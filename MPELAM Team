//@version=5
indicator('Volume Logic Trading Assistant', max_bars_back = 5000,max_boxes_count=200, overlay = false)

//                                  ╔════════════════════════════════════════════════════════════════════════════════════════════╗
//                                  ║                                                                                            ║
//                                  ║                                  ⚡ Volume Logic Trading Assistant ⚡                        ║
//                                  ║                                          Manuel "MrM"                                      ║
//                                  ║                                                                                            ║
//                                  ╚════════════════════════════════════════════════════════════════════════════════════════════╝

//                                      ┌─────────────────────────────────────────────────────────────────────────────────────┐
//                                      │  COPYRIGHT NOTICE - GNU GPL v3                                                      │
//                                      │                                                                                     │
//                                      │  Copyright (C) 2025 MPELAM Team                                                     │
//                                      │  Email: manuelmarmaglio@gmail.com (Oggetto: TRADING)                                │
//                                      │                                                                                     │
//                                      │                                                                                     │
//                                      │  Licenza: GNU General Public License v3+                                            │
//                                      │  Redistribuzione: Consentita solo con attribuzione completa                         │
//                                      │  Disclaimer: NESSUNA GARANZIA - USA A TUO RISCHIO E PERICOLO                        │
//                                      │                                                                                     │          
//                                      └─────────────────────────────────────────────────────────────────────────────────────┘
                        
//                                  ⚙️ CONFIGURAZIONE SISTEMA:
//                                  ⚠️  ATTENZIONE: BBars DEVE ESSERE NUMERO PARI 


// Starter Pack
// -----------------------------------------------------------{

import MPELAM/Definitive_Library/28 as M 
var int counting = 0

// Var
// -----------------------------------------------------------{

// ═══════════════════════════════════════════════════════════════════════════════════════
// TIMEFRAME E ANALISI TEMPORALE
// ═══════════════════════════════════════════════════════════════════════════════════════
var string current_timeframe             = timeframe.period                                  // Timeframe corrente

timeframe_level = M.timeframe_level_function(current_timeframe)
 
var int lenght_ema = current_timeframe == "S" or current_timeframe == "1S" or current_timeframe == "5S" or current_timeframe == "10S" or current_timeframe == "15S" or current_timeframe == "30S" ? 13 : current_timeframe == "45S" or current_timeframe == "1" or current_timeframe == "1m" or current_timeframe == "2" or current_timeframe == "2m" ? 11 : current_timeframe == "3" or current_timeframe == "3m" or current_timeframe == "5" or current_timeframe == "5m" or current_timeframe == "10" or current_timeframe == "10m" ? 7 : current_timeframe == "15" or current_timeframe == "15m" or current_timeframe == "30" or current_timeframe == "30m" or current_timeframe == "45" or current_timeframe == "45m" ? 5 : current_timeframe == "60" or current_timeframe == "1H" or current_timeframe == "1h" or current_timeframe == "120" or current_timeframe == "2H" or current_timeframe == "2h" or current_timeframe == "180" or current_timeframe == "3H" or current_timeframe == "3h" or current_timeframe == "240" or current_timeframe == "4H" or current_timeframe == "4h" or current_timeframe == "360" or current_timeframe == "6H" or current_timeframe == "6h" or current_timeframe == "480" or current_timeframe == "8H" or current_timeframe == "8h" or current_timeframe == "720" or current_timeframe == "12H" or current_timeframe == "12h" ? 3 : current_timeframe == "D" or current_timeframe == "1D" or current_timeframe == "d" or current_timeframe == "W" or current_timeframe == "1W" or current_timeframe == "w" or current_timeframe == "M" or current_timeframe == "1M" ? 2 : -99

// ═══════════════════════════════════════════════════════════════════════════════════════
// CONFIGURAZIONE GENERALE E INPUT
// ═══════════════════════════════════════════════════════════════════════════════════════
var percent                              = input.float(title='% pesata di volume', defval=65, minval=1, maxval = 100) // Percentuale peso volume VAH/VAL
bbars                                    = input.int(title='Number of Bars - inserire un numero pari', defval=400, minval=1) // Numero barre per analisi
var int original_bbars                   = bbars                                             // Backup valore originale bbars
int bbars_2                              = bbars / 2                                         // Metà delle barre per pivot
var int bar_limit                        = 1500                                              // Limite massimo barre computazione
var bool ancoraggio_pivot                = true                                              // Ancoraggio bbars al pivot
var bool auto_pivot_vol                  = true                                              // Adattamento posizioni cover al volume
var bool fast_play                       = true                                              // Uso primo pivot disponibile
var bool block_start_bar                 = false                                             // Flag blocco avvio analisi
var bool fast_cover_setting              = true                                              // Gestione cover su inefficienze rapide
var float incremento_resistenze_pivot    = 1.5                                               // Moltiplicatore distanza resistenze
var float run                            = 0                                                 // Contatore stati esecuzione
var int contatore                        = 0                                                 // Contatore barre aggiuntive
var int original_bbars_old               = original_bbars - 1                                // Backup bbars precedente
var int cnum                             = 100                                               // Numero canali volume profilo

// ═══════════════════════════════════════════════════════════════════════════════════════
// GESTIONE SPREAD E ASSET
// ═══════════════════════════════════════════════════════════════════════════════════════
var float min_0_3                        = close / 100 * 0.2                                // Distanza minima posizioni cover

// ═══════════════════════════════════════════════════════════════════════════════════════
// PERCENTILI VIX E SENTIMENT
// ═══════════════════════════════════════════════════════════════════════════════════════
var float p05                            = 12.29                                            // Percentile VIX 5%
var float p15                            = 13.15                                            // Percentile VIX 15%
var float p35                            = 15.38                                            // Percentile VIX 35%
var float p50                            = 16.55                                            // Percentile VIX 50%
var float p70                            = 19.27                                            // Percentile VIX 70%
var float p85                            = 22.65                                            // Percentile VIX 85%
var float p93                            = 26.91                                            // Percentile VIX 93%
var float p98                            = 33.81                                            // Percentile VIX 98%

// ═══════════════════════════════════════════════════════════════════════════════════════
// SUPPORTI E RESISTENZE
// ═══════════════════════════════════════════════════════════════════════════════════════
var a_sup                                = array.new_float(0)                               // Array pivot non vergini
var float actual_supporto                = na                                               // Supporto attuale dinamico
var float actual_resistenza              = na                                               // Resistenza attuale dinamica
var int support_switch_bar               = na                                               // Barra switch supporto
var int res_switch_bar                   = na                                               // Barra switch resistenza
var float actual_old_supporto            = na                                               // Supporto vecchio per confronto
var float actual_old_resistenza          = na                                               // Resistenza vecchia per confronto
var int support_switch_bar_old           = na                                               // Barra switch supporto vecchio
var int res_switch_bar_old               = na                                               // Barra switch resistenza vecchia
var bool bot_is_sup                      = false                                            // Flag bot corrisponde a supporto
var bool top_is_res                      = false                                            // Flag top corrisponde a resistenza

// ═══════════════════════════════════════════════════════════════════════════════════════
// LIVELLI TOP/BOT E BREAKOUT
// ═══════════════════════════════════════════════════════════════════════════════════════
var float bot                            = na                                               // Livello bottom del range
var float top                            = na                                               // Livello top del range
var bool up_breakout                     = false                                            // Flag breakout rialzista
var bool down_breakout                   = false                                            // Flag breakout ribassista
var float distanza_break_out_up          = na                                               // Distanza breakout rialzista
var float distanza_break_out_down        = na                                               // Distanza breakout ribassista
var float bot_in_up_break_out            = na                                               // Bot al momento breakout up
var float top_in_down_break_out          = na                                               // Top al momento breakout down

// ═══════════════════════════════════════════════════════════════════════════════════════
// LIQUIDITÀ E PIVOT
// ═══════════════════════════════════════════════════════════════════════════════════════
var float bot_liq                        = na                                               // Liquidità base ancorata pivot bottom
var float top_liq                        = na                                               // Liquidità base ancorata pivot top
var float save_bot_liq                   = na                                               // Backup liquidità bottom per bar_limit
var float save_top_liq                   = na                                               // Backup liquidità top per bar_limit
var bool bot_liq_modified                = false                                            // Flag modifica liquidità bottom
var bool top_liq_modified                = false                                            // Flag modifica liquidità top

// ═══════════════════════════════════════════════════════════════════════════════════════
// CONTROLLI E BLOCCHI
// ═══════════════════════════════════════════════════════════════════════════════════════
var bool bot_block                       = false                                            // Blocco logica bottom
var bool top_block                       = false                                            // Blocco logica top
var bool bot_block_fast                  = false                                            // Blocco fast bottom
var bool top_block_fast                  = false                                            // Blocco fast top
var bool bar_reach                       = false                                            // Flag raggiungimento bar_limit

// ═══════════════════════════════════════════════════════════════════════════════════════
// DISTANZE E MEDIE VOLUME
// ═══════════════════════════════════════════════════════════════════════════════════════
var float piv_distance                   = input.float(title='Distanza di prezzo per posizioni cover', defval=50, minval=1) // Distanza base pivot
var float media_mom                      = na                                               // Media momentum range
var float piv_distance_1                 = na                                               // Distanza scalare livello 1
var float piv_distance_2                 = na                                               // Distanza scalare livello 2
var float piv_distance_3                 = na                                               // Distanza scalare livello 3
var float piv_distance_1_res             = na                                               // Distanza resistenze livello 1
var float piv_distance_2_res             = na                                               // Distanza resistenze livello 2
var float piv_distance_3_res             = na                                               // Distanza resistenze livello 3
var float bot_mom                        = na                                               // Bottom momentum temporaneo
var float top_mom                        = na                                               // Top momentum temporaneo
var int contatore_try                    = na                                               // Contatore tentativi pivot
var int contatore_media                  = 0                                                // Contatore per calcolo media
var float media                          = 0                                                // Accumulo per media range
var float media_vol                      = na                                               // Media volume finale
var float actual_media_vol               = na                                               // Media volume corrente

// ═══════════════════════════════════════════════════════════════════════════════════════
// SUPPORTI/RESISTENZE COVER SCALARI
// ═══════════════════════════════════════════════════════════════════════════════════════
var int actual_support_over_bot_perc     = 0                                                // Percentuale supporto sopra bottom

// ═══════════════════════════════════════════════════════════════════════════════════════
// ARRAY PIVOT E TRACKING
// ═══════════════════════════════════════════════════════════════════════════════════════
var float[] high_pivots                  = array.new_float(0)                              // Array pivot high
var float[] low_pivots                   = array.new_float(0)                              // Array pivot low
var int[] high_bar_indices               = array.new_int(0)                                // Indici barre pivot high
var int[] low_bar_indices                = array.new_int(0)                                // Indici barre pivot low

// ═══════════════════════════════════════════════════════════════════════════════════════
// VOLUME PROFILE E POC
// ═══════════════════════════════════════════════════════════════════════════════════════
float[] totalvols                        = array.new_float(cnum, 0.)                        // Array volumi totali
var float vol_value                      = na                                               // Valore volume corrente
var float poc_level                      = na                                               // Livello Point of Control
var float vah_level                      = na                                               // Livello Value Area High
var float val_level                      = na                                               // Livello Value Area Low
var float poc_bot_level                  = na                                               // POC bottom level
var float poc_top_level                  = na                                               // POC top level
var float poc_second_level               = na                                               // Secondo POC più significativo
var bool poc_is_buy                      = false                                            // Flag POC rialzista/ribassista
var float val_to_bot_volume_perc         = na                                               // Percentuale volume VAL-BOT
var float vah_to_top_volume_perc         = na                                               // Percentuale volume VAH-TOP
var float central_volume_perc            = na                                               // Percentuale volume centrale
var float vah_to_poc_vol_ratio           = na                                               // Ratio volume VAH/POC
var float poc_2_to_poc_vol_ratio         = na                                               // Ratio volume POC2/POC
var float val_to_poc_vol_ratio           = na                                               // Ratio volume VAL/POC

// ═══════════════════════════════════════════════════════════════════════════════════════
// PERCENTUALI E TRIGGER
// ═══════════════════════════════════════════════════════════════════════════════════════
var int vah_perc                         = na                                               // Percentuale VAH nel range
var int poc_perc                         = na                                               // Percentuale POC nel range
var int poc_2_perc                       = na                                               // Percentuale POC2 nel range
var int val_perc                         = na                                               // Percentuale VAL nel range
var int bot_liq_perc                     = na                                               // Percentuale liquidità bottom
var int top_liq_perc                     = na                                               // Percentuale liquidità top
var int low_perc                         = na                                               // Percentuale low corrente
var int high_perc                        = na                                               // Percentuale high corrente
var float vol_distance_perc              = na                                               // Percentuale distanza volume

// ═══════════════════════════════════════════════════════════════════════════════════════
// BREAKOUT E MOMENTUM
// ═══════════════════════════════════════════════════════════════════════════════════════
var float break_out_up_perc_mom          = na                                               // Percentuale breakout up momentum
var float break_out_down_perc_mom        = na                                               // Percentuale breakout down momentum
var float distanza_break_out_up_post     = na                                               // Distanza post breakout up
var float break_out_up_perc              = na                                               // Percentuale breakout up
var float break_out_up_top_perc          = na                                               // Percentuale top breakout up
var float break_out_down_perc            = na                                               // Percentuale breakout down
var float distanza_break_out_post_mom_up = na                                               // Distanza post momentum up
var float distanza_break_out_down_post   = na                                               // Distanza post breakout down
var float break_out_down_top_perc        = na                                               // Percentuale top breakout down
var int breakout_bar_index_down          = 0                                                // Indice barra breakout down
var float distanza_break_out_post_mom_down = na                                             // Distanza post momentum down

// ═══════════════════════════════════════════════════════════════════════════════════════
// COLORI E VISUALIZZAZIONE
// ═══════════════════════════════════════════════════════════════════════════════════════
var bool show_plot                       = true                                             // Flag visualizzazione grafica
var color headerColor                    = color.new(color.gray, 20)                      // Colore header tabelle
var color positiveColor                  = color.new(color.green, 60)                     // Colore valori positivi
var color negativeColor                  = color.new(color.red, 60)                       // Colore valori negativi
var color vah_color                      = na                                               // Colore dinamico VAH
var color val_color                      = na                                               // Colore dinamico VAL
var color poc_color                      = na                                               // Colore dinamico POC
var color poc_2_color                    = na                                               // Colore dinamico POC2
var color vup_color                      = positiveColor                                    // Colore volume rialzista
var color vdown_color                    = negativeColor                                    // Colore volume ribassista
var color up_color                       = color.new(color.green, 70)                     // Colore up standard
var color down_color                     = color.new(color.red, 70)                       // Colore down standard
var int poc_width                        = 1                                                // Spessore linea POC
var int vah_width                        = 1                                                // Spessore linea VAH
var int val_width                        = 1                                                // Spessore linea VAL
var int ext_width                        = 1                                                // Spessore linee estreme

// ═══════════════════════════════════════════════════════════════════════════════════════
// LINEE E ELEMENTI GRAFICI
// ═══════════════════════════════════════════════════════════════════════════════════════
var line poc_line                        = na                                               // Linea POC
var line poc_2_line                      = na                                               // Linea secondo POC
var line top_line                        = na                                               // Linea top range
var line bot_line                        = na                                               // Linea bottom range
var line upper_line                      = na                                               // Linea VAH
var line lower_line                      = na                                               // Linea VAL
var line lower_line_liq                  = na                                               // Linea liquidità bottom
var line higher_line_liq                 = na                                               // Linea liquidità top
var line poc_bot_level_line              = na                                               // Linea livello POC bottom
var line poc_top_level_line              = na                                               // Linea livello POC top
var line res_line                        = na                                               // Linea resistenza principale
var line sup_line                        = na                                               // Linea supporto principale
var line res_line_1                      = na                                               // Linea resistenza livello 1
var line sup_line_1                      = na                                               // Linea supporto livello 1
var line res_line_2                      = na                                               // Linea resistenza livello 2
var line sup_line_2                      = na                                               // Linea supporto livello 2
var line res_line_3                      = na                                               // Linea resistenza livello 3
var line sup_line_3                      = na                                               // Linea supporto livello 3

// ═══════════════════════════════════════════════════════════════════════════════════════
// VOLUME PROFILE BOXES E STORAGE
// ═══════════════════════════════════════════════════════════════════════════════════════
var vol_bars                             = array.new_box(cnum * 2, na)                      // Array boxes volume profile

// ═══════════════════════════════════════════════════════════════════════════════════════
// LABEL E TRACKING EVENTI
// ═══════════════════════════════════════════════════════════════════════════════════════
var label[] saved_labels                 = array.new_label()                                // Array label salvate
var label vol_break_up_perc_mom_label    = na                                               // Label breakout up momentum
var label vol_break_down_perc_mom_label  = na                                               // Label breakout down momentum

// ═══════════════════════════════════════════════════════════════════════════════════════
// LINEAR REGRESSION E TREND
// ═══════════════════════════════════════════════════════════════════════════════════════
var float lr_vol_perc                    = na                                               // Percentuale volume linear regression
var bool useUpperDevInput_lr             = true                                             // Flag deviazione superiore LR
var float upperMultInput_lr              = 2                                                // Moltiplicatore deviazione superiore
var bool useLowerDevInput_lr             = true                                             // Flag deviazione inferiore LR
var float lowerMultInput_lr              = 2                                                // Moltiplicatore deviazione inferiore
var bool showPearsonInput_lr             = true                                             // Flag visualizzazione Pearson
var bool extendLeftInput_lr              = false                                            // Flag estensione sinistra LR
var bool extendRightInput_lr             = false                                            // Flag estensione destra LR
var line upper_lr                        = na                                               // Linea deviazione superiore LR
var line lower_lr                        = na                                               // Linea deviazione inferiore LR
var line baseLine_lr                     = na                                               // Linea base LR
var float prev_pearsonR                  = na                                               // Pearson precedente
var float prev_percent_change            = na                                               // Cambio percentuale precedente
var float perc_pearson                   = na                                               // Percentuale Pearson
var bool trend_up                        = false                                            // Flag trend rialzista
var float perc_trend                     = na                                               // Percentuale trend

// ═══════════════════════════════════════════════════════════════════════════════════════
// FIBONACCI E TARGET
// ═══════════════════════════════════════════════════════════════════════════════════════
var float fib_for_break                  = na                                               // Fibonacci per breakout
var float fib_for_scenario               = na                                               // Fibonacci per scenari
var float fib_val_value                  = na                                               // Valore Fibonacci VAL
var float fib_vah_value                  = na                                               // Valore Fibonacci VAH
var float fib_perc_0                     = 0                                                // Livello Fibonacci 0%
var float fib_perc_1                     = 23.6                                             // Livello Fibonacci 23.6%
var float fib_perc_2                     = 38.2                                             // Livello Fibonacci 38.2%
var float fib_perc_3                     = 50                                               // Livello Fibonacci 50%
var float fib_perc_4                     = 61.8                                             // Livello Fibonacci 61.8%
var float fib_perc_5                     = 78.6                                             // Livello Fibonacci 78.6%
var float fib_perc_6                     = 100                                              // Livello Fibonacci 100%

// ═══════════════════════════════════════════════════════════════════════════════════════
// EMA E VALIDAZIONE LIVELLI
// ═══════════════════════════════════════════════════════════════════════════════════════
var float ema_switch_perc                = na                                               // Percentuale switch EMA
var bool val_is_in_buy                   = false                                            // Flag VAL validato per buy
var bool vah_is_in_buy                   = false                                            // Flag VAH validato per buy
var bool poc_is_in_buy                   = false                                            // Flag POC validato per buy
var bool poc_2_is_in_buy                 = false                                            // Flag POC2 validato per buy
var bool bot_liq_is_in_buy               = false                                            // Flag liquidità bottom per buy
var bool act_sup_is_in_buy               = false                                            // Flag supporto attuale per buy
var float ema_value_before_start         = na                                               // Valore EMA prima dello start
var int contatore_ema_switch_down        = na                                               // Contatore switch EMA down
var float last_ema_switch_down           = na                                               // Ultimo switch EMA down
var float prezzo_interpolato_lr_start    = na                                               // Prezzo interpolato LR start

// ═══════════════════════════════════════════════════════════════════════════════════════
// ANALISI MERCATO E PATTERN
// ═══════════════════════════════════════════════════════════════════════════════════════
var string market                        = na                                               // Stato del mercato
var bool active_mid_trade                = false                                            // Flag trading intermedio attivo
var string market_buy_pattern            = na                                               // Pattern di acquisto identificato
var float low_level                      = na                                               // Livello basso di riferimento
var int start_perc                       = na                                               // Percentuale di partenza
var int new_poc_perc                     = na                                               // Nuovo POC percentuale
var float break_start_perc               = na                                               // Percentuale inizio break

// ═══════════════════════════════════════════════════════════════════════════════════════
// TARGET E LIVELLI DINAMICI
// ═══════════════════════════════════════════════════════════════════════════════════════
var float siffredi_lower_target                   = na                                               // Target inferiore principale
var float siffredi_higher_target                  = na                                               // Target superiore principale
var float lower_target_bot               = na                                               // Target inferiore bottom
var float higher_target_bot              = na                                               // Target superiore bottom
var float lower_target_act_sup_over_bot  = na                                               // Target supporto sopra bottom
var float higher_target_act_sup_over_bot = na                                               // Target superiore supporto
var int save_start_perc                  = na                                               // Percentuale start salvata
var bool save_start_perc_bool            = false                                            // Flag salvataggio percentuale
var float mid_ask                        = na                                               // Prezzo ask intermedio
var int mid_perc_min                     = 0                                                // Percentuale minima intermedia
var int mid_perc_mid                     = 0                                                // Percentuale media intermedia
var float mid_lower_target               = na                                               // Target inferiore intermedio
var float mid_higher_target              = na                                               // Target superiore intermedio

// ═══════════════════════════════════════════════════════════════════════════════════════
// ARRAY E STRUTTURE DATI
// ═══════════════════════════════════════════════════════════════════════════════════════
var orig_perc_array                      = array.new_float(6)                              // Array percentuali originali

// ═══════════════════════════════════════════════════════════════════════════════════════
// VOLUME ANALYSIS
// ═══════════════════════════════════════════════════════════════════════════════════════
var string volume_top_condition          = na                                               // Condizione volume area superiore
var string volume_mid_condition          = na                                               // Condizione volume area centrale
var string volume_bot_condition          = na                                               // Condizione volume area inferiore
var int top_level_vol                    = na                                               // Livello volume superiore (1-5)
var int mid_level_vol                    = na                                               // Livello volume centrale (1-5)
var int bot_level_vol                    = na                                               // Livello volume inferiore (1-5)

// ═══════════════════════════════════════════════════════════════════════════════════════
// GESTIONE POSIZIONI E CONTATORI
// ═══════════════════════════════════════════════════════════════════════════════════════
var int tot_position                     = 0                                                // Totale posizioni aperte
var int tot_position_cover               = 0                                                // Totale posizioni cover
var float break_ask                      = na                                               // Prezzo ask per breakout
var float siffredi_ask                      = na                                            // Prezzo ask per breakout basso
var int open_position_mid                = 0                                                // Posizioni intermedie aperte
var int open_position_break              = 0                                                // Posizioni breakout aperte
var int posizione_attive_no_cover        = 0                                                // Posizioni attive senza cover

// ═══════════════════════════════════════════════════════════════════════════════════════
// SCENARI BOT E LIQUIDITÀ
// ═══════════════════════════════════════════════════════════════════════════════════════
var float first_bot_liq                  = na                                               // Prima liquidità bottom salvata
var float first_bot                      = na                                               // Primo bottom salvato
var int bot_liq_perc_used                = na                                               // Percentuale liquidità bot utilizzata
var bool scenario_bot_line               = false                                            // Flag scenario bottom attivo
var bool scenario_bot_2_line             = false                                            // Flag secondo scenario bottom
var int scenario_bot_line_to_h           = 0                                                // Scenario bot verso high
var int scenario_bot_line_to_l           = 0                                                // Scenario bot verso low
var float scenario_bot_ask_to_h          = 0                                                // Ask scenario bot high
var float scenario_bot_ask_to_l          = 0                                                // Ask scenario bot low

// ═══════════════════════════════════════════════════════════════════════════════════════
// SUPPORTI COVER SCALARI
// ═══════════════════════════════════════════════════════════════════════════════════════
var float supporto_1                     = na                                               // Supporto cover livello 1
var float supporto_2                     = na                                               // Supporto cover livello 2
var float supporto_3                     = na                                               // Supporto cover livello 3
var float supporto_4                     = na                                               // Supporto cover livello 4

// ═══════════════════════════════════════════════════════════════════════════════════════
// SCENARI COVER E TRIGGER
// ═══════════════════════════════════════════════════════════════════════════════════════
var bool cover_1_line                    = false                                            // Flag cover livello 1 attivo
var bool cover_2_line                    = false                                            // Flag cover livello 2 attivo
var bool cover_3_line                    = false                                            // Flag cover livello 3 attivo
var bool cover_4_line                    = false                                            // Flag cover livello 4 attivo
var bool supporto_cover_trig_1           = false                                            // Trigger supporto cover 1
var bool supporto_cover_trig_2           = false                                            // Trigger supporto cover 2
var bool supporto_cover_trig_3           = false                                            // Trigger supporto cover 3
var bool supporto_cover_trig_4           = false                                            // Trigger supporto cover 4

// ═══════════════════════════════════════════════════════════════════════════════════════
// SCENARI COVER - PARAMETRI OPERATIVI
// ═══════════════════════════════════════════════════════════════════════════════════════
var int scenario_cover_1_line_to_h       = 0                                                // Cover 1 verso high
var int scenario_cover_1_line_to_l       = 0                                                // Cover 1 verso low
var float scenario_cover_1_ask_to_h      = 0                                                // Ask cover 1 high
var float scenario_cover_1_ask_to_l      = 0                                                // Ask cover 1 low
var int scenario_cover_2_line_to_h       = 0                                                // Cover 2 verso high
var int scenario_cover_2_line_to_l       = 0                                                // Cover 2 verso low
var float scenario_cover_2_ask_to_h      = 0                                                // Ask cover 2 high
var float scenario_cover_2_ask_to_l      = 0                                                // Ask cover 2 low
var int scenario_cover_3_line_to_h       = 0                                                // Cover 3 verso high
var int scenario_cover_3_line_to_l       = 0                                                // Cover 3 verso low
var float scenario_cover_3_ask_to_h      = 0                                                // Ask cover 3 high
var float scenario_cover_3_ask_to_l      = 0                                                // Ask cover 3 low
var int scenario_cover_4_line_to_h       = 0                                                // Cover 4 verso high
var int scenario_cover_4_line_to_l       = 0                                                // Cover 4 verso low
var float scenario_cover_4_ask_to_h      = 0                                                // Ask cover 4 high
var float scenario_cover_4_ask_to_l      = 0                                                // Ask cover 4 low

// ═══════════════════════════════════════════════════════════════════════════════════════
// SCENARI POSIZIONI INTERMEDIE
// ═══════════════════════════════════════════════════════════════════════════════════════
var int scenario_val_to_bot_target_line  = 0                                                // Scenario VAL verso bot target
var float scenario_val_to_bot_target_ask = 0                                                // Ask VAL verso bot target
var int scenario_poc_to_bot_target_line  = 0                                                // Scenario POC verso bot target
var float scenario_poc_to_bot_target_ask = 0                                                // Ask POC verso bot target
var int scenario_poc_2_to_bot_target_line = 0                                               // Scenario POC2 verso bot target
var float scenario_poc_2_to_bot_target_ask = 0                                              // Ask POC2 verso bot target
var int scenario_vah_to_bot_target_line  = 0                                                // Scenario VAH verso bot target
var float scenario_vah_to_bot_target_ask = 0                                                // Ask VAH verso bot target
var int scenario_val_to_higher_line     = 0                                                 // Scenario VAL verso higher
var float scenario_val_to_higher_ask    = 0                                                 // Ask VAL verso higher

// ═══════════════════════════════════════════════════════════════════════════════════════
// SCENARI SPECIALI E BREAKOUT
// ═══════════════════════════════════════════════════════════════════════════════════════
var int scenario_actual_over_bot_line    = 0                                                // Scenario supporto sopra bot
var float scenario_actual_over_bot_ask   = 0                                                // Ask supporto sopra bot
var int scenario_break_out_line          = 0                                                // Scenario breakout attivo
var float scenario_break_out_ask         = 0                                                // Ask breakout

// ═══════════════════════════════════════════════════════════════════════════════════════
// CONTATORI POSIZIONI PER TIPOLOGIA
// ═══════════════════════════════════════════════════════════════════════════════════════
var float target_res                     = na                                               // Target resistenza
var int tot_position_scenario_bot        = 0                                                // Totale posizioni scenario bot
var bool close_alarm_mid                 = false                                            // Allarme chiusura posizioni mid
var int tot_position_scenario_cover_1    = 0                                                // Totale posizioni cover livello 1
var int tot_position_scenario_cover_2    = 0                                                // Totale posizioni cover livello 2
var int tot_position_scenario_cover_3    = 0                                                // Totale posizioni cover livello 3
var int tot_position_scenario_cover_4    = 0                                                // Totale posizioni cover livello 4
var int last_cover                       = 0                                                // Ultimo livello cover utilizzato

// ═══════════════════════════════════════════════════════════════════════════════════════
// GESTIONE SCENARI SPECIALI
// ═══════════════════════════════════════════════════════════════════════════════════════
var float take_val_to_top                = na                                               // Take profit VAL verso top
var float top_data_compression           = na                                               // Dati compressione superiore
var string pendant_trig                  = na                                               // Trigger scenario pendant
var bool siffredi_fatta                  = false                                            // Flag scenario Siffredi eseguito
var bool break_fail                      = false                                            // Flag fallimento breakout
var bool target_upper_lr                 = false                                            // Flag target linear regression superiore

// ----------------------------------------}

//Interpolazione di prezzo per evitare falsi segnali 
var float upperStartPrice_lr = na 
var float upperEndPrice_lr = na 
var float lowerStartPrice_lr = na 
var float lowerEndPrice_lr = na 
var float pearson = na 
var float lower_lr_perc = na 
var float upper_lr_perc = na 
var bool ema_over_lr = false
var bool ema_switch_down = false 
var bool ema_switch_up = false 
var bool stop_profit = false 
var bool siffredi_cover_line = false 
var string block_cover_open = na 
var int scenario_siffredi_cover_line = 0 
var float scenario_siffredi_cover_ask = 0 


// Gestione titoli e timframe
// -----------------------------------------------------------{

var int lenght_pivot_order_block = timeframe_level > 0 ? 1 : 2

[spread, n_titoli, titolo] = M.title_spread_n_titoli_function(counting)
//
var float moltiplicatore_break  = timeframe_level == 1 ? 1 : timeframe_level == 2  ? 2 : timeframe_level > 2  ? 2 : 1 
var float moltiplicatore_mid    = timeframe_level == 1 ? 2 : timeframe_level == 3  ? 2 : timeframe_level > 2  ? 3 : 2 
var float moltiplicatore_bot    = timeframe_level == 1 ? 2 : timeframe_level == 2  ? 2 : timeframe_level > 2  ? 3 : 1 
var float moltiplicatore_cover  = timeframe_level == 1 ? 2 : timeframe_level == 3  ? 2 : timeframe_level > 2  ? 3 : 2 

var float  n_titoli_moltiplicatore_break = na
var float  n_titoli_moltiplicatore_mid   = na
var float  n_titoli_moltiplicatore_bot   = na
var float  n_titoli_moltiplicatore_cover = na

if not na(titolo) and na(n_titoli_moltiplicatore_break)
    n_titoli_moltiplicatore_break := n_titoli * moltiplicatore_break
    n_titoli_moltiplicatore_mid   := n_titoli * moltiplicatore_mid  
    n_titoli_moltiplicatore_bot   := n_titoli * moltiplicatore_bot  
    n_titoli_moltiplicatore_cover := n_titoli * moltiplicatore_cover
//

// Ottieni l'ultimo valore del VIX
vix = request.security("CAPITALCOM:VIX", current_timeframe, close)

// Determina lo stato del VIX tramite semplici confronti
status = vix >= p98 ? "PANICO" : vix >= p93 ? "CRITICO" : vix >= p85 ? "ALTO" : vix >= p70 ? "ELEVATO" : vix >= p50 ? "NORMALE" : vix >= p35 ? "BASSO" : vix >= p15 ? "MOLTO BASSO" : "COMPIACENZA"

// Assegnazione valori in base allo status
[min_level, mid_level, sentiment_level, incremento_distanza_pivot] = M.valori_status(status, timeframe_level)

// Colore basato sullo stato
col = vix >= p93 ? color.red : vix >= p85 ? color.orange : vix >= p70 ? color.yellow : vix >= p35 ? color.gray : color.green
//

// ----------------------------------------}

// Strutture di base
// -----------------------------------------------------------{

//Vengono confrontati diversi livelli di pivot, il pivot old e quello normale servono per i margini di gioco, quelli fast per il sistema ad inefficienza rapida per le posizioni cover (rappresenza un rischio a timeframe bassi quando la volatilità implicita è elevata e vengono infinte usati dei sistemi di pivot 1,1 per controllare la liquidità interna (pivot basso per top e alto per bot))
//Gestione supporti e resistenze 
supporto                                 = bar_index > 1 ? ta.pivotlow  (low,  bbars_2, bbars_2)   : na 
resistenza                               = bar_index > 1 ? ta.pivothigh (high, bbars_2, bbars_2)   : na 

switch_supporto                          = not na(supporto)
switch_resistenza                        = not na(resistenza)

var float actual_supporto_old_3 = na 
var float actual_supporto_old_2 = na 
var float actual_supporto_old_1 = na 

if switch_supporto    
    actual_supporto_old_3               := actual_supporto_old_2
    actual_supporto_old_2               := actual_supporto_old_1
    actual_supporto_old_1               := actual_supporto
    actual_supporto                     := supporto  
    support_switch_bar                  := bar_index - bbars_2 - 1 // Indica il punto in cui il low corrisponde all'actual supporto 
    if not fast_cover_setting
        array.push(a_sup, supporto)

    if bot_liq_modified 
        bot_liq_modified                := false 
//

if switch_resistenza  
    actual_resistenza                   := resistenza  
    res_switch_bar                      := bar_index - bbars_2 - 1 // Indica il punto in cui il low corrisponde all'actual supporto 
    if not fast_cover_setting
        array.push(a_sup, resistenza)

    if top_liq_modified 
        top_liq_modified                := false 
//

supporto_fast                            = bar_index > 1000 ? ta.pivotlow  (low,  13, 13)   : na 
resistenza_fast                          = bar_index > 1000 ? ta.pivothigh (high, 13, 13)   : na 

switch_supporto_fast                     = not na(supporto_fast)
switch_resistenza_fast                   = not na(resistenza_fast)

if switch_supporto_fast    
    if fast_cover_setting
        array.push(a_sup, supporto_fast)
//

if switch_resistenza_fast  
    if fast_cover_setting
        array.push(a_sup, resistenza_fast)
//
//Gestione supporti e resistenze 
supporto_old                             = bar_index > 100 ? ta.pivotlow  (low,  original_bbars_old, original_bbars_old)   : na 
resistenza_old                           = bar_index > 100 ? ta.pivothigh (high, original_bbars_old, original_bbars_old)   : na 

switch_supporto_old                      = not na(supporto_old)
switch_resistenza_old                    = not na(resistenza_old)

if switch_supporto_old    
    actual_old_supporto                 := supporto_old 
    support_switch_bar_old              := bar_index - original_bbars_old - 1 // Indica il punto in cui il low corrisponde all'actual supporto 

//
if switch_resistenza_old  
    actual_old_resistenza               := resistenza_old 
    res_switch_bar_old                  := bar_index - original_bbars_old - 1 // Indica il punto in cui il low corrisponde all'actual supporto 
//

// Elimino i pivot non vergini dall'array, iterando sia supporti che resistenze nello stesso array vengono prese le inefficienze di apertura di mercato come posizione cover.
int size                                 = array.size(a_sup)
for i = 0 to size - 1
    int j                                = size - 1 - i
    if j >= 0 and j < array.size(a_sup)  // Controllo di sicurezza
        level                            = array.get(a_sup, j)
        if high >= level and low <= level
            array.remove(a_sup, j)
//

//Utilizzo bot max quando le bbars non sono bloccate, questo evita problemi di iterazione di ta. che oggettivamente fanno schifo se modificati in lenght
bot_max                                  = ta.lowest(low, original_bbars)
top_max                                  = ta.highest(high, original_bbars)
//

if run == 0 and not na(bot_max)
    contatore_media                     += 1 
    media                               := timeframe_level > 0 ? media + ((top_max - bot_max) / 2) : media + ((top_max - bot_max))
//

if barstate.islastconfirmedhistory
    media_mom                           := media / contatore_media
    media_vol                           := math.max(media_mom, min_0_3)
    piv_distance                        := media_vol
    piv_distance_1                      := piv_distance   * incremento_distanza_pivot
    piv_distance_2                      := piv_distance_1 * incremento_distanza_pivot
    piv_distance_3                      := piv_distance_2 * incremento_distanza_pivot
    piv_distance_1_res                  := piv_distance   * incremento_resistenze_pivot
    piv_distance_2_res                  := piv_distance_1_res * incremento_resistenze_pivot
    piv_distance_3_res                  := piv_distance_2_res * incremento_resistenze_pivot
//

//Questa struttura serve per ancora la bbars al pivot quando il codice è startato in run == 1 

if tot_position[1] == 0
    //Questo è lo start del codice oltre che lo switch di pivot, tendenzilmente vengono cercati prima i supporti chiave e poi eventuali resistenze che indicano cadute, questa scelta è stata operata per attendere un certo numero di candele prima di switchare il pivot evitando di perdere i volumi della caduta precedente.
    if ((run == 0 and barstate.islastconfirmedhistory) or bar_reach[1] or (run > 1 and not block_start_bar)) and ancoraggio_pivot and ((bar_index - support_switch_bar - 1)) < bar_limit and ((bar_index - support_switch_bar - original_bbars)) > 0 and actual_supporto <= bot
        contatore_try                   := bar_index - original_bbars - support_switch_bar
        top_mom                         := 0
        bot_mom                         := 9999999 
        for i = 1 to (bbars + contatore_try) //Eseguo un mini test rapido ad ogni switch per assisurarmi di non avere schiacciamenti di volume, lo switch a livello grafico causa spesso crash del codice, tuttavia a livello di alert funzona anche a 1s perchè vengono eliminati automaticamente i sistemi di plottaggio del codice (non serve mettere showplot false per farlo funzionare)
            if high[i] > top_mom
                top_mom                 := high[i]
            if low[i] < bot_mom 
                bot_mom                 := low[i] 
        actual_media_vol                := top_mom - bot_mom
        if actual_media_vol > media_vol 
            contatore                   := bar_index - original_bbars - support_switch_bar
            block_start_bar             := true 
            bot_block_fast              := true
        //
    //
    if ((run == 0 and barstate.islastconfirmedhistory) or bar_reach[1] or (run > 1 and not block_start_bar)) and not bot_block_fast and ancoraggio_pivot and ((bar_index - res_switch_bar - 1)) < bar_limit and ((bar_index - res_switch_bar - original_bbars)) > 0 and not bot_block
        contatore_try                   := bar_index - original_bbars - res_switch_bar
        top_mom                         := 0
        bot_mom                         := 9999999 
        for i = 1 to (bbars + contatore_try) 
            if high[i] > top_mom
                top_mom                 := high[i]
            if low[i] < bot_mom 
                bot_mom                 := low[i] 
        actual_media_vol                := top_mom - bot_mom
        if actual_media_vol > media_vol 
            contatore                   := bar_index - original_bbars - res_switch_bar
            block_start_bar             := true 
            top_block_fast              := true 

    //
    if ((run == 0 and barstate.islastconfirmedhistory) or bar_reach[1] or (run > 1 and not block_start_bar)) and not top_block_fast and ancoraggio_pivot and ((bar_index - support_switch_bar_old - 1)) < bar_limit and ((bar_index - support_switch_bar_old - original_bbars)) > 0 
        contatore_try                   := bar_index - original_bbars - support_switch_bar_old
        top_mom                         := 0
        bot_mom                         := 9999999 
        for i = 1 to (bbars + contatore_try)
            if high[i] > top_mom
                top_mom                 := high[i]
            if low[i] < bot_mom 
                bot_mom                 := low[i] 
        actual_media_vol                := top_mom - bot_mom
        if actual_media_vol > media_vol 
            contatore                   := bar_index - original_bbars - support_switch_bar_old
            block_start_bar             := true 
            bot_block                   := true
            bot_block_fast              := false 
        //  


    if ((run == 0 and barstate.islastconfirmedhistory or bar_reach[1] or (run > 1 and not block_start_bar))) and not bot_block and ancoraggio_pivot and ((bar_index - res_switch_bar_old - 1)) < bar_limit and ((bar_index - res_switch_bar_old - original_bbars)) > 0 
        contatore_try                   := bar_index - original_bbars - res_switch_bar_old
        block_start_bar                 := true 
        top_block                       := true
        top_mom                         := 0
        bot_mom                         := 9999999 
        for i = 1 to (bbars + contatore_try) 
            if high[i] > top_mom
                top_mom                 := high[i]
            if low[i] < bot_mom 
                bot_mom                 := low[i] 
        actual_media_vol                := top_mom - bot_mom
        if actual_media_vol > media_vol 
            contatore                   := bar_index - original_bbars - res_switch_bar_old
            block_start_bar             := true 
            top_block                   := true
            top_block_fast              := false 
    //
    //

if block_start_bar
    bbars                               := bbars + contatore
    if run == 0 or (bbars < bbars[1]) //Ho dovuto calcolare manualmente top e bot durante lo switch, la funzione ta.pivot continuava a creare problemi utilizzando una lenght mobile
        top                             := 0
        bot                             := 9999999 
        for i = 1 to bbars 
            if high[i] > top
                top                     := high[i]
            if low[i] < bot 
                bot                     := low[i] 
        if (bbars < bbars[1])
            save_bot_liq                := na 
            save_top_liq                := na 
//

bar_reach                               := bbars == bar_limit

if bar_reach //Azzero le bool di ricerca prima dello switch
    bot_block                           := false
    top_block                           := false
    bot_block_fast                      := false
    top_block_fast                      := false
//

//Distanza delle posizioni cover

if run == 0 and not block_start_bar
    bot                                 := bot_max
    top                                 := top_max
if (not block_start_bar)
    bot                                 := bot_max
    top                                 := top_max

// iterazione anticipata per breakout in modo da abbreviare il numero di calcoli
// Dichiarazione delle variabili per i breakout

if run > 0 
    if high > top
        top                                 := high
        if not up_breakout
            up_breakout                     := true 
            bot_in_up_break_out             := bot
            distanza_break_out_up           := top[1] - bot_in_up_break_out
    //
    if low < bot 
        bot                                 := low 
        if not down_breakout
            down_breakout                   := true 
            top_in_down_break_out           := top
            distanza_break_out_down         := top_in_down_break_out - bot[1]
//

// ----------------------------------------}

//Gestione corrispondenze pivot - bot/top
// -----------------------------------------------------------{

bot_is_sup                              := (bot == actual_supporto or bot == actual_old_supporto or bot == actual_supporto_old_1 or bot == actual_supporto_old_2 or bot == actual_supporto_old_3) ? true : false 
top_is_res                              := (top == actual_resistenza or top == actual_old_resistenza) ? true : false 

bot_is_sup_started                      = bot_is_sup and not bot_is_sup[1]
top_is_res_started                      = top_is_res and not top_is_res[1]

bot_is_sup_over                         = not bot_is_sup and bot_is_sup[1]
top_is_res_over                         = not top_is_res and top_is_res[1]

if bot_is_sup and actual_supporto > bot
    actual_support_over_bot_perc        := math.round(((actual_supporto - bot) / (top - bot)) * 100) 
//
if not bot_is_sup
    actual_support_over_bot_perc        := 0
//

global_distance                         = top - bot //Calcolo la distanza globale per preparare un banale sistema di proporzioni e trasformare in percentuale i dati, questo aiuta a triggerare più facilmente i valori che si avvicinano al target predefinito

low_perc                            := math.floor(((low - bot) / global_distance) * 100)
high_perc                           := math.ceil(((high - bot) / global_distance) * 100)

// ----------------------------------------}

// Gestione cover
// -----------------------------------------------------------{

//Assegnazioni di pivot distanti per posizioni cover

//Iterazione scalare per il sistema cover
[tot_sup, old_sup, old_sup_1, old_sup_2, old_sup_3, tot_res, old_res, old_res_1, old_res_2, old_res_3] = M.scalare_sistema_cover(a_sup, fast_play, bot_is_sup, bot, piv_distance, piv_distance_1, piv_distance_2, piv_distance_3, actual_supporto, top, block_start_bar, actual_resistenza, piv_distance_1_res, piv_distance_2_res, piv_distance_3_res)

// ----------------------------------------}

// ----------------------------------------}

// Gestione Breakout
// -----------------------------------------------------------{

// Dichiarazioni Volume indicator + dichiarazioni liq
// -----------------------------------------------------------{

step                                    = global_distance / cnum

// Identifica i pivot high e low brevi per impostare la liquidità attuale 
pivot_high                              = ta.pivothigh(high, lenght_pivot_order_block, lenght_pivot_order_block)
pivot_low                               = ta.pivotlow(low, lenght_pivot_order_block, lenght_pivot_order_block)

// Array per memorizzare i pivot rilevati e i loro timestamp

// Aggiungi un nuovo pivot high quando trovato
if not na(pivot_high) 
    array.push(high_pivots, pivot_high)
    array.push(high_bar_indices, bar_index)
//    
// Aggiungi un nuovo pivot low quando trovato
if not na(pivot_low) 
    array.push(low_pivots, pivot_low)
    array.push(low_bar_indices, bar_index)
//    

// Rimuovi i pivot più vecchi di bbars
int current_bar                         = bar_index

// Rimuovi i pivot high più vecchi di bbars
if array.size(high_bar_indices) > 0
    while array.size(high_bar_indices) > 0 and (current_bar - array.get(high_bar_indices, 0)) == bar_limit +1
        array.shift(high_pivots)
        array.shift(high_bar_indices)
//    
// Rimuovi i pivot low più vecchi di bbars
if array.size(low_bar_indices) > 0
    while array.size(low_bar_indices) > 0  and (current_bar - array.get(low_bar_indices, 0))  == bar_limit +1
        array.shift(low_pivots)
        array.shift(low_bar_indices)
//    
// Trova il pivothigh più basso e il pivotlow più alto, se gli array non sono vuoti
// Per bot_liq: trovare il minimo pivot high all'interno dell'intervallo bbars
if na(save_bot_liq) or (not na(save_bot_liq) and low < save_bot_liq)
    bot_liq                             := na
    if array.size(high_pivots) > 0
        // Trovo i pivot high all'interno dell'intervallo bbars
        float[] valid_high_pivots       = array.new_float(0)
        for i = 0 to array.size(high_pivots) - 1
            if (current_bar - array.get(high_bar_indices, i)) < bbars
                array.push(valid_high_pivots, array.get(high_pivots, i))
        
        // Se ci sono pivot high validi, prendo il minimo
        if array.size(valid_high_pivots) > 0
            bot_liq                     := array.min(valid_high_pivots)
        if bot_liq < save_bot_liq
            save_bot_liq                := na 
    //
// Per top_liq: trovare il massimo pivot low all'interno dell'intervallo bbars
if na(save_top_liq) or (not na(save_top_liq) and high > save_top_liq)
    top_liq                             := na
    if array.size(low_pivots) > 0
        // Trovo i pivot low all'interno dell'intervallo bbars
        float[] valid_low_pivots        = array.new_float(0)
        for i = 0 to array.size(low_pivots) - 1
            if (current_bar - array.get(low_bar_indices, i)) < bbars
                array.push(valid_low_pivots, array.get(low_pivots, i))
        
        // Se ci sono pivot low validi, prendo il massimo
        if array.size(valid_low_pivots) > 0
            top_liq                     := array.max(valid_low_pivots)
        if top_liq > save_top_liq
            save_top_liq                := na 
        //
if not na(save_bot_liq)
    bot_liq                             := save_bot_liq
if not na(save_top_liq)
    top_liq                             := save_top_liq
//

// ----------------------------------------}


// Calcolo Percentuali di Distanza e Break Out
// -----------------------------------------------------------{

// Inizializzazione dei breakout alla prima esecuzione, deve essere aggiustato, in questo momento rileva falsi break quando l'ancoraggio è avvenuto su supporto old o resistenza old 
[old_top, old_bot, current_res, current_sup] = M.breakout(top, actual_old_resistenza, actual_resistenza, bot, actual_old_supporto, actual_supporto)
var int bar_breakout = 0 
var int bar_breakout_down = 0 

if barstate.islastconfirmedhistory 
    if current_res == actual_old_resistenza
        bar_breakout := res_switch_bar_old
    if current_res == actual_resistenza
        bar_breakout := res_switch_bar
    bar_breakout := bar_index - bar_breakout
if barstate.islastconfirmedhistory 
    if current_res == actual_old_supporto
        bar_breakout_down := support_switch_bar_old
    if current_res == actual_supporto
        bar_breakout_down := support_switch_bar
    bar_breakout_down := bar_index - bar_breakout_down
//
if barstate.islastconfirmedhistory 
    if top > current_res
        up_breakout                     := true 
        bot_in_up_break_out             := bot
        distanza_break_out_up           := current_res - bot_in_up_break_out
    //
    if bot < current_sup
        down_breakout                   := true 
        top_in_down_break_out           := top
        distanza_break_out_down         := top_in_down_break_out - current_sup
//

// Funzione per gestire la pulizia delle label
//Pulizia label in eccesso - al momento non veiene plottato questo array, la sua utilità è quella di vedere lo storico del grafico anche dopo che le bbars sono state superate. 

M.clean_labels(saved_labels) //blocco attualmente eliminabile - per rimuoverlo rimuovere tutte le label inserite nell'array

if run > 0
    breakout_bar_index_up               = ta.valuewhen(high == top, bar_index, 0)

    if up_breakout and low < poc_level
        distanza_break_out_up_post      := top - bot_in_up_break_out
        break_out_up_perc               := ((distanza_break_out_up_post - distanza_break_out_up) / distanza_break_out_up) * 100
        up_breakout                     := false 

        // Crea la label e salvala nell'array
        label break_out_up_perc_label   = label.new(
             breakout_bar_index_up, 
             top, 
             "Break_out: " + str.tostring(break_out_up_perc, "#.##") + "%", 
             color          =positiveColor, 
             style          =label.style_label_down, 
             textcolor      =color.white, 
             size           =size.small, 
             force_overlay  = true
             )
        array.push(saved_labels, break_out_up_perc_label)
    //
    
        
    label.delete(vol_break_up_perc_mom_label)

    if up_breakout
        distanza_break_out_post_mom_up  := top - bot_in_up_break_out
        break_out_up_perc_mom           := ((distanza_break_out_post_mom_up - distanza_break_out_up) / distanza_break_out_up) * 100
        break_out_up_top_perc           := math.max(break_out_up_perc_mom, break_out_up_perc_mom[1])
        vol_break_up_perc_mom_label     := label.new(bar_index + 43 , top, 
                              text      = "Break: " + str.tostring(math.round_to_mintick(break_out_up_perc_mom)) + "%",
                              style     = label.style_label_down,
                              color     = na ,
                              textcolor = positiveColor, force_overlay = true)
    if not up_breakout and not na (break_out_up_top_perc)
        break_out_up_top_perc           := na 
//

// Una collezione per mantenere le label di breakout
if run > 0 
    breakout_bar_index_down             := ta.valuewhen(low == bot, bar_index, 0)

    if down_breakout and high > poc_level
        distanza_break_out_down_post    := top_in_down_break_out - bot
        break_out_down_perc             := ((distanza_break_out_down_post - distanza_break_out_down) / distanza_break_out_down) * 100
        down_breakout                   := false 

        // Crea la label e salvala nell'array
        label break_out_down_perc_label = label.new(
             breakout_bar_index_down, 
             bot, 
             "Break_out: " + str.tostring(break_out_down_perc, "#.##") + "%", 
             color          =color.blue, 
             style          =label.style_label_up, 
             textcolor      =color.white, 
             size           =size.small, 
             force_overlay  = true
             )
        array.push(saved_labels, break_out_down_perc_label)
    //

    
        
    label.delete(vol_break_down_perc_mom_label)

    if down_breakout
        distanza_break_out_post_mom_down := top_in_down_break_out - bot
        break_out_down_perc_mom         := ((distanza_break_out_post_mom_down - distanza_break_out_down) / distanza_break_out_down) * 100
        break_out_down_top_perc         := math.max(break_out_down_perc_mom, break_out_down_perc_mom[1])
        vol_break_down_perc_mom_label   := label.new(bar_index + 43, bot, 
                              text          = "Break: " + str.tostring(math.round_to_mintick(break_out_down_perc_mom)) + "%",
                              style         = label.style_label_up,
                              color         = na ,
                              textcolor     = color.red, force_overlay = true)
    if not down_breakout and not na (break_out_down_top_perc)
        break_out_down_top_perc         := na 
    //

// -------------------------------------}

// -------------------------------------}

//Analisi e figure
// ------------------------------------------------------------{

// Setting Finonacci + organizzazione livelli in base a status vix e timeframe corrente
// -----------------------------------------------------------{

//Tutto lo scenario bot top viene suddiciso in una sequenza di fibonacci per gestire livelli minimi di acquisto ed eventuali incrementi o diminuzioni della % di volume pesata. questo per mantenere stabilità nel codice ed evitare iper compressioni o iper estensioni
//Gestione dello scenario box 

// Determina in quale zona di Fibonacci si trova VAL
fib_val_value                           := val_perc <= fib_perc_1 ? 1 : 
                                          val_perc <= fib_perc_2 ? 2 : 
                                          val_perc <= fib_perc_3 ? 3 : 
                                          val_perc <= fib_perc_4 ? 4 : 
                                          val_perc <= fib_perc_5 ? 5 : 
                                          val_perc <= fib_perc_6 ? 6 : 6

// Determina in quale zona di Fibonacci si trova VAH
fib_vah_value                           := vah_perc <= fib_perc_1 ? 1 : 
                                          vah_perc <= fib_perc_2 ? 2 : 
                                          vah_perc <= fib_perc_3 ? 3 : 
                                          vah_perc <= fib_perc_4 ? 4 : 
                                          vah_perc <= fib_perc_5 ? 5 : 
                                          vah_perc <= fib_perc_6 ? 6 : 6
//

if timeframe_level <= 1
    if sentiment_level[1] == 0
        fib_for_scenario                := fib_perc_3
    else 
        fib_for_scenario                := fib_perc_4
    //
    if sentiment_level[1] > 2 and tot_res[1] > 0
        fib_for_break                   := fib_perc_5
    else
        fib_for_break                   := fib_perc_4
//
else if timeframe_level > 1

    fib_for_scenario                    := fib_perc_5
    fib_for_break                       := fib_perc_5
//

fib_perc_5_value                        = bot + (global_distance * fib_for_scenario / 100)
bot_liq_distance                        = top - bot_liq 
new_fib_perc_5                          = math.round(((fib_perc_5_value - bot_liq) / bot_liq_distance) * 100)

// -------------------------------------}

// -------------------------------------}

// Buy Logic Mid & Break
// -----------------------------------------------------------{

// Var posizioni 
// -----------------------------------------------------------{


if close_alarm_mid 
    close_alarm_mid := false 
    scenario_val_to_higher_line         := 0 
    scenario_val_to_higher_ask          := 0 
    scenario_vah_to_bot_target_line     := 0
    scenario_vah_to_bot_target_ask      := 0
    scenario_val_to_bot_target_line     := 0
    scenario_val_to_bot_target_ask      := 0
    scenario_poc_to_bot_target_line     := 0
    scenario_poc_to_bot_target_ask      := 0
    scenario_poc_2_to_bot_target_line   := 0
    scenario_poc_2_to_bot_target_ask    := 0
//

// -------------------------------------}

// Lista trig
// -----------------------------------------------------------{

if tot_position_cover == 0 and last_cover > 0
    last_cover := 0
//

if not scenario_bot_line and not scenario_bot_2_line and not na(first_bot_liq)
    first_bot_liq := na 
//

stable_box = bot[1] == bot and top[1] == top 

var float     lower_target_perc                   = na 
var float     higher_target_perc                  = na 
var float     lower_target_perc_bot               = na 
var float     higher_target_perc_bot              = na 
var float     lower_target_act_sup_over_bot_perc  = na 
var float     higher_target_act_sup_over_bot_perc = na 
var float     mid_lower_target_perc               = na 
var float     mid_higher_target_perc              = na 

var bool close_mid_fast      = false 
var bool close_break_fast    = false 
var float break_ask_perc = na 
var string cover_in_candle = na 
var int mid_ask_perc = na 
// Variabili aggiuntive
if barstate.islast and run > 0
    mid_ask_perc := not na(mid_ask) ? math.round((mid_ask - bot) / ((top - bot) * 100)) : na 

    var int n_posizione = na
    //Trig di apertura
    val_trig_base_act = (
             (high[1] >= val_level          and low <= val_level)         or
             (high_perc >= val_perc      and low_perc <= val_perc)     or
             (low[1] >= val_level           and low <= val_level)         or 
             (low_perc >= val_perc       and low_perc <= val_perc))    and stable_box and val_is_in_buy
             //

    val_trig_break_act = val_trig_base_act and low_perc < lower_lr_perc

    vah_trig_base_act = (
             (high[1] >= vah_level          and low <= vah_level)         or
             (high_perc >= vah_perc      and low_perc <= vah_perc)     or
             (low[1] >= vah_level           and low <= vah_level)         or 
             (low_perc >= vah_perc       and low_perc <= vah_perc))    and stable_box and vah_is_in_buy
             //

    poc_trig_base_act = (
             (high[1] >= poc_level          and low <= poc_level)           or
             (high_perc >= poc_perc      and low_perc <= poc_perc)       or
             (low[1] >= poc_level           and low <= poc_level)           or 
             (low_perc >= poc_perc       and low_perc <= poc_perc))      and stable_box and poc_is_in_buy
             //

    poc_2_trig_base_act = (
             (high[1] >= poc_second_level    and low <= poc_second_level)       or
             (high_perc >= poc_2_perc     and low_perc <= poc_2_perc)        or
             (low[1] >= poc_second_level     and low <= poc_second_level)       or 
             (low_perc >= poc_2_perc      and low_perc <= poc_2_perc))       and stable_box and poc_2_is_in_buy
             //

    poc_2_trig_break_act = poc_2_trig_base_act and low_perc < lower_lr_perc 

    bot_liq_trig = (
             (high[1] >= bot_liq                and low <= bot_liq)                 or
             (high_perc >= bot_liq_perc      and low_perc <= bot_liq_perc)       or
             (low[1] >= bot_liq                 and low <= bot_liq)                 or 
             (low_perc >= bot_liq_perc       and low_perc <= bot_liq_perc))       
             and stable_box and bot_liq_is_in_buy

    old_sup_trig = 
             (low[1] > old_sup[1] and low <= old_sup[1]) or
             (low[1] > old_sup and low <= old_sup)

    //Trig di chiusura 
    higher_target_bot_trig =
             high >= higher_target_bot              or 
             high_perc >= higher_target_perc_bot    

    siffredi_higher_target_trig = 
             high >= siffredi_higher_target                  or 
             high_perc >= higher_target_perc     
                
    siffredi_lower_target_trig = 
             high >= siffredi_lower_target                  or 
             high_perc >= lower_target_perc        

    lower_target_bot_trig = 
             high >= lower_target_bot              or 
             high_perc >= lower_target_perc_bot    or 
             high > upperEndPrice_lr               

    mid_lower_target_bot_trig = 
             (high >= mid_lower_target              or 
             high_perc >= mid_lower_target_perc     or 
             high > upperEndPrice_lr)                and open_position_mid > 0 and save_start_perc == save_start_perc[1]

    mid_higher_target_bot_trig = 
             (high >= mid_higher_target              or 
             high_perc >= mid_higher_target_perc
             ) and open_position_mid > 0
 
    chiusura_scenario_under_lower_lr = (((open_position_break > 0 or pearson < 0.75 or mid_ask_perc > 50) and stable_box) ? mid_lower_target_bot_trig : mid_higher_target_bot_trig)

    actual_support_over_bot_target_trig_lower = 
             high >= lower_target_act_sup_over_bot              or 
             high_perc >= lower_target_act_sup_over_bot_perc    or 
             high > upperEndPrice_lr               
    //

    actual_support_trig = actual_support_over_bot_target_trig_lower 
    //
    any_trig_close = 
         (low[1] < val_level            and high > val_level          )     or
         (low[1] < val_level[1]         and high > val_level[1]       )     or
         (low[1] < vah_level            and high > vah_level          )     or
         (low[1] < vah_level[1]         and high > vah_level[1]       )     or
         (low[1] < poc_level            and high > poc_level          )     or
         (low[1] < poc_level[1]         and high > poc_level[1]       )     or
         (low[1] < poc_second_level     and high > poc_second_level   )     or
         (low[1] < poc_second_level[1]  and high > poc_second_level[1])     or
         (low[1] < top_liq              and high > top_liq      )           or
         (low[1] < top_liq[1]           and high > top_liq[1]   )  

    low_trig  = any_trig_close and high_perc > mid_level
    high_trig = any_trig_close and high_perc > (mid_level * 2) 
    //

// -------------------------------------}

// Posizioni in area intermedia di retrend up il seguente blocco possiede tutto lo stesso ID 12 preservando lo stesso ID posso conservare rapidamente un'iterazione di chiusura
// -----------------------------------------------------------{

// Buy Break out ID 13 - 23
// -----------------------------------------------------------{

    bool scenario_break_out = false 
    if open_position_break > 0 and tot_position_scenario_bot > 1
        break_fail := true 
    //
    scenario_break_out := market_buy_pattern    == "Poc 2 Break"    ? poc_2_trig_base_act  :
                         market_buy_pattern     == "Poc Break"      ? poc_trig_base_act    :
                         market_buy_pattern     == "Vah Break"      ? vah_trig_base_act    :
                         false        
                        
    bool scenario_siffredi = false 

    if (market_buy_pattern == "Siffredi") or ((market_buy_pattern == "Siffredi look for break"))
        scenario_siffredi := market_buy_pattern == "Siffredi" ? ((vah_trig_base_act) or (poc_2_trig_base_act) or poc_trig_base_act or (val_trig_base_act)) and not siffredi_fatta and na(siffredi_ask) : (poc_trig_base_act or (val_trig_base_act)) and not siffredi_fatta and na(siffredi_ask)

    if scenario_break_out and open_position_mid == 0 and tot_position_scenario_bot == 0 and scenario_break_out_line == 0
        n_posizione := 13
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
         \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
         str.tostring(timenow), "{", titolo, "BUY", n_titoli_moltiplicatore_break, "}", "}", "}"), alert.freq_once_per_bar)
        //
        scenario_break_out_line := 1
        scenario_break_out_ask := vah_trig_base_act   ? (vah_level + spread)            :
                                 poc_2_trig_base_act  ? (poc_second_level + spread)     :
                                 poc_trig_base_act    ? (poc_level + spread)            :
                                 (poc_level + spread)        
        //
        break_ask := scenario_break_out_ask
        target_res := low_perc < fib_perc_4 ? top : not na(old_res) ? old_res : upperEndPrice_lr 
        if target_res == upperEndPrice_lr
            target_upper_lr := true 
        break_start_perc := (scenario_break_out_ask - bot) / ((top - bot) * 100)
        label scenario_break = label.new(bar_index, low - (high - low), "scenario break", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, scenario_break)

    if not na(target_res) and high > top 
        stop_profit := true 

    if scenario_break_out_line == 1 and scenario_break_out_line[1] == 1 and not na(target_res) and ((high > target_res and not target_upper_lr) or (high > upperEndPrice_lr and target_upper_lr) or (stop_profit and low < top_liq)) and high > scenario_break_out_ask
        n_posizione := 13
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
         \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
        //
        stop_profit := false
        break_ask := na 
        target_upper_lr := false 
        break_fail := false 
        break_start_perc := na 
        label close_res = label.new(bar_index, high, "close scenario break", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, close_res)
        //
        target_res := na 
        scenario_break_out_ask := 0
        scenario_break_out_line  := 0
    // 
    if scenario_siffredi and open_position_mid == 0 and (tot_position_scenario_bot == 0 or (tot_position_scenario_bot == 1 and tot_position == 1)) and scenario_break_out_line == 0 and not siffredi_fatta 
        n_posizione := 23
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
         \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
         str.tostring(timenow), "{", titolo, "BUY", n_titoli_moltiplicatore_break, "}", "}", "}"), alert.freq_once_per_bar)
        //
        scenario_break_out_line := 1
        scenario_break_out_ask := vah_trig_base_act   ? (vah_level + spread)            :
                                 poc_2_trig_base_act  ? (poc_second_level + spread)     :
                                 poc_trig_base_act    ? (poc_level + spread)            :
                                 (poc_level + spread)        
        //
        break_ask := scenario_break_out_ask
        siffredi_ask := break_ask
        break_start_perc :=  not na(scenario_break_out_ask) ? (scenario_break_out_ask - bot) / ((top - bot) * 100) : na

        label scenario_break = label.new(bar_index, low - (high - low), "scenario siffredi", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, scenario_break)

    if scenario_break_out_line == 1 and scenario_break_out_line[1] == 1 and (siffredi_higher_target_trig) and high > scenario_break_out_ask and not na(siffredi_ask)
        n_posizione := 23
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
         \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
        //
        break_ask := na 
        siffredi_ask := na 
        break_fail := false 
        break_start_perc := na 
        label close_res = label.new(bar_index, high, "close scenario siffredi", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, close_res)
        //
        scenario_break_out_ask := 0
        scenario_break_out_line  := 0
    //
    if market_buy_pattern == "Siffredi" and scenario_break_out_line == 1 
        siffredi_fatta := true 
    if market_buy_pattern != "Siffredi" and siffredi_fatta
        siffredi_fatta := false 

// -------------------------------------}

//Conteggio posizioni 
// -----------------------------------------------------------{

    open_position_break := scenario_actual_over_bot_line + scenario_break_out_line

// -------------------------------------}

// Buy Pendant
// -----------------------------------------------------------{

    bool scenario_val_to_higher = false 
    if (market_buy_pattern == "Top Compression")
        scenario_val_to_higher := val_trig_base_act 

    if market_buy_pattern == "Poc"
        scenario_val_to_higher := poc_trig_base_act

    if market_buy_pattern == "Val"
        scenario_val_to_higher := val_trig_base_act
        
    if scenario_val_to_higher and scenario_val_to_higher_line == 0 and open_position_mid == 0 and tot_position_scenario_bot == 0 and open_position_break == open_position_break[1]
        n_posizione := 12
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
         \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
         str.tostring(timenow), "{", titolo, "BUY", n_titoli_moltiplicatore_mid, "}", "}", "}"), alert.freq_once_per_bar)
        //
        scenario_val_to_higher_line := 1
        scenario_val_to_higher_ask  := bot_liq_trig ? bot_liq + spread  : val_trig_base_act ? val_level + spread :  poc_level + spread
        mid_ask := scenario_val_to_higher_ask
        open_position_mid := 1
        //
        label scenario_val_to_vah_box_label = label.new(bar_index, low, "scenario val", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, scenario_val_to_vah_box_label)
        if market_buy_pattern == "Top Compression"
            if tot_res > 0 
                take_val_to_top := old_res_1
            else
                top_data_compression := top
        if val_trig_base_act 
            pendant_trig := "Val"
        if poc_trig_base_act 
            pendant_trig := "Poc"
        //
    //Metto na per chiudere prima la posizione al breakout
    if not na(take_val_to_top) and vah_level < vah_level[1]
        take_val_to_top := na 
    //
    if scenario_val_to_higher_line == 1 and scenario_val_to_higher_line[1] == 1 and 
         (((high > upperEndPrice_lr or (high > top_data_compression and ema_switch_down)) and not na(top_data_compression)) or 
         (not na(take_val_to_top) and high > take_val_to_top) or 
         (na(take_val_to_top) and na(top_data_compression) and mid_higher_target_bot_trig and pendant_trig == "Val")    or 
         (na(take_val_to_top) and na(top_data_compression) and mid_higher_target_bot_trig and pendant_trig == "Poc"))
         and high > scenario_val_to_higher_ask
        n_posizione := 12
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
         \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
        //
        mid_ask := na
        pendant_trig := na 
        //
        label close_val_to_vah_box_label = label.new(bar_index, high, "close scenario val", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, close_val_to_vah_box_label)
        //
        scenario_val_to_higher_line := 0
        scenario_val_to_higher_ask  := 0
        take_val_to_top := na 
    //

// -------------------------------------}

// Buy 2 Poc position 
// -----------------------------------------------------------{

    bool scenario_poc_2_to_bot_target = false 
    if market_buy_pattern       == "Poc 2 Buy Fig"
        scenario_poc_2_to_bot_target := poc_2_trig_base_act 

    if scenario_poc_2_to_bot_target and open_position_mid == 0 and tot_position_scenario_bot == 0 and open_position_break == open_position_break[1]//togliere la posizione quando le cover di sotto sono aperte
        n_posizione := 12
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
         \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
         str.tostring(timenow), "{", titolo, "BUY", n_titoli_moltiplicatore_mid, "}", "}", "}"), alert.freq_once_per_bar)
        //
        scenario_poc_2_to_bot_target_line := 1
        scenario_poc_2_to_bot_target_ask  := poc_second_level + spread 
        mid_ask := scenario_poc_2_to_bot_target_ask
        open_position_mid := 1
        //
        label scenario_poc_2_to_bot_target_label = label.new(bar_index, low, "scenario_poc 2 to bot target", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, scenario_poc_2_to_bot_target_label)
        //
    if scenario_poc_2_to_bot_target_line == 1 and scenario_poc_2_to_bot_target_line[1] == 1 and 
         (chiusura_scenario_under_lower_lr) and high > scenario_poc_2_to_bot_target_ask
        n_posizione := 12
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
         \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
        //
        mid_ask := na
        //
        label close_poc_2_to_bot_higher_label = label.new(bar_index, high, "close scenario poc 2 to bot target", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, close_poc_2_to_bot_higher_label)
        //
        scenario_poc_2_to_bot_target_line := 0
        scenario_poc_2_to_bot_target_ask  := 0
    //

// -------------------------------------}

// Buy Poc position 
// -----------------------------------------------------------{
    bool scenario_poc_to_bot_target = false 

    if market_buy_pattern       == "Poc Buy Fig" or (market_buy_pattern == "Poc Break" and scenario_break_out_line == 1 and poc_perc < (break_ask_perc - 33) )
        scenario_poc_to_bot_target := poc_trig_base_act 

    if scenario_poc_to_bot_target and open_position_mid == 0 and tot_position_scenario_bot == 0 and open_position_break == open_position_break[1] //togliere la posizione quando le cover di sotto sono aperte
        n_posizione := 12
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
         \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
         str.tostring(timenow), "{", titolo, "BUY", n_titoli_moltiplicatore_mid, "}", "}", "}"), alert.freq_once_per_bar)
        //
        scenario_poc_to_bot_target_line := 1
        scenario_poc_to_bot_target_ask  := poc_level + spread 
        mid_ask := scenario_poc_to_bot_target_ask
        open_position_mid := 1
        //
        label scenario_poc_to_bot_target_label = label.new(bar_index, low, "scenario_poc to bot target", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, scenario_poc_to_bot_target_label)
        //
    if scenario_poc_to_bot_target_line == 1 and scenario_poc_to_bot_target_line[1] == 1 and (chiusura_scenario_under_lower_lr) and high > scenario_poc_to_bot_target_ask
        n_posizione := 12
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
         \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
        //
        mid_ask := na
        //
        label close_poc_to_bot_higher_label = label.new(bar_index, high, "close scenario poc to bot target", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, close_poc_to_bot_higher_label)
        //
        scenario_poc_to_bot_target_line := 0
        scenario_poc_to_bot_target_ask  := 0
    //

// -------------------------------------}

// Buy Val position 
// -----------------------------------------------------------{

    bool scenario_val_to_bot_target = false 

    if market_buy_pattern       == "Val Buy Fig"
        scenario_val_to_bot_target := val_trig_base_act

    if scenario_val_to_bot_target and open_position_mid == 0 and tot_position_scenario_bot == 0 and open_position_break == open_position_break[1]//togliere la posizione quando le cover di sotto sono aperte
        n_posizione := 12
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
         \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
         str.tostring(timenow), "{", titolo, "BUY", n_titoli_moltiplicatore_mid, "}", "}", "}"), alert.freq_once_per_bar)
        //
        scenario_val_to_bot_target_line := 1
        scenario_val_to_bot_target_ask  := val_level + spread 
        mid_ask := scenario_val_to_bot_target_ask
        //
        open_position_mid := 1
        label scenario_val_to_bot_target_label = label.new(bar_index, low, "scenario_val to bot target", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, scenario_val_to_bot_target_label)
       //
    if scenario_val_to_bot_target_line == 1 and scenario_val_to_bot_target_line[1] == 1 and (chiusura_scenario_under_lower_lr) and high > scenario_val_to_bot_target_ask
        n_posizione := 12
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
         \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
        //
        mid_ask := na
        //
        label close_val_to_bot_higher_label = label.new(bar_index, high, "close scenario val to bot target", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, close_val_to_bot_higher_label)
        //
        scenario_val_to_bot_target_line := 0
        scenario_val_to_bot_target_ask  := 0
    //

// -------------------------------------}

// Buy Vah position
// -----------------------------------------------------------{

    bool scenario_vah_to_bot_target = false 

    if market_buy_pattern       == "Vah Buy Fig"
        scenario_vah_to_bot_target := vah_trig_base_act

    if scenario_vah_to_bot_target and open_position_mid == 0 and tot_position_scenario_bot == 0 and open_position_break == open_position_break[1]//togliere la posizione quando le cover di sotto sono aperte
        n_posizione := 12
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
         \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
         str.tostring(timenow), "{", titolo, "BUY", n_titoli_moltiplicatore_mid, "}", "}", "}"), alert.freq_once_per_bar)
        //
        scenario_vah_to_bot_target_line := 1
        scenario_vah_to_bot_target_ask  := vah_level + spread 
        mid_ask := scenario_vah_to_bot_target_ask
        open_position_mid := 1
        //
        label scenario_vah_to_bot_target_label = label.new(bar_index, low, "scenario_vah to bot target", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, scenario_vah_to_bot_target_label)
        //
    if scenario_vah_to_bot_target_line == 1 and scenario_vah_to_bot_target_line[1] == 1 and (chiusura_scenario_under_lower_lr) and high > scenario_vah_to_bot_target_ask
        n_posizione := 12
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
         \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
        //
        mid_ask := na
        //
        label close_vah_to_bot_higher_label = label.new(bar_index, high, "close scenario vah to bot target", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, close_vah_to_bot_higher_label)
        //
        scenario_vah_to_bot_target_line := 0
        scenario_vah_to_bot_target_ask  := 0
   //

// -------------------------------------}

// -------------------------------------}

//Conteggio posizioni e gestione secondaria dei livelli di target 
// -----------------------------------------------------------{

    open_position_mid := scenario_val_to_higher_line + scenario_poc_to_bot_target_line + scenario_val_to_bot_target_line + scenario_vah_to_bot_target_line + scenario_poc_2_to_bot_target_line
    //
    mid_just_open = open_position_mid > open_position_mid[1] 
    mid_ask_perc := not na(mid_ask) ? math.round((mid_ask - bot) / ((top - bot) * 100)) : na 

// -------------------------------------}

// -------------------------------------}

// Buy Logic Bot
// -----------------------------------------------------------{

// Posizione Bot liq/ primo pivot
// -----------------------------------------------------------{

    scenario_actual_over_bot = actual_support_over_bot_perc < 50 and actual_supporto > bot and bot_is_sup and low[1] > actual_supporto and low < actual_supporto and act_sup_is_in_buy and actual_supporto < mid_ask and tot_position_scenario_bot == 0 and not cover_1_line

    if scenario_actual_over_bot and open_position_break == 0 and not mid_just_open and tot_position_scenario_bot == 0 
        n_posizione := 11
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
         \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
         str.tostring(timenow), "{", titolo, "BUY", n_titoli_moltiplicatore_mid, "}", "}", "}"), alert.freq_once_per_bar)
        //
        scenario_actual_over_bot_line := 1
        scenario_actual_over_bot_ask  := actual_supporto + spread * 2
        //
        label scenario_actual_over_bot_label = label.new(bar_index, low - (high - low), "scenario actual over bot", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, scenario_actual_over_bot_label)

    if scenario_actual_over_bot_line == 1 and scenario_actual_over_bot_line[1] == 1 and ((high > upperEndPrice_lr[1] or actual_support_trig) or (ema_switch_down and cover_1_line)) and high > scenario_actual_over_bot_ask
        n_posizione := 11
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
         \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
        if high > mid_ask 
            close_mid_fast := true
            //
        if break_fail and high > break_ask
            close_break_fast := true            
        //
        //
        label close_actual_over_bot = label.new(bar_index, high, "close actual over bot", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, close_actual_over_bot)
        //
        scenario_actual_over_bot_line := 0
        scenario_actual_over_bot_ask  := 0
    //

    //Posizione supporto (old o attuale)
    scenario_bot   = bot_liq_trig and bot_is_sup and not scenario_bot_line and not scenario_bot_2_line and not cover_1_line[1]
    scenario_bot_down = low < bot[1]
    scenario_bot_down_start = scenario_bot_down and ((bot_is_sup[1] and not scenario_bot_line and not scenario_bot_2_line ))

    scenario_bot_2 = old_sup_trig and not bot_is_sup and not scenario_bot_line and not scenario_bot_2_line and not cover_1_line[1]
    //Salvo due blocchi diversi di livelli cover a parte in modo da non raddoppiare la successiva iterazione del codice.
    if (scenario_bot or scenario_bot_down_start) and not scenario_bot_line
        scenario_bot_line   := true 
        first_bot_liq := bot_liq
        first_bot := bot
        if not na(old_sup)
            supporto_1 := old_sup
        if not na(old_sup_1)
            supporto_2 := old_sup_1
        if not na(old_sup_2)
            supporto_3 := old_sup_2
        if not na(old_sup_3)
            supporto_4 := old_sup_3
        //
    if scenario_bot_2 and not scenario_bot_2_line
        scenario_bot_2_line := true 
        first_bot_liq := bot_liq
        first_bot := bot
        if not na(old_sup_1)
            supporto_1 := old_sup_1
        if not na(old_sup_2)
            supporto_2 := old_sup_2
        if not na(old_sup_3)
            supporto_3 := old_sup_3
        //

    if tot_position_scenario_bot > 0 and incremento_distanza_pivot[1] > incremento_distanza_pivot[2]
        //
        supporto_1                       := na
        supporto_2                       := na
        supporto_3                       := na
        supporto_4                       := na
        array.sort(a_sup, order.descending)  // Ordine decrescente per supporti
        // Trova il primo supporto <= actual_supporto
        for i = 0 to array.size(a_sup) - 1
            if array.get(a_sup, i) < (first_bot - piv_distance[1]) and array.get(a_sup, i) < supporto_1[1] and not na(supporto_1[1])
                supporto_1             := array.get(a_sup, i)
            else 
                supporto_1 := supporto_1[1]
         //
        if not na(supporto_1)
            for i = 0 to array.size(a_sup) - 1
                if array.get(a_sup, i) < (supporto_1 - piv_distance_1[1]) and array.get(a_sup, i) < supporto_2[1] and not na(supporto_2[1])
                    supporto_2           := array.get(a_sup, i)
                else 
                    supporto_2         := na 
        if not na(supporto_2) 
            for i = 0 to array.size(a_sup) - 1
                if array.get(a_sup, i) < (supporto_2 - piv_distance_2[1]) and array.get(a_sup, i) < supporto_3[1] and not na(supporto_3[1])
                    supporto_3           := array.get(a_sup, i)
                else 
                    supporto_3         := na 
        if not na(supporto_3)
            for i = 0 to array.size(a_sup) - 1
                if array.get(a_sup, i) < (supporto_3 - piv_distance_3[1]) and array.get(a_sup, i) < supporto_4[1] and not na(supporto_4[1])
                    supporto_4           := array.get(a_sup, i)
                else 
                    supporto_4         := na 
    //

    //Iterazioni quando bot_is_sup  
    if scenario_bot_line
        
        if (scenario_bot or scenario_bot_down_start) and scenario_bot_line_to_l == 0 and scenario_actual_over_bot_line == 0 and not mid_just_open and ((bot_liq_perc < mid_ask_perc - 13) or na(mid_ask_perc))
            n_posizione := 1 
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
             \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
             str.tostring(timenow), "{", titolo, "BUY", n_titoli_moltiplicatore_bot, "}", "}", "}"), alert.freq_once_per_bar)
            //
            scenario_bot_line_to_l := 1
            scenario_bot_ask_to_l  := scenario_bot ? (bot_liq[1] + spread) : (bot[1] + spread)
            //
            label scenario_bot_label = label.new(bar_index, low, "scenario_bot l", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_bot_label)

        //
        if (scenario_bot or scenario_bot_down_start) and scenario_bot_line_to_h == 0 and (open_position_break + open_position_mid) < 4 and na(siffredi_ask) //togliere la posizione quando le cover di sotto sono aperte
            n_posizione := 2
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
             \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
             str.tostring(timenow), "{", titolo, "BUY", n_titoli_moltiplicatore_bot, "}", "}", "}"), alert.freq_once_per_bar)
            //
            scenario_bot_line_to_h := 1 
            scenario_bot_ask_to_h  := bot_liq[1] + spread 
            //
            label scenario_bot_2_label = label.new(bar_index, low, "scenario_bot h", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_bot_2_label)

        //Attualmente molte chiusure si chiudono in un banale overbuy, sarà opportuno adattare lo studio del pearson anche a questo gruppo di chiusure 

        if scenario_bot_line_to_l == 1 and scenario_bot_line_to_l[1] == 1 and ((lower_target_bot_trig) or (ema_switch_down and cover_1_line)) and high > scenario_bot_ask_to_l
            n_posizione := 1
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
             \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
            if high > mid_ask 
                close_mid_fast := true
                //
            if break_fail and high > break_ask
                close_break_fast := true            
            //
            //
            label scenario_bot_close_label_l = label.new(bar_index, high, "close scenario_bot l", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_bot_close_label_l)
            //
            scenario_bot_line_to_l := 0
            scenario_bot_ask_to_l  := 0
        //

        if scenario_bot_line_to_h == 1 and scenario_bot_line_to_h[1] == 1 and ((higher_target_bot_trig) or (ema_switch_down and cover_2_line)) and high > scenario_bot_ask_to_h
            n_posizione := 2
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
             \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
            if high > mid_ask 
                close_mid_fast := true
                //
            if break_fail and high > break_ask
                close_break_fast := true            
            //
            label scenario_bot_close_label_h = label.new(bar_index, high, "close scenario_bot h", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_bot_close_label_h)
            //
            scenario_bot_line_to_h := 0
            scenario_bot_ask_to_h  := 0
        //
    //Iterazioni quando not bot_is_sup 
    if scenario_bot_2_line 
        
        if (scenario_bot_2) and scenario_bot_line_to_l == 0 and scenario_actual_over_bot_line == 0 and not mid_just_open and ((bot_liq_perc < mid_ask_perc - 13) or na(mid_ask_perc)) 
            n_posizione := 1
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
             \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
             str.tostring(timenow), "{", titolo, "BUY", n_titoli_moltiplicatore_bot, "}", "}", "}"), alert.freq_once_per_bar)
            //
            scenario_bot_line_to_l := 1
            scenario_bot_ask_to_l  := old_sup + spread 
            //
            label scenario_bot_label = label.new(bar_index, low, "scenario_bot l", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_bot_label)

        //
        if scenario_bot_2 and scenario_bot_line_to_h == 0 and (open_position_break + open_position_mid) < 4 and na(siffredi_ask)//togliere la posizione quando le cover di sotto sono aperte
            n_posizione := 2
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
             \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
             str.tostring(timenow), "{", titolo, "BUY", n_titoli_moltiplicatore_bot, "}", "}", "}"), alert.freq_once_per_bar)
            //
            scenario_bot_line_to_h := 1 
            scenario_bot_ask_to_h  := old_sup + spread 
            //
            label scenario_bot_2_label = label.new(bar_index, low, "scenario_bot h", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_bot_2_label)

        //Attualmente molte chiusure si chiudono in un banale overbuy, sarà opportuno adattare lo studio del pearson anche a questo gruppo di chiusure 

        if scenario_bot_line_to_l == 1  and scenario_bot_line_to_l[1] == 1 and ((lower_target_bot_trig or cover_1_line)) and high > scenario_bot_ask_to_l
            n_posizione := 1
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
             \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
            //
            label scenario_bot_close_label_l = label.new(bar_index, high, "close scenario_bot l", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_bot_close_label_l)
            if high > mid_ask 
                close_mid_fast := true
                //
            if break_fail and high > break_ask
                close_break_fast := true            
            //
            scenario_bot_line_to_l := 0
            scenario_bot_ask_to_l  := 0
        //
        if scenario_bot_line_to_h == 1 and scenario_bot_line_to_h[1] == 1 and ((higher_target_bot_trig) or (ema_switch_down and cover_2_line)) and high > scenario_bot_ask_to_h
            n_posizione := 2
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
             \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
            if high > mid_ask 
                close_mid_fast := true
                //
            if break_fail and high > break_ask
                close_break_fast := true            
            //
            label scenario_bot_close_label_h = label.new(bar_index, high, "close scenario_bot h", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_bot_close_label_h)
            //
            scenario_bot_line_to_h := 0
            scenario_bot_ask_to_h  := 0
        //

    if close_mid_fast
        n_posizione := 12
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
         \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
        close_alarm_mid := true
        label close_alarm_mid_label = label.new(bar_index, high + high - low, "close alarm mid", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, close_alarm_mid_label)
        close_mid_fast := false 
    //
    if close_break_fast
        n_posizione := 13
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
         \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
        //
        break_ask := na 
        target_upper_lr := false 
        break_fail := false 
        break_start_perc := na 
        label close_res = label.new(bar_index, high, "close scenario break", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, close_res)
        //
        target_res := na 
        scenario_break_out_ask := 0
        scenario_break_out_line  := 0
        close_break_fast := false


// -------------------------------------}

//Pulisco i livelli di bot e i supporti quando le posizioni sono tutte chiuse - definisco le variabili di cover
// -------------------------------------{

    tot_position_scenario_bot := scenario_bot_line_to_l + scenario_bot_line_to_h 
    //Chiusura della line di scenario bot quando non ci sono operazioni aperte
    if tot_position_scenario_bot == 0 and scenario_bot_line 
        scenario_bot_line := false 
        supporto_1 := na 
        supporto_2 := na 
        supporto_3 := na 
        supporto_4 := na 
    //
    if tot_position_scenario_bot == 0 and scenario_bot_2_line
        scenario_bot_2_line := false 
        supporto_1 := na 
        supporto_2 := na 
        supporto_3 := na 
        supporto_4 := na 
    //            

    if scenario_bot_line or scenario_bot_2_line
        supporto_cover_trig_1 := not na(supporto_1[1]) and low[1] > supporto_1[1] and low <= supporto_1[1] and not cover_2_line
        supporto_cover_trig_2 := not na(supporto_2[1]) and low[1] > supporto_2[1] and low <= supporto_2[1] and not cover_3_line
        supporto_cover_trig_3 := not na(supporto_3[1]) and low[1] > supporto_3[1] and low <= supporto_3[1] and not cover_4_line
        supporto_cover_trig_4 := not na(supporto_4[1]) and low[1] > supporto_4[1] and low <= supporto_4[1]
    //

// -------------------------------------}

//Posizione cover Siffredi
// -------------------------------------{

    if tot_position_scenario_bot > 0 and upperEndPrice_lr < scenario_bot_ask_to_h and scenario_siffredi_cover_line == 0 and na(siffredi_ask)
        siffredi_cover_line := true 
    else 
        siffredi_cover_line := false 
    //
    bool scenario_siffredi_cover = false 

    if siffredi_cover_line and ((market_buy_pattern == "Siffredi") or (market_buy_pattern == "Siffredi look for break"))
        scenario_siffredi_cover := ((vah_trig_base_act) or (poc_2_trig_base_act) or poc_trig_base_act or (val_trig_base_act))
    //
    if scenario_siffredi_cover 
        if not cover_1_line
            block_cover_open := "Cover 1"
        if cover_1_line and not cover_2_line
            block_cover_open := "Cover 2"
        if cover_2_line and not cover_3_line
            block_cover_open := "Cover 3"
        if cover_3_line and not cover_4_line
            block_cover_open := "Cover 4"

    if scenario_siffredi_cover 
        n_posizione := 100
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
         \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
         str.tostring(timenow), "{", titolo, "BUY", n_titoli_moltiplicatore_cover, "}", "}", "}"), alert.freq_once_per_bar)
        //
        scenario_siffredi_cover_line := 1
        scenario_siffredi_cover_ask := vah_trig_base_act   ? (vah_level + spread)            :
                                 poc_2_trig_base_act  ? (poc_second_level + spread)     :
                                 poc_trig_base_act    ? (poc_level + spread)            :
                                 (poc_level + spread)        
        //
        siffredi_ask := scenario_siffredi_cover_ask
        label scenario_siffredi_cover_label = label.new(bar_index, low - (high - low), "scenario siffredi cover", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, scenario_siffredi_cover_label)

    if scenario_siffredi_cover_line == 1 and scenario_siffredi_cover_line[1] == 1 and siffredi_lower_target_trig and high > scenario_siffredi_cover_ask
        n_posizione := 100
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
         \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
        //
        label scenario_siffredi_cover_label_close = label.new(bar_index, high, "close scenario siffredi cover", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, scenario_siffredi_cover_label_close)
        //
        siffredi_ask := na 
        scenario_siffredi_cover_line := 0
        scenario_siffredi_cover_ask  := 0
        block_cover_open := na 
    //



// -------------------------------------}

//Posizione cover 1
// -------------------------------------{

    if supporto_cover_trig_1 
        cover_1_line := true 
    //
    //Aperture
    if cover_1_line
        if supporto_cover_trig_1 and scenario_cover_1_line_to_h == 0 and block_cover_open != "Cover 1" 
            n_posizione := 3
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
             \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
             str.tostring(timenow), "{", titolo, "BUY", n_titoli_moltiplicatore_cover, "}", "}", "}"), alert.freq_once_per_bar)
            scenario_cover_1_line_to_h := 1 
            scenario_cover_1_ask_to_h  := supporto_1 + spread 
            //
            label scenario_cover_1_label_h = label.new(bar_index, low, "scenario_cover_1 h", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_1_label_h)

        if supporto_cover_trig_1 and scenario_cover_1_line_to_l == 0 
            n_posizione := 4
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
             \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
             str.tostring(timenow), "{", titolo, "BUY", n_titoli_moltiplicatore_cover, "}", "}", "}"), alert.freq_once_per_bar)
            scenario_cover_1_line_to_l := 1 
            scenario_cover_1_ask_to_l  := supporto_1 + spread 
            //
            label scenario_cover_1_label_l = label.new(bar_index, low, "scenario_cover_1 l", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_1_label_l)
        //
        //Chiusure
        if scenario_cover_1_line_to_l == 1 and scenario_cover_1_line_to_l[1] == 1 and ((low_trig) or (high > scenario_bot_ask_to_h and not na (scenario_bot_ask_to_h)) or (high > scenario_bot_ask_to_l and not na (scenario_bot_ask_to_l)))  and high > scenario_cover_1_ask_to_l
            n_posizione := 4
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
             \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)

            //
            label scenario_cover_1_close_label_l = label.new(bar_index, high, "close scenario_cover_1 l", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_1_close_label_l)
            //
            scenario_cover_1_line_to_l := 0
            scenario_cover_1_ask_to_l  := 0

            //
        if scenario_cover_1_line_to_h == 1 and scenario_cover_1_line_to_h[1] == 1 and ((high_trig)) and high > scenario_cover_1_ask_to_h
            n_posizione := 3
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
             \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
 
            //
            label scenario_cover_1_close_label_h = label.new(bar_index, high, "close scenario_cover_1 h", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_1_close_label_h)
            //
            scenario_cover_1_line_to_h := 0
            scenario_cover_1_ask_to_h  := 0
            //
        tot_position_scenario_cover_1 := scenario_cover_1_line_to_l + scenario_cover_1_line_to_h
        //Chiusura della line di scenario bot quando non ci sono operazioni aperte
        if tot_position_scenario_cover_1 == 0 and cover_1_line
            cover_1_line := false 
        //

// -------------------------------------}

//Posizione cover 2
// -------------------------------------{

    if supporto_cover_trig_2 and (cover_1_line[1] or not cover_1_line) 
        cover_2_line := true 
    //
    //Aperture
    if cover_2_line
        if supporto_cover_trig_2 and scenario_cover_2_line_to_h == 0 and block_cover_open != "Cover 2"
            n_posizione := 5
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
             \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
             str.tostring(timenow), "{", titolo, "BUY", n_titoli_moltiplicatore_cover, "}", "}", "}"), alert.freq_once_per_bar)
            scenario_cover_2_line_to_h := 1 
            scenario_cover_2_ask_to_h  := supporto_2 + spread 
            //
            label scenario_cover_2_label_h = label.new(bar_index, low, "scenario_cover_2 h", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_2_label_h)

        if supporto_cover_trig_2 and scenario_cover_2_line_to_l == 0 
            n_posizione := 6
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
             \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
             str.tostring(timenow), "{", titolo, "BUY", n_titoli_moltiplicatore_cover, "}", "}", "}"), alert.freq_once_per_bar)
            scenario_cover_2_line_to_l := 1 
            scenario_cover_2_ask_to_l  := supporto_2 + spread 
            //
            label scenario_cover_2_label_l = label.new(bar_index, low, "scenario_cover_2 l", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_2_label_l)
        //
        //Chiusure
        if scenario_cover_2_line_to_l == 1 and scenario_cover_2_line_to_l[1] == 1 and ((low_trig) or (high > scenario_cover_1_ask_to_h and not na(scenario_cover_1_ask_to_h))) and high > scenario_cover_2_ask_to_l
            n_posizione := 6
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
             \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)

            //
            label scenario_cover_2_close_label_l = label.new(bar_index, high, "close scenario_cover_2 l", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_2_close_label_l)
            //
            scenario_cover_2_line_to_l := 0
            scenario_cover_2_ask_to_l  := 0
            //
        if scenario_cover_2_line_to_h == 1 and scenario_cover_2_line_to_h[1] == 1 and ((high_trig)) and high > scenario_cover_2_ask_to_h
            n_posizione := 5
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
             \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)

            //
            label scenario_cover_2_close_label_h = label.new(bar_index, high, "close scenario_cover_2 h", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_2_close_label_h)
            //
            scenario_cover_2_line_to_h := 0
            scenario_cover_2_ask_to_h  := 0
            //
        tot_position_scenario_cover_2 := scenario_cover_2_line_to_l + scenario_cover_2_line_to_h
        //Chiusura della line di scenario bot quando non ci sono operazioni aperte
        if tot_position_scenario_cover_2 == 0 and cover_2_line
            cover_2_line := false 
        //

// -------------------------------------}

//Posizione cover 3
// -------------------------------------{

    if supporto_cover_trig_3 and (cover_2_line[1] or not cover_2_line) 
        cover_3_line := true 
    //
    //Aperture
    if cover_3_line 
        if supporto_cover_trig_3 and scenario_cover_3_line_to_h == 0 and block_cover_open != "Cover 3"
            n_posizione := 7
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
             \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
             str.tostring(timenow), "{", titolo, "BUY", n_titoli_moltiplicatore_cover, "}", "}", "}"), alert.freq_once_per_bar)
            scenario_cover_3_line_to_h := 1 
            scenario_cover_3_ask_to_h  := supporto_3 + spread 
            //
            label scenario_cover_3_label_h = label.new(bar_index, low, "scenario_cover_3 h", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_3_label_h)

        if supporto_cover_trig_3 and scenario_cover_3_line_to_l == 0
            n_posizione := 8
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
             \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
             str.tostring(timenow), "{", titolo, "BUY", n_titoli_moltiplicatore_cover, "}", "}", "}"), alert.freq_once_per_bar)
            scenario_cover_3_line_to_l := 1 
            scenario_cover_3_ask_to_l  := supporto_3 + spread 
            //
            label scenario_cover_3_label_l = label.new(bar_index, low, "scenario_cover_3 l", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_3_label_l)
        //
        //Chiusure
        if scenario_cover_3_line_to_l == 1 and scenario_cover_3_line_to_l[1] == 1 and ((low_trig) or (high > scenario_cover_2_ask_to_h and not na(scenario_cover_2_ask_to_h))) and high > scenario_cover_3_ask_to_l
            n_posizione := 8
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
             \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)

            //
            label scenario_cover_3_close_label_l = label.new(bar_index, high, "close scenario_cover_3 l", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_3_close_label_l)
            //
            scenario_cover_3_line_to_l := 0
            scenario_cover_3_ask_to_l  := 0
        //
        if scenario_cover_3_line_to_h == 1 and scenario_cover_3_line_to_h[1] == 1 and high_trig and high > scenario_cover_3_ask_to_h
            n_posizione := 7
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
             \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)

            //
            label scenario_cover_3_close_label_h = label.new(bar_index, high, "close scenario_cover_3 h", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_3_close_label_h)
            //
            scenario_cover_3_line_to_h := 0
            scenario_cover_3_ask_to_h  := 0
        //
        tot_position_scenario_cover_3 := scenario_cover_3_line_to_l + scenario_cover_3_line_to_h
        //Chiusura della line di scenario bot quando non ci sono operazioni aperte
        if tot_position_scenario_cover_3 == 0 and cover_3_line
            cover_3_line := false 
        //

// -------------------------------------}

//Posizione cover 4
// -------------------------------------{

    if supporto_cover_trig_4 and (cover_3_line[1] or not cover_3_line)
        cover_4_line := true 
    //
    //Aperture
    if cover_4_line 
        if supporto_cover_trig_4 and scenario_cover_4_line_to_h == 0 and block_cover_open != "Cover 4"
            n_posizione := 9
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
             \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
             str.tostring(timenow), "{", titolo, "BUY", n_titoli_moltiplicatore_cover, "}", "}", "}"), alert.freq_once_per_bar)
            scenario_cover_4_line_to_h := 1 
            scenario_cover_4_ask_to_h  := supporto_4 + spread 
            //
            label scenario_cover_4_label_h = label.new(bar_index, low, "scenario_cover_4 h", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_4_label_h)

        if supporto_cover_trig_4 and scenario_cover_4_line_to_l == 0
            n_posizione := 10
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
             \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
             str.tostring(timenow), "{", titolo, "BUY", n_titoli_moltiplicatore_cover, "}", "}", "}"), alert.freq_once_per_bar)
            scenario_cover_4_line_to_l := 1 
            scenario_cover_4_ask_to_l  := supporto_4 + spread 
            //
            label scenario_cover_4_label_l = label.new(bar_index, low, "scenario_cover_4 l", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_4_label_l)
        //
        //Chiusure
        if scenario_cover_4_line_to_l == 1 and scenario_cover_4_line_to_l[1] == 1 and (low_trig or (high > scenario_cover_3_ask_to_h and not na(scenario_cover_3_ask_to_h)))  and high > scenario_cover_4_ask_to_l
            n_posizione := 10
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
             \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)

            //
            label scenario_cover_4_close_label_l = label.new(bar_index, high, "close scenario_cover_4 l", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_4_close_label_l)
            //
            scenario_cover_4_line_to_l := 0
            scenario_cover_4_ask_to_l  := 0
            //
        if scenario_cover_4_line_to_h == 1 and scenario_cover_4_line_to_h[1] == 1 and (high_trig) and high > scenario_cover_4_ask_to_h
            n_posizione := 9
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
             \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)

            //
            label scenario_cover_4_close_label_h = label.new(bar_index, high, "close scenario_cover_4 h", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_4_close_label_h)
            //
            scenario_cover_4_line_to_h := 0
            scenario_cover_4_ask_to_h  := 0
        //
        tot_position_scenario_cover_4 := scenario_cover_4_line_to_l + scenario_cover_4_line_to_h
        //Chiusura della line di scenario bot quando non ci sono operazioni aperte
        if tot_position_scenario_cover_4 == 0 and cover_4_line
            cover_4_line := false 
        //

// Reset supporti
// -----------------------------------------------------------{

    tot_position_cover := tot_position_scenario_cover_1 + tot_position_scenario_cover_2 + tot_position_scenario_cover_3 + tot_position_scenario_cover_4 + scenario_siffredi_cover_line
    var int last_cover_open = 0
    if tot_position_scenario_cover_4        > 0
        last_cover_open := 4
    else if tot_position_scenario_cover_3   > 0
        last_cover_open := 3
    else if tot_position_scenario_cover_2   > 0
        last_cover_open := 2
    else if tot_position_scenario_cover_1   > 0
        last_cover_open := 1

    if tot_position_cover < tot_position_cover[1]
        if last_cover_open == 1 
            supporto_1 := bot 
            if bot_is_sup 
                supporto_2 := old_sup 
                supporto_3 := old_sup_1 
                supporto_4 := old_sup_2 
            else 
                supporto_2 := old_sup_1 
                supporto_3 := old_sup_2 
                supporto_4 := old_sup_3 

        else if last_cover_open == 2 
            supporto_2 := bot 
            if bot_is_sup 
                supporto_3 := old_sup 
                supporto_4 := old_sup_1 
            else 
                supporto_3 := old_sup_1 
                supporto_4 := old_sup_2 

        else if last_cover_open == 3 
            supporto_3 := bot 
            if bot_is_sup 
                supporto_4 := old_sup
            else 
                supporto_4 := old_sup_1 

        else if last_cover_open == 4 
            supporto_4 := bot 

// -------------------------------------}

// -------------------------------------}
 
// -------------------------------------}

// Sezione di copertura sell
// -----------------------------------------------------------{

    var bool sell_line = false 
    var float position_to_cover = 0
    var float target_cover = 0 

    if tot_position > 2 and down_breakout and not sell_line

        sell_line := true 

        if not na(mid_ask)
            position_to_cover_single = 1 * moltiplicatore_mid
            position_to_cover += position_to_cover_single
            target_cover := target_cover + (mid_ask * position_to_cover_single)

        if not na(break_ask)
            position_to_cover_single = 1 * moltiplicatore_break
            position_to_cover += position_to_cover_single
            target_cover := target_cover + (break_ask * position_to_cover_single)

        if scenario_bot_line_to_l == 1 
            position_to_cover_single = 1 * moltiplicatore_bot
            position_to_cover += position_to_cover_single
            target_cover := target_cover + (scenario_bot_ask_to_l * position_to_cover_single)

        if scenario_bot_line_to_h == 1 
            position_to_cover_single = 1 * moltiplicatore_bot
            position_to_cover += position_to_cover_single
            target_cover := target_cover + (scenario_bot_ask_to_h * position_to_cover_single)

        if scenario_actual_over_bot_line == 1 
            position_to_cover_single = 1 * moltiplicatore_mid
            position_to_cover += position_to_cover_single
            target_cover := target_cover + (scenario_actual_over_bot_ask * position_to_cover_single)

        if scenario_cover_1_line_to_l == 1 
            position_to_cover_single = 1 * moltiplicatore_cover
            position_to_cover += position_to_cover_single
            target_cover := target_cover + (scenario_cover_1_ask_to_l * position_to_cover_single)

        if scenario_cover_1_line_to_h == 1 
            position_to_cover_single = 1 * moltiplicatore_cover
            position_to_cover += position_to_cover_single
            target_cover := target_cover + (scenario_cover_1_ask_to_h * position_to_cover_single)

        if scenario_cover_2_line_to_l == 1 
            position_to_cover_single = 1 * moltiplicatore_cover
            position_to_cover += position_to_cover_single
            target_cover := target_cover + (scenario_cover_2_ask_to_l * position_to_cover_single)

        if scenario_cover_2_line_to_h == 1 
            position_to_cover_single = 1 * moltiplicatore_cover 
            position_to_cover += position_to_cover_single
            target_cover := target_cover + (scenario_cover_2_ask_to_h * position_to_cover_single)

        if scenario_cover_3_line_to_l == 1 
            position_to_cover_single = 1 * moltiplicatore_cover 
            position_to_cover += position_to_cover_single 
            target_cover := target_cover + (scenario_cover_3_ask_to_l * position_to_cover_single)

        if scenario_cover_3_line_to_h == 1 
            position_to_cover_single = 1 * moltiplicatore_cover 
            position_to_cover += position_to_cover_single 
            target_cover := target_cover + (scenario_cover_3_ask_to_h * position_to_cover_single)

        if scenario_cover_4_line_to_l == 1 
            position_to_cover_single = 1 * moltiplicatore_cover 
            position_to_cover += position_to_cover_single
            target_cover := target_cover + (scenario_cover_4_ask_to_l * position_to_cover_single)

        if scenario_cover_4_line_to_h == 1 
            position_to_cover_single = 1 * moltiplicatore_cover 
            position_to_cover += position_to_cover_single 
            target_cover := target_cover + (scenario_cover_4_ask_to_h * position_to_cover_single)
    
        if scenario_siffredi_cover_line == 1 
            position_to_cover_single = 1 * moltiplicatore_cover 
            position_to_cover += position_to_cover_single 
            target_cover := target_cover + (scenario_siffredi_cover_ask * position_to_cover_single)

// -------------------------------------}

// Volume indicator
// ------------------------------------------------------------{

levels                                  = array.new_float(cnum + 1)
for x = 0 to cnum by 1
    array.set(levels, x, bot + step * x)
//
// get the volume if there is intersection
get_vol(y11, y12, y21, y22, height, vol) =>
    nz(math.max(math.min(math.max(y11, y12), math.max(y21, y22)) - math.max(math.min(y11, y12), math.min(y21, y22)), 0) * vol / height)
//

//L'indicare volume profile seguente è particolare in quanto raddoppia il peso delle spike rispetto al peso dei corpi in modo da avvicinarsi il più possibile al corretto livello di poc
if (barstate.isconfirmed and run > 0 ) or (run == 0 and barstate.islastconfirmedhistory)
    if run < 2 
        if run == 1
            alert("Run",alert.freq_once_per_bar)
        run                             += 1
    // calculate/get volume for each channel and candle
    volumes                             = array.new_float(cnum * 2, 0.)
    for bars = 0 to bbars - 1 by 1
        body_top                        = math.max(close[bars], open[bars])
        body_bot                        = math.min(close[bars], open[bars])
        itsgreen                        = close[bars] >= open[bars]

        topwick                         = high[bars] - body_top
        bottomwick                      = body_bot - low[bars]
        body                            = body_top - body_bot

        bodyvol                         = body * volume[bars]           / (2 * topwick + 2 * bottomwick + body)
        topwickvol                      = 2 * topwick * volume[bars]    / (2 * topwick + 2 * bottomwick + body)
        bottomwickvol                   = 2 * bottomwick * volume[bars] / (2 * topwick + 2 * bottomwick + body)
        for x = 0 to cnum - 1 by 1
            array.set(volumes, x, array.get(volumes, x) + (itsgreen ? get_vol(array.get(levels, x), array.get(levels, x + 1), body_bot, body_top, body, bodyvol) : 0) + get_vol(array.get(levels, x), array.get(levels, x + 1), body_top, high[bars], topwick, topwickvol) / 2 + get_vol(array.get(levels, x), array.get(levels, x + 1), body_bot, low[bars], bottomwick, bottomwickvol) / 2)
            array.set(volumes, x + cnum, array.get(volumes, x + cnum) + (itsgreen ? 0 : get_vol(array.get(levels, x), array.get(levels, x + 1), body_bot, body_top, body, bodyvol)) + get_vol(array.get(levels, x), array.get(levels, x + 1), body_top, high[bars], topwick, topwickvol) / 2 + get_vol(array.get(levels, x), array.get(levels, x + 1), body_bot, low[bars], bottomwick, bottomwickvol) / 2)
    //
    totalvols                           := array.new_float(cnum, 0.)
    for x = 0 to cnum - 1 by 1
        array.set(totalvols, x, array.get(volumes, x) + array.get(volumes, x + cnum))
    //
    int poc                             = array.indexof(totalvols, array.max(totalvols))

    // calculate value area
    totalmax                            = array.sum(totalvols) * percent / 100.
    va_total                            = array.get(totalvols, poc)
    int up                              = poc
    int down                            = poc
    for x = 0 to cnum - 1 by 1
        if va_total >= totalmax
            break
        uppervol                        = up < cnum - 1 ? array.get(totalvols, up + 1) : 0.
        lowervol                        = down > 0      ? array.get(totalvols, down - 1) : 0.
        if uppervol == 0 and lowervol == 0
            break
        if uppervol >= lowervol
            va_total                    += uppervol
            up                          += 1
            up
        else
            va_total                    += lowervol
            down                        -= 1
            down
    //
    // Sposto le liquiditù sulle assenze di volume per non perdere le inefficienze di apertura di mercato

    float new_bot_liq                   = bot_liq
    
    // Trova l'indice di livello corrispondente a bot_liq
    int bot_liq_index                   = 0
    for i = 0 to cnum - 1
        if array.get(levels, i) <= bot_liq and (i == cnum - 1 or array.get(levels, i + 1) > bot_liq)
            bot_liq_index               := i
            break
    
    // Controlla le barre dall'alto verso il basso per trovare volume assente
    for i = bot_liq_index to 0
        if i < array.size(totalvols)
            if array.get(totalvols, i) == 0
                // Trovata barra con volume assente, aggiorna bot_liq
                new_bot_liq             := array.get(levels, i)
                bot_liq_modified        := true
                break
    
    // Aggiorna bot_liq se necessario
    if bot_liq_modified
        bot_liq                         := new_bot_liq
    //
    float new_top_liq                   = top_liq
    
    // Trova l'indice di livello corrispondente a top_liq
    int top_liq_index                   = cnum - 1
    for i = 0 to cnum - 1
        if array.get(levels, i) <= top_liq and (i == cnum - 1 or array.get(levels, i + 1) > top_liq)
            top_liq_index               := i
            break
    
    // Controlla le barre dal basso verso l'alto per trovare volume assente
    for i = top_liq_index to cnum - 1
        if i < array.size(totalvols)
            if array.get(totalvols, i) == 0
                // Trovata barra con volume assente, aggiorna top_liq
                new_top_liq             := array.get(levels, i)
                top_liq_modified        := true
                break
    
    // Aggiorna top_liq se necessario
    if top_liq_modified
        top_liq                         := new_top_liq

    // Ottimizzazione migliorata del livello VAH - SOLO VERSO L'ALTO ricerco livelli con ratio maggiore a quello attuale 
    int original_up                     = up
    bool vah_moved                      = false

    // Iterazione verso l'alto
    int current_level                   = original_up
    float current_max_vol               = array.get(totalvols, current_level)
    int max_vol_level                   = current_level

    // Verifica se esiste un livello superiore e cerca livelli con volume maggiore
    while current_level + 1 < cnum
        current_level                   += 1
        float next_vol                  = array.get(totalvols, current_level)
        
        // Se il volume del livello superiore è maggiore, aggiorna il massimo
        if next_vol > current_max_vol
            current_max_vol             := next_vol
            max_vol_level               := current_level
            vah_moved                   := true
        else
            // Se troviamo un volume inferiore, interrompiamo
            break

    // Aggiorna il valore di up con il livello di massimo volume trovato
    up                                  := max_vol_level

    // Ottimizzazione migliorata del livello VAL - SOLO VERSO IL BASSO ricerco livelli con ratio maggiore a quello attuale 
    int original_down                   = down
    bool val_moved                      = false

    // Iterazione verso il basso
    current_level                       := original_down
    current_max_vol                     := array.get(totalvols, current_level)
    max_vol_level                       := current_level

    // Verifica se esiste un livello inferiore
    while current_level > 0
        current_level                   -= 1
        float next_vol                  = array.get(totalvols, current_level)
        
        // Se il volume del livello inferiore è maggiore, aggiorna il massimo
        if next_vol > current_max_vol
            current_max_vol             := next_vol
            max_vol_level               := current_level
            val_moved                   := true
        else
            // Se troviamo un volume inferiore, interrompiamo
            break

    // Aggiorna il valore di down con il livello di massimo volume trovato
    down                                := max_vol_level

    // Solo dopo l'ottimizzazione, ricalcola i livelli VAH e VAL
    vah_level                           := up < cnum - 1 ? (array.get(levels, up) + array.get(levels, up + 1)) / 2 : array.get(levels, up)
    val_level                           := down > 0 ? (array.get(levels, down) + array.get(levels, down + 1)) / 2 : array.get(levels, down)
    poc_level                           := (array.get(levels, poc) + array.get(levels, poc + 1)) / 2

    // Trova il POC più grande al di fuori dell'area di valore
    float ext_poc_vol                   = 0
    int levels_size                     = array.size(levels)
    int totalvols_size                  = array.size(totalvols)

    // Variabile temporanea per memorizzare il risultato
    float temp_poc_second_level         = na

    // Cerca sotto VAL (sicuro)
    if down > 0  // Verifica che ci siano livelli sotto VAL
        for i = 0 to math.min(down - 1, totalvols_size - 1)
            if i + 1 < levels_size  // Controlla che i+1 sia un indice valido per levels
                float vol           = array.get(totalvols, i)
                if vol > ext_poc_vol
                    ext_poc_vol     := vol
                    temp_poc_second_level := (array.get(levels, i) + array.get(levels, i + 1)) / 2

    // Cerca sopra VAH (sicuro)
    if up + 1 < totalvols_size  // Verifica che ci siano livelli sopra VAH
        int start_i                     = up + 1
        int end_i                       = totalvols_size - 1
        
        // Solo se start_i <= end_i, esegui il ciclo
        if start_i <= end_i
            for i = start_i to end_i
                if i + 1 < levels_size  // Controlla che i+1 sia un indice valido per levels
                    float vol       = array.get(totalvols, i)
                    if vol > ext_poc_vol
                        ext_poc_vol := vol
                        temp_poc_second_level := (array.get(levels, i) + array.get(levels, i + 1)) / 2

    // Assegna il risultato solo se abbiamo trovato un valore valido
    if not na(temp_poc_second_level)
        poc_second_level                := temp_poc_second_level    // Determina se il POC è rialzista o ribassista basandosi sul volume
    float poc_buy_volume                = array.get(volumes, poc)
    float poc_sell_volume               = array.get(volumes, poc + cnum)

    if poc_buy_volume > poc_sell_volume
        poc_color                       := color.blue  // Maggior volume di acquisto
        poc_is_buy                      := true 
    else if poc_sell_volume > poc_buy_volume
        poc_color                       := color.red // Maggior volume di vendita
        poc_is_buy                      := false 

    // Trova l'indice che corrisponde a val_level
    int val_index                       = down
    // Trova l'indice che corrisponde a top (ultimo elemento dell'array levels)
    int top_index                       = cnum - 1
    // L'indice che corrisponde a bot è 0

    // Versione robusta per il calcolo del volume tra val_level e bot
    float val_to_bot_volume             = 0.0
    if val_index >= 0  // Controlla che val_index sia valido
        for i = 0 to math.min(val_index, cnum - 1)  // Limita l'indice superiore
            val_to_bot_volume           += array.get(totalvols, i)

    // Versione robusta per il calcolo del volume tra vah_level e top
    float vah_to_top_volume             = 0.0
    if up + 1 < cnum and top_index >= 0  // Controlla validità di entrambi gli indici
        for i = math.max(0, up + 1) to math.min(top_index, cnum - 1)  // Limita entrambi gli indici
            vah_to_top_volume           += array.get(totalvols, i)

    // Calcolo del volume totale rimane invariato
    float total_volume                  = array.sum(totalvols)
    // Calcola le percentuali rispetto al volume totale
    val_to_bot_volume_perc              := (val_to_bot_volume / total_volume) * 100
    vah_to_top_volume_perc              := (vah_to_top_volume / total_volume) * 100
    central_volume_perc                 := 100 - val_to_bot_volume_perc - vah_to_top_volume_perc
//

// Calcolo delle percentuali di volume rispetto al POC
    // -----------------------------------------------------------{

    // Calcola solo dopo che il profilo volumetrico è stato completato
    if run > 0
        // Trova l'indice che corrisponde al POC
        int poc_index                   = array.indexof(totalvols, array.max(totalvols))
        
        // Trova l'indice che corrisponde al VAH
        int vah_index                   = up
        
        // Trova l'indice che corrisponde al POC_2
        // Calcola la distanza tra POC e POC_2 per determinare l'indice
        float poc_to_poc_2_distance     = math.abs(poc_level - poc_second_level)
        int poc_2_index                 = -1
        
        // Determina l'indice di POC_2 cercando il livello più vicino
        if not na(poc_second_level)
            float min_distance          = 999999.0
            for i = 0 to cnum - 1
                float level_mid         = (array.get(levels, i) + array.get(levels, i + 1)) / 2
                float distance          = math.abs(level_mid - poc_second_level)
                if distance < min_distance
                    min_distance        := distance
                    poc_2_index         := i
        
        // Calcola i rapporti di volume solo se gli indici sono validi
        if poc_index >= 0 and vah_index >= 0
            float poc_volume            = array.get(totalvols, poc_index)
            
            if poc_volume > 0
                // Calcola il rapporto tra il volume al VAH e il volume al POC
                float vah_volume        = array.get(totalvols, vah_index)
                vah_to_poc_vol_ratio    := (vah_volume / poc_volume) * 100
                
                // Calcola il rapporto tra il volume al POC_2 e il volume al POC
                if poc_2_index >= 0
                    float poc_2_volume  = array.get(totalvols, poc_2_index)
                    poc_2_to_poc_vol_ratio := (poc_2_volume / poc_volume) * 100
                    
                // Calcola il rapporto tra il volume al VAL e il volume al POC
                if val_index >= 0
                    float val_volume    = array.get(totalvols, val_index)
                    val_to_poc_vol_ratio := (val_volume / poc_volume) * 100

    // -------------------------------------}
// -------------------------------------}

// Definizione label - line e valori top/bot delle linee di poc - val e vah
// ------------------------------------------------------------{

    mid_distance                        = global_distance / 2

    poc_bot_level                       := bot + mid_distance 

    vah_perc                            := math.round(((vah_level - bot) / global_distance) * 100)
    poc_perc                            := math.round(((poc_level - bot) / global_distance) * 100)
    poc_2_perc                          := math.round(((poc_second_level - bot) / global_distance) * 100)
    val_perc                            := math.round(((val_level - bot) / global_distance) * 100)
    bot_liq_perc                        := math.round(((bot_liq - bot) / global_distance) * 100)
    top_liq_perc                        := math.round(((top_liq - bot) / global_distance) * 100)

    vol_distance                        = vah_level - val_level
    vol_distance_perc                   := vah_perc - val_perc
    vol_value                           := vah_level - val_level
    //
    if scenario_break_out_line == 1 
        break_ask_perc := math.round(((break_ask - bot) / global_distance) * 100)
    else
        break_ask_perc := na 
    //Riadattamento di posizioni cover (aggiunto successivamente per recuperare media del volume corretta per distanziare le posizioni switch_resistenza//Riordino supporti e resistenze quando viene impostato un nuovo pivot e quel pivot corrisponde a sup/res attuale)
    // -----------------------------------------------------------{

    piv_distance_1                      := piv_distance   * incremento_distanza_pivot
    piv_distance_2                      := piv_distance_1 * incremento_distanza_pivot
    piv_distance_3                      := piv_distance_2 * incremento_distanza_pivot

    //Gestione del sistema cover dopo l'iterazione run == 0 che definisce i punti di start, potrebbe essere spostato sopra questo blocco, al momento si trova qua perchè le posizioni cover erano precedentemente ancorate alla distanza VAL VAH che però portava a delle sovracompressioni in timeframe brevi, in realtà a timeframe alti era in grado di velocizzare la gestione a timeframe alti e non scarterei a priori questa opzione.
    if run > 0 and array.size(a_sup) > 0
        tot_sup                         := 0 
        //
        old_sup                         := na
        old_sup_1                       := na
        old_sup_2                       := na
        old_sup_3                       := na
        array.sort(a_sup, order.descending)  // Ordine decrescente per supporti
        // Trova il primo supporto <= actual_supporto
        for i = 0 to array.size(a_sup) - 1
            if fast_play and bot_is_sup
                if array.get(a_sup, i) < bot - piv_distance
                    old_sup             := array.get(a_sup, i)
                    if not na(old_sup)
                        tot_sup         += 1
                    break
        for i = 0 to array.size(a_sup) - 1
            if fast_play and not bot_is_sup
                if array.get(a_sup, i) < bot
                    old_sup             := array.get(a_sup, i)
                    if not na(old_sup)
                        tot_sup         += 1
                    break
        //
        for i = 0 to array.size(a_sup) - 1
            if not fast_play 
                if array.get(a_sup, i) < actual_supporto - piv_distance 
                    old_sup             := array.get(a_sup, i)
                    if not na(old_sup)
                        tot_sup         += 1
                    break
        //
        if not na(old_sup)
            for i = 0 to array.size(a_sup) - 1
                if array.get(a_sup, i) < old_sup - piv_distance_1
                    old_sup_1           := array.get(a_sup, i)
                    if not na(old_sup_1)
                        tot_sup         += 1
                    break
        if not na(old_sup_1) 
            for i = 0 to array.size(a_sup) - 1
                if array.get(a_sup, i) < old_sup_1 - piv_distance_2
                    old_sup_2           := array.get(a_sup, i)
                    if not na(old_sup_2)
                        tot_sup         += 1
                    break
        if not na(old_sup_2)
            for i = 0 to array.size(a_sup) - 1
                if array.get(a_sup, i) < old_sup_2 - piv_distance_3
                    old_sup_3           := array.get(a_sup, i)
                    if not na(old_sup_3)
                        tot_sup         += 1
                    break
        //
    if run > 0 and array.size(a_sup) > 0 
        tot_res                         := 0 
        //
        old_res                         := na
        old_res_1                       := na
        old_res_2                       := na
        old_res_3                       := na

        array.sort(a_sup, order.ascending) // Ordine crescente per resistenze
        
        // Trova la prima resistenza >= actual_resistenza
        for i = 0 to array.size(a_sup) - 1
            if fast_play 
                if array.get(a_sup, i) > top + piv_distance and block_start_bar
                    old_res             := array.get(a_sup, i)
                    if not na(old_res)
                        tot_res         += 1 
                    break
                if array.get(a_sup, i) > top and not block_start_bar
                    old_res             := array.get(a_sup, i)
                    if not na(old_res)
                        tot_res         += 1
                    break
        for i = 0 to array.size(a_sup) - 1
            if not fast_play 
                if array.get(a_sup, i) > actual_resistenza + piv_distance 
                    old_res             := array.get(a_sup, i)
                    if not na(old_res)
                        tot_res         += 1 
                    break
        //     
        if not na(old_res)
            for i = 0 to array.size(a_sup) - 1
                if array.get(a_sup, i) > old_res + piv_distance_1_res
                    old_res_1           := array.get(a_sup, i)
                    if not na(old_res_1)
                        tot_res         += 1 
                    break
        if not na(old_res_1)
            for i = 0 to array.size(a_sup) - 1
                if array.get(a_sup, i) > old_res_1 + piv_distance_2_res
                    old_res_2           := array.get(a_sup, i)
                    if not na(old_res_2)
                        tot_res         += 1 
                    break
        if not na(old_res_2)
            for i = 0 to array.size(a_sup) - 1
                if array.get(a_sup, i) > old_res_2 + piv_distance_3_res
                    old_res_3           := array.get(a_sup, i)
                    if not na(old_res_3)
                        tot_res         += 1 
                    break
    //

    // -------------------------------------}

//Sistema generale di plot 
    if run > 1 and not show_plot
        line.delete(poc_line)
        line.delete(poc_2_line)
        line.delete(top_line)
        line.delete(bot_line)
        line.delete(upper_line)
        line.delete(lower_line)
        line.delete(lower_line_liq)
        line.delete(higher_line_liq)
        line.delete(poc_bot_level_line)
        line.delete(poc_top_level_line)
        line.delete(res_line)
        line.delete(sup_line)
        line.delete(res_line_1)
        line.delete(sup_line_1)
        line.delete(res_line_2)
        line.delete(sup_line_2)
        line.delete(res_line_3)
        line.delete(sup_line_3)
    //
    if show_plot or run == 0 or run == 1 

        line.delete(poc_line)
        line.delete(poc_2_line)
        line.delete(top_line)
        line.delete(bot_line)
        line.delete(upper_line)
        line.delete(lower_line)
        line.delete(lower_line_liq)
        line.delete(higher_line_liq)
        line.delete(poc_bot_level_line)
        line.delete(poc_top_level_line)
        line.delete(res_line)
        line.delete(sup_line)
        line.delete(res_line_1)
        line.delete(sup_line_1)
        line.delete(res_line_2)
        line.delete(sup_line_2)
        line.delete(res_line_3)
        line.delete(sup_line_3)

        if high_perc == vah_perc or low_perc == vah_perc
            vah_color                   := positiveColor
        else
            vah_color                   := negativeColor
        //
        if high_perc == val_perc or low_perc == val_perc
            val_color                   := positiveColor
        else
            val_color                   := negativeColor
        //
        poc_2_color                     := poc_level > poc_second_level ? color.red : color.blue
        // Disegna le linee
        poc_line                        := line.new(bar_index - bbars, poc_level,  bar_index + 13, poc_level,   color=poc_color,     width=poc_width, force_overlay = true)    
        poc_2_line                      := line.new(bar_index - bbars, poc_second_level,  bar_index + 13, poc_second_level,   color=poc_2_color,     width=poc_width, force_overlay = true)    
        top_line                        := line.new(bar_index - bbars, top,        bar_index + 13, top,         color=negativeColor,   width=ext_width, force_overlay = true)    
        bot_line                        := line.new(bar_index - bbars, bot,        bar_index + 13, bot,         color=bot_is_sup ? positiveColor : negativeColor, width=ext_width, force_overlay = true)    
        upper_line                      := line.new(bar_index - bbars, vah_level,  bar_index + 13, vah_level,   color=color.white, width=vah_width, force_overlay = true)
        lower_line                      := line.new(bar_index - bbars, val_level,  bar_index + 13, val_level,   color=color.white, width=val_width, force_overlay = true)
        lower_line_liq                  := line.new(bar_index - bbars, bot_liq,    bar_index + 13, bot_liq,     color=color.green, width=val_width, force_overlay = true)
        higher_line_liq                 := line.new(bar_index - bbars, top_liq,    bar_index + 13, top_liq,     color=color.red,   width=val_width, force_overlay = true)
        res_line                        := line.new(bar_index - bbars, old_res,    bar_index + 13, old_res,     color=negativeColor,   width=2, force_overlay = true)
        sup_line                        := line.new(bar_index - bbars, old_sup,    bar_index + 13, old_sup,     color=positiveColor, width=2, force_overlay = true)
        res_line_1                      := line.new(bar_index - bbars, old_res_1,  bar_index + 13, old_res_1,   color=negativeColor,   width=2, force_overlay = true)
        sup_line_1                      := line.new(bar_index - bbars, old_sup_1,  bar_index + 13, old_sup_1,   color=positiveColor, width=2, force_overlay = true)
        res_line_2                      := line.new(bar_index - bbars, old_res_2,  bar_index + 13, old_res_2,   color=negativeColor,   width=2, force_overlay = true)
        sup_line_2                      := line.new(bar_index - bbars, old_sup_2,  bar_index + 13, old_sup_2,   color=positiveColor, width=2, force_overlay = true)
        res_line_3                      := line.new(bar_index - bbars, old_res_3,  bar_index + 13, old_res_3,   color=negativeColor,   width=2, force_overlay = true)
        sup_line_3                      := line.new(bar_index - bbars, old_sup_3,  bar_index + 13, old_sup_3,   color=positiveColor, width=2, force_overlay = true)
        //
        
        dist                            = (top - bot) / 500
        
        // Trova il volume massimo per la normalizzazione
        float max_vol               = 0
        for i = 0 to cnum - 1
            max_vol                 := math.max(max_vol, array.get(volumes, i) + array.get(volumes, i + cnum))

        // Definisci la larghezza massima desiderata in barre
        int max_width               = 50  // Puoi regolare questo valore secondo le tue preferenze

        for x = 0 to cnum - 1 by 1
            box.delete(array.get(vol_bars, x))
            box.delete(array.get(vol_bars, x + cnum))
            
            // Calcola la larghezza normalizzata per volumi rialzisti
            int bull_width          = max_vol > 0 ? math.min(math.round(array.get(volumes, x) / max_vol * max_width), max_width) : 0
            
            // Disegna le barre rialziste
            array.set(vol_bars, x, box.new(bar_index + 13, 
                                             array.get(levels, x + 1) - dist, 
                                             bar_index + 13 + bull_width, 
                                             array.get(levels, x) + dist, 
                                             border_width=0, 
                                             bgcolor=x >= down and x <= up ? vup_color : up_color,
                                             force_overlay= true ))

            // Calcola la larghezza normalizzata per volumi ribassisti
            int bear_width          = max_vol > 0 ? math.min(math.round(array.get(volumes, x + cnum) / max_vol * max_width), max_width) : 0

            // Disegna le barre ribassiste
            array.set(vol_bars, x + cnum, box.new(bar_index + 13 + bull_width, 
                                                     array.get(levels, x + 1) - dist, 
                                                     bar_index + 13 + bull_width + bear_width, 
                                                     array.get(levels, x) + dist, 
                                                     border_width=0, 
                                                     bgcolor=x >= down and x <= up ? vdown_color : down_color,
                                                     force_overlay= true))
//

// -------------------------------------}

// Ema per identificare la zona di prezzo
// -----------------------------------------------------------{
 
ema                                     = ta.ema(close, lenght_ema)
ema_trend_up                            = ema > ema[1] and barstate.isconfirmed
ema_trend_down                          = ema < ema[1] and barstate.isconfirmed 

ema_switch_up                           := ema_trend_down[1] and ema_trend_up and barstate.isconfirmed
ema_switch_down                         := ema_trend_up[1] and ema_trend_down and barstate.isconfirmed


//Verifico che per le partenze di val e poi - o comunque di tutte le partenze non in bot o sup, la provenienza del trend sia alta.
if ema_switch_up 
    ema_value_before_start              := ta.lowest(ema, lenght_ema/2) 
if ema_switch_down
    ema_value_before_start              := ta.highest(ema, lenght_ema/2)
    last_ema_switch_down                := ema_value_before_start
    contatore_ema_switch_down           := 0 
//
if not ema_switch_down
    contatore_ema_switch_down           += 1
//

prezzo_interpolato_lr_start         := upperStartPrice_lr + ((upperEndPrice_lr - upperStartPrice_lr) * (bbars - contatore_ema_switch_down) / bbars)
//
if not na(prezzo_interpolato_lr_start) and ema_switch_down
    prezzo_interpolato_lr_start         := na 
    //

ema_over_lr                             := (not na(prezzo_interpolato_lr_start) and last_ema_switch_down > prezzo_interpolato_lr_start )

if run > 0
    if ema_value_before_start > val_level and high[1] > val_level and low > val_level
        val_is_in_buy                   := true 
    else
        val_is_in_buy                   := false 
    //
    if ema_value_before_start > vah_level and high[1] > vah_level and low > vah_level
        vah_is_in_buy                   := true 
    else
        vah_is_in_buy                   := false 
    //
    if ema_value_before_start > poc_level and high[1] > poc_level and low > poc_level 
        poc_is_in_buy                   := true 
    else
        poc_is_in_buy                   := false 
    //
    if ema_value_before_start > poc_second_level and high[1] > poc_second_level and low > poc_second_level
        poc_2_is_in_buy                 := true 
    else
        poc_2_is_in_buy                 := false 
    //
    if ema_value_before_start > bot_liq and high[1] > bot_liq and low > bot_liq
        bot_liq_is_in_buy               := true 
    else
        bot_liq_is_in_buy               := false 
    if ema_value_before_start > actual_supporto and high[1] > actual_supporto and actual_supporto == actual_supporto[1] and low > actual_supporto
        act_sup_is_in_buy               := true 
    else
        act_sup_is_in_buy               := false 
//

// -------------------------------------}

// LR
// -----------------------------------------------------------{

//Utilizzo una lr per la gestione del trend, al momento risulta poco utilizzato rispetto alle sue reali potenzialità, il pearson è uno strumento fondamentale per la dinamizzazione dei flussi verso i rispettivi target

lengthInput_lr                          = bbars
sourceInput_lr                          = close

extendStyle_lr                          = extendLeftInput_lr and extendRightInput_lr ? extend.both : 
                                          extendLeftInput_lr ? extend.left : 
                                          extendRightInput_lr ? extend.right : 
                                          extend.none

group3_lr                               = "Color Settings"
colorUpper_lr                           = color.new(color.blue, 90)
colorLower_lr                           = color.new(color.red, 90)
 
//

[s_lr, a_lr, i_lr]                      = M.calcSlope_lr(sourceInput_lr, lengthInput_lr, run)
startPrice_lr                           = i_lr + s_lr * (lengthInput_lr - 1)
endPrice_lr                             = i_lr


if show_plot or run == 0 or run == 1 

    if na(baseLine_lr) and not na(startPrice_lr)
        baseLine_lr                     := line.new(bar_index - lengthInput_lr + 1, startPrice_lr, bar_index, endPrice_lr, width=1, extend=extendStyle_lr, color=color.new(colorLower_lr, 0), force_overlay = true)
    else
        if not na(startPrice_lr)
            line.set_xy1(baseLine_lr, bar_index - lengthInput_lr + 1, startPrice_lr)
            line.set_xy2(baseLine_lr, bar_index, endPrice_lr)
    //

[stdDev_lr, pearsonR_lr, upDev_lr, dnDev_lr] = M.calcDev_lr(sourceInput_lr, lengthInput_lr, s_lr, a_lr, i_lr, run)
//
pearson := pearsonR_lr
upperStartPrice_lr                      := startPrice_lr + (useUpperDevInput_lr ? upperMultInput_lr * stdDev_lr : upDev_lr)
upperEndPrice_lr                        := endPrice_lr   + (useUpperDevInput_lr ? upperMultInput_lr * stdDev_lr : upDev_lr)

lowerStartPrice_lr                      := startPrice_lr + (useLowerDevInput_lr ? -lowerMultInput_lr * stdDev_lr : -dnDev_lr)
lowerEndPrice_lr                        := endPrice_lr   + (useLowerDevInput_lr ? -lowerMultInput_lr * stdDev_lr : -dnDev_lr)


if show_plot or run == 0 or run == 1 
    if na(upper_lr) and not na(upperStartPrice_lr)
        upper_lr                        := line.new(bar_index - lengthInput_lr + 1, upperStartPrice_lr, bar_index, upperEndPrice_lr, width=1, extend=extendStyle_lr, color=color.new(colorUpper_lr, 0), force_overlay = true)
    else
        if not na(upperStartPrice_lr)
            line.set_xy1(upper_lr, bar_index - lengthInput_lr + 1, upperStartPrice_lr)
            line.set_xy2(upper_lr, bar_index, upperEndPrice_lr)
        //
    if na(lower_lr) and not na(lowerStartPrice_lr)
        lower_lr                        := line.new(bar_index - lengthInput_lr + 1, lowerStartPrice_lr, bar_index, lowerEndPrice_lr, width=1, extend=extendStyle_lr, color=color.new(colorUpper_lr, 0), force_overlay = true)
    else
        if not na(lowerStartPrice_lr)
            line.set_xy1(lower_lr, bar_index - lengthInput_lr + 1, lowerStartPrice_lr)
            line.set_xy2(lower_lr, bar_index, lowerEndPrice_lr)
        //
    if not na(upper_lr) and not na(baseLine_lr)
        linefill.new(upper_lr, baseLine_lr, color = colorUpper_lr)
    if not na(baseLine_lr) and not na(lower_lr)
        linefill.new(baseLine_lr, lower_lr, color = colorLower_lr)
    //

float trend_lr                          = math.sign(startPrice_lr - endPrice_lr)

// Memorizza i valori precedenti di Pearson e percent_change

// Calcola la pendenza come percentuale
percent_change                          = run > 0 ? (endPrice_lr - startPrice_lr) * 100 / startPrice_lr : na 

if percent_change >= 0 and run > 0
    trend_up                            := true
else
    trend_up                            := false
//

real_pearson                            = trend_up ? pearson : -pearson

lr_distance                             = upperStartPrice_lr - lowerStartPrice_lr
lr_vol_perc                             := 100 - (((global_distance - lr_distance)/global_distance)*100)
//

lower_lr_perc                           := math.round(((lowerEndPrice_lr - bot) / global_distance) * 100)
upper_lr_perc                           := math.round(((upperEndPrice_lr - bot) / global_distance) * 100)
//

// -------------------------------------}

// Volume analisi
// -----------------------------------------------------------{

//Analisi sommaria del volume, al momento questa prima struttura di analisi risulta povera di funzioni utili salvo per il livello top compression, sono sicuro che un'analisi della coordinazione del volume potrebbe scindere pattern diversi

bot_vol_ratio                           = val_to_bot_volume_perc / val_perc
mid_vol_ratio                           = central_volume_perc / vol_distance_perc
top_vol_ratio                           = vah_to_top_volume_perc / (100 - vah_perc)

if run > 0 
    //Sezione bot
    if val_perc <= 5
        volume_bot_condition := "No data", bot_level_vol := 0 
    else if bot_vol_ratio <= 0.4 and volume_bot_condition != "Spike"
        volume_bot_condition := "Spike", bot_level_vol := 1 
    else if bot_vol_ratio > 0.4 and bot_vol_ratio <= 0.7 and volume_bot_condition != "Basso"
        volume_bot_condition := "Basso", bot_level_vol := 2 
    else if bot_vol_ratio > 0.7 and bot_vol_ratio <= 0.9 and volume_bot_condition != "Medio"
        volume_bot_condition := "Medio", bot_level_vol := 3 
    else if bot_vol_ratio > 0.9 and bot_vol_ratio <= 1.1 and volume_bot_condition != "Forte"
        volume_bot_condition := "Forte", bot_level_vol := 4 
    else if bot_vol_ratio > 1.1 and volume_bot_condition != "Iper"
        volume_bot_condition := "Iper", bot_level_vol := 5 
    //Sezione top 
    if vah_perc >= 95
        volume_top_condition := "No data", top_level_vol := 0 
    else if top_vol_ratio <= 0.4 and volume_top_condition != "Spike"
        volume_top_condition := "Spike", top_level_vol := 1 
    else if top_vol_ratio > 0.4 and top_vol_ratio <= 0.7 and volume_top_condition != "Basso"
        volume_top_condition := "Basso", top_level_vol := 2 
    else if top_vol_ratio > 0.7 and top_vol_ratio <= 0.9 and volume_top_condition != "Medio"
        volume_top_condition := "Medio", top_level_vol := 3 
    else if top_vol_ratio > 0.9 and top_vol_ratio <= 1.1 and volume_top_condition != "Forte"
        volume_top_condition := "Forte", top_level_vol := 4 
    else if top_vol_ratio > 1.1 and volume_top_condition != "Iper"
        volume_top_condition := "Iper", top_level_vol := 5 
    //Sezione mid 
    if mid_vol_ratio <= 0.5 and volume_mid_condition != "Micro"
        volume_mid_condition := "Micro", mid_level_vol := 1
    else if mid_vol_ratio > 0.5 and mid_vol_ratio <= 0.8 and volume_mid_condition != "Basso"
        volume_mid_condition := "Basso", mid_level_vol := 2
    else if mid_vol_ratio > 0.8 and mid_vol_ratio <= 1.2 and volume_mid_condition != "Medio"
        volume_mid_condition := "Medio", mid_level_vol := 3
    else if mid_vol_ratio > 1.2 and mid_vol_ratio <= 1.5 and volume_mid_condition != "Forte"
        volume_mid_condition := "Forte", mid_level_vol := 4
    else if mid_vol_ratio > 1.5 and volume_mid_condition != "Iper"
        volume_mid_condition := "Iper", mid_level_vol := 5

var string volume_dispersion            = na 

if mid_level_vol >= 4
    if top_level_vol == 0 and volume_dispersion != "No Top Data"
        volume_dispersion               := "No Top Data"
    else if bot_level_vol == 0 and volume_dispersion != "No Bot Data"
        volume_dispersion               := "No Bot Data"
    else if bot_level_vol >= 4 and top_level_vol >= 4 and volume_dispersion != "No Vol Focus"
        volume_dispersion               := "No Vol Focus"
    else if bot_level_vol >= 4 and top_level_vol < 4 and volume_dispersion != "Bot - Mid Dispersion"
        volume_dispersion               := "Bot - Mid Dispersion"
    else if top_level_vol >= 4 and bot_level_vol < 4 and volume_dispersion != "Top - Mid Dispersion"
        volume_dispersion               := "Top - Mid Dispersion"
    else if mid_level_vol == 4 and top_level_vol < 4 and bot_level_vol < 4 and volume_dispersion != "Focus Mid Vol"
        volume_dispersion               := "Focus Mid Vol"
    else if mid_level_vol == 5 and top_level_vol < 4 and bot_level_vol < 4 and volume_dispersion != "Iper Focus Mid Vol"
        volume_dispersion               := "Iper Focus Mid Vol"
    //

if mid_level_vol < 4 
    if top_level_vol == 0 and volume_dispersion != "No Top Data"
        volume_dispersion               := "No Top Data"
    else if bot_level_vol == 0 and volume_dispersion != "No Bot Data"
        volume_dispersion               := "No Bot Data"
    else if bot_level_vol >= 4 and top_level_vol >= 4 and volume_dispersion != "Top - Bot Focus"
        volume_dispersion               := "Top - Bot Focus"
    else if bot_level_vol >= 4 and top_level_vol < 4 and volume_dispersion != "Bot Dispersion"
        volume_dispersion               := "Bot Dispersion"
    else if top_level_vol >= 4 and bot_level_vol < 4 and volume_dispersion != "Top Dispersion"
        volume_dispersion               := "Top Dispersion"
    else if top_level_vol < 4 and bot_level_vol < 4 and volume_dispersion != "Vol Fluido"
        volume_dispersion               := "Vol Fluido"
    //
//

// -------------------------------------}

// Market analisi 
// -----------------------------------------------------------{

if not na(bot) and bot != 0  // Evita la divisione per zero
    new_poc_perc                        := math.round(((poc_level - bot_liq) / bot_liq_distance) * 100)
else
    // Se fib_perc_4 è minore o uguale a bot_liq_perc, allora la nuova percentuale è 0
    new_poc_perc                        := na
//

// Analisi generale di mercato 
if (run > 0 and barstate.isconfirmed) or run == 1 
    //Stringhe d'ingresso con run == 1 
    if run == 1 and bot_is_sup and not trend_up 
        market                          := "Fall Accumula Liq"
    if run == 1 and bot_is_sup and trend_up 
        market                          := "Trend Up"
    if run == 1 and not bot_is_sup and not trend_up 
        market                          := "Trend Down"
    if run == 1 and not bot_is_sup and trend_up 
        market                          := "Fall Spike Up"
    //
    //Iterazioni post inizializzazione per incrociare i dati di start
    if market == "Fall Spike Up" and bot_is_sup 
        market                          := "Trend Up"
    if market == "Fall Spike Up" and not trend_up 
        market                          := "Trend Down"
    if market == "Fall Accumula Liq" and trend_up 
        market                          := "Trend Up"
    if market == "Fall Accumula Liq" and not bot_is_sup 
        market                          := "Trend Down"
    if market == "Trend Up" and not trend_up
        market                          := "Fall Accumula Liq"
    if market == "Trend Down" and bot_is_sup 
        market                          := "Fall Accumula Liq"
    if market == "Trend Down" and trend_up
        market                          := "Fall Spike Up"
    //
    //Iterazione per prevedere lo switch del trend verso l'alto 
    if (market == "Fall Accumula Liq" or market == "Trend Down") and (high >upperEndPrice_lr or ema_over_lr )
        market                          := "Switch Up Trend"
    if market == "Switch Up Trend" and (trend_up)
        market                          := "Trend Up"
    if market == "Switch Up Trend" and low < bot_liq
        market                          := "Trend Down"
    // 
    //Passaggio alle definizioni dei pattern di gioco 
    if market == "Fall Accumula Liq" or market == "Trend Up" or market == "Fall Spike Up" or market == "Switch Up Trend" or (market == "Trend Down" and pearson < 0.2 )
        active_mid_trade                := true 
    else 
        active_mid_trade                := false  
        market_buy_pattern              := "No Buy Pattern" 
    //
    //Impostazione degli scenari quando l'analisi di mercato fornisce un responso d'analisi
    if active_mid_trade 
        low_level                       := math.min(val_level, poc_second_level)
        //Definizione delle figure
        figura_vah_to_bot_target        = vah_perc <= fib_for_scenario and vah_perc <= (lower_lr_perc) and vah_perc > (bot_liq_perc)
         and vah_is_in_buy and 
         (na(break_start_perc) or (not na(break_start_perc) and vah_perc   < (break_start_perc - (min_level[1] / 2)))) //Questa struttura serve per abbassare la posizione mid quando la posizone break è aperta
 
        figura_poc_to_bot_target        = ((poc_perc <= fib_for_scenario) or (not na(new_fib_perc_5) and new_poc_perc <= new_fib_perc_5)) 
         and ((poc_perc <= (lower_lr_perc) or val_perc < bot_liq_perc)) and poc_perc > (bot_liq_perc) 
         and poc_is_in_buy and not figura_vah_to_bot_target and 
         (na(break_start_perc) or (not na(break_start_perc) and poc_perc   < (break_start_perc - (min_level[1] / 2))))

        figura_val_to_bot_target        = (val_perc <= fib_for_scenario and val_perc <= (lower_lr_perc) and val_perc > (bot_liq_perc)
         and val_is_in_buy and not figura_poc_to_bot_target) and not figura_poc_to_bot_target and not figura_vah_to_bot_target and 
         (na(break_start_perc) or (not na(break_start_perc) and val_perc   < (break_start_perc - (min_level[1] / 2))))

        figura_poc_2_to_bot_target      = ((poc_2_perc <= fib_for_scenario and poc_2_perc <= (lower_lr_perc) and poc_2_perc > (bot_liq_perc)
         and poc_2_is_in_buy and not figura_val_to_bot_target and not figura_vah_to_bot_target and not figura_poc_to_bot_target and low_level == poc_second_level) or 
         (poc_2_perc <= fib_for_scenario and poc_2_perc <= (lower_lr_perc) and poc_2_perc > bot_liq_perc and poc_2_is_in_buy and poc_second_level > poc_level and poc_2_to_poc_vol_ratio > 50)) and 
         (na(break_start_perc) or (not na(break_start_perc) and poc_2_perc < (break_start_perc - (min_level[1] / 2))))

        figura_bot_liq                  = not figura_vah_to_bot_target and not figura_val_to_bot_target and not figura_poc_to_bot_target and not figura_poc_2_to_bot_target
 
        //
        if low_level <= lowerEndPrice_lr //Impostazione degli scenari quando i livelli di poc sono sotto la lr attuale
            if not up_breakout
                //Vah
                if market_buy_pattern  != "Vah Buy Fig" and figura_vah_to_bot_target 
                    market_buy_pattern  := "Vah Buy Fig"
                    start_perc          := vah_perc
                //
                if market_buy_pattern  == "Vah Buy Fig" and not figura_vah_to_bot_target
                    market_buy_pattern  := na 
                    start_perc          := na 
                //Poc 
                if market_buy_pattern  != "Poc Buy Fig" and figura_poc_to_bot_target
                    market_buy_pattern  := "Poc Buy Fig"
                    start_perc          := poc_perc 
                //
                if market_buy_pattern  == "Poc Buy Fig" and not figura_poc_to_bot_target
                    market_buy_pattern  := na 
                    start_perc          := na 
                //Poc 2
                if market_buy_pattern  != "Poc 2 Buy Fig" and figura_poc_2_to_bot_target
                    market_buy_pattern  := "Poc 2 Buy Fig"
                    start_perc          := poc_2_perc 
                //
                if market_buy_pattern  == "Poc 2 Buy Fig" and not figura_poc_2_to_bot_target
                    market_buy_pattern  := na 
                    start_perc          := na 
                //Val
                if market_buy_pattern  != "Val Buy Fig" and figura_val_to_bot_target 
                    market_buy_pattern  := "Val Buy Fig"
                    start_perc          := val_perc 
                //
                if market_buy_pattern  == "Val Buy Fig" and not figura_val_to_bot_target
                    market_buy_pattern  := na 
                    start_perc          := na 
                //Bot Liq
                if market_buy_pattern  != "Bot Liq Fig" and figura_bot_liq 
                    market_buy_pattern  := "Bot Liq Fig"
                //
                if market_buy_pattern  == "Bot Liq Fig" and not figura_bot_liq
                    market_buy_pattern  := na 
                //
            else 
                market_buy_pattern      := "Break-out Fig"
            //

            ///////////////
            //Impostazioni degli scenari di break - la attuale percentuale 15% dovrebbe diventare un dato modificato dal timeframe corrente, sarebbe opportuno inizializzarlo allo start del codice 
            if market_buy_pattern == "Break-out Fig"
                if poc_second_level > poc_level 
                    if poc_perc < fib_for_break and poc_is_in_buy
                        market_buy_pattern := "Poc Break"
                    if (vah_perc < fib_for_break) and vah_is_in_buy
                        market_buy_pattern := "Vah Break"
                    if (poc_2_to_poc_vol_ratio > 50 and poc_2_perc < fib_for_break) and poc_2_is_in_buy
                        market_buy_pattern := "Poc 2 Break"
                //
                if poc_second_level < poc_level 
                    if (poc_2_to_poc_vol_ratio > 50 and poc_2_perc < fib_for_break) and poc_2_is_in_buy
                        market_buy_pattern := "Poc 2 Break"
                    if poc_perc < fib_for_break and poc_is_in_buy
                        market_buy_pattern := "Poc Break"
                    if (vah_perc < fib_for_break) and vah_is_in_buy
                        market_buy_pattern := "Vah Break"
                //
                if ((market_buy_pattern == "Break-out Fig" and val_level > bot_liq) or (market_buy_pattern == "Poc 2 Break" and val_level > poc_second_level and val_perc < fib_perc_5)) and val_is_in_buy
                    market_buy_pattern  := "Val Break"
                //
                if market_buy_pattern == "Break-out Fig"
                    market_buy_pattern  := "No data after break" 
        //
        if low_level > lowerEndPrice_lr or (market == "Switch Up Trend" and not trend_up and pearson < 0.5) //Ricerca di scenari più bassi quando il poc è compreso nella lr
            market_buy_pattern              := "Pendant Study" 
            if low_level == val_level
                start_perc                  := val_perc
            if low_level == poc_second_level
                start_perc                  := poc_2_perc
            if market_buy_pattern == "Pendant Study" and val_perc > 70
                 and (na(break_start_perc) or (not na(break_start_perc)  and val_perc  < (break_start_perc - (min_level[1] / 2))))
                market_buy_pattern          := "Top Compression" , start_perc := val_perc
            if market_buy_pattern == "Pendant Study" and vah_perc < 30
                 and (na(break_start_perc) or (not na(break_start_perc) and vah_perc   < (break_start_perc - (min_level[1] / 2))))
                market_buy_pattern          := "Bot Compression" , start_perc := vah_perc
            if market_buy_pattern == "Pendant Study" and poc_is_in_buy
                 and (na(break_start_perc) or (not na(break_start_perc) and poc_perc   < (break_start_perc - (min_level[1] / 2)))) and poc_perc < 50
                market_buy_pattern          := "Poc" , start_perc := poc_perc
            if market_buy_pattern == "Pendant Study" and val_is_in_buy
                 and (na(break_start_perc) or (not na(break_start_perc) and val_perc   < (break_start_perc - (min_level[1] / 2))))
                market_buy_pattern          := "Val" , start_perc := val_perc
            if market_buy_pattern == "Pendant Study" and not val_is_in_buy and bot_liq_is_in_buy
                market_buy_pattern          := "Bot Liq" , start_perc := bot_liq_perc
        if  market == "Switch Up Trend" and not trend_up and pearson >= 0.85 //Scenario Max - l'idea è che lo sfondamento di una lr mobile indica un volume che ha nettamente rotto il trend. Sarebbe opportuno iterare la Siffredi solo quando real_pearson < -0.9/0.8 in questo modo mi assicuro che quel trend sta davvero cadendo
            market_buy_pattern              := "Siffredi" 
        if  market == "Switch Up Trend" and not trend_up and pearson < 0.85 and pearson >= 0.5
            market_buy_pattern              := "Siffredi look for break" 

// -------------------------------------}

//Gestione dei livelli di target
// -----------------------------------------------------------{

if open_position_mid == 0 
    save_start_perc := start_perc 
    if save_start_perc_bool
        save_start_perc_bool := false  
if open_position_mid > 0 and not save_start_perc_bool
    save_start_perc := math.round(((mid_ask - bot) / global_distance) * 100)
    save_start_perc_bool := true 
//
if save_start_perc_bool and bot != bot[1]
    save_start_perc := math.round(((mid_ask - bot) / global_distance) * 100)
//

mid_perc_min := save_start_perc + min_level
mid_perc_mid := mid_perc_min + mid_level


// Popolamento struttura vettoriale con parametrizzazione sequenziale
array.set(orig_perc_array, 0, bot_liq_perc)
array.set(orig_perc_array, 1, val_perc)
array.set(orig_perc_array, 2, poc_perc)
array.set(orig_perc_array, 3, vah_perc)
array.set(orig_perc_array, 4, top_liq_perc)
array.set(orig_perc_array, 5, poc_2_perc)

// Costanti critiche per thresholding

//Imposto le percentuali per il bot 
if na(first_bot_liq)
    bot_liq_perc_used := bot_liq_perc
else
    bot_liq_perc_used := math.round(((first_bot_liq - bot) / global_distance) * 100)
//

bot_perc_min = bot_liq_perc_used + min_level
bot_perc_mid = bot_perc_min + mid_level

actual_support_over_bot_perc_min = actual_support_over_bot_perc + min_level
actual_support_over_bot_perc_mid = actual_support_over_bot_perc_min + mid_level

// Funzione ottimizzata per calcolo target percentuali con parametrizzazione threshold
   
//


// Correzione vettoriale con epsilon-bound comparison per float

//
var int siffredi_ask_perc = na 
siffredi_ask_perc := not na(siffredi_ask) ? math.round(((siffredi_ask - bot) / global_distance) * 100) : 25 

siffredi_min = siffredi_ask_perc + min_level
siffredi_mid = siffredi_min + mid_level

//Target Siffredi
[lower_target_perc_tupla, higher_target_perc_tupla]                                     = M.calculate_target_percentages(orig_perc_array, siffredi_min, siffredi_mid)
siffredi_lower_target_tupla                        = M.get_level_from_perc(lower_target_perc_tupla, bot_liq_perc, bot_liq, val_perc, val_level, poc_perc, poc_level, vah_perc, vah_level, top_liq_perc, top_liq, poc_2_perc, poc_second_level, actual_support_over_bot_perc, actual_supporto)
siffredi_higher_target_tupla                       = M.get_level_from_perc(higher_target_perc_tupla, bot_liq_perc, bot_liq, val_perc, val_level, poc_perc, poc_level, vah_perc, vah_level, top_liq_perc, top_liq, poc_2_perc, poc_second_level, actual_support_over_bot_perc, actual_supporto)

// Target del livello bot liq posizione 1-2
[lower_target_perc_bot_tupla, higher_target_perc_bot_tupla]                             = M.calculate_target_percentages(orig_perc_array, bot_perc_min, bot_perc_mid)
lower_target_bot_tupla                    = M.get_level_from_perc(lower_target_perc_bot_tupla, bot_liq_perc, bot_liq, val_perc, val_level, poc_perc, poc_level, vah_perc, vah_level, top_liq_perc, top_liq, poc_2_perc, poc_second_level, actual_support_over_bot_perc, actual_supporto)
higher_target_bot_tupla                  = M.get_level_from_perc(higher_target_perc_bot_tupla, bot_liq_perc, bot_liq, val_perc, val_level, poc_perc, poc_level, vah_perc, vah_level, top_liq_perc, top_liq, poc_2_perc, poc_second_level, actual_support_over_bot_perc, actual_supporto)

// Target per posizione 11 actual over bot 
[lower_target_act_sup_over_bot_perc_tupla, higher_target_act_sup_over_bot_perc_tupla]   = M.calculate_target_percentages(orig_perc_array, actual_support_over_bot_perc_min, actual_support_over_bot_perc_mid)
lower_target_act_sup_over_bot_tupla       = M.get_level_from_perc(lower_target_act_sup_over_bot_perc_tupla, bot_liq_perc, bot_liq, val_perc, val_level, poc_perc, poc_level, vah_perc, vah_level, top_liq_perc, top_liq, poc_2_perc, poc_second_level, actual_support_over_bot_perc, actual_supporto)

//Target per posizioni MID 12
[mid_lower_target_perc_tupla, mid_higher_target_perc_tupla]                             = M.calculate_target_percentages(orig_perc_array, mid_perc_min, mid_perc_mid)
mid_lower_target_tupla                    = M.get_level_from_perc(mid_lower_target_perc_tupla, bot_liq_perc, bot_liq, val_perc, val_level, poc_perc, poc_level, vah_perc, vah_level, top_liq_perc, top_liq, poc_2_perc, poc_second_level, actual_support_over_bot_perc, actual_supporto)
mid_higher_target_tupla                   = M.get_level_from_perc(mid_higher_target_perc_tupla, bot_liq_perc, bot_liq, val_perc, val_level, poc_perc, poc_level, vah_perc, vah_level, top_liq_perc, top_liq, poc_2_perc, poc_second_level, actual_support_over_bot_perc, actual_supporto)

if barstate.isconfirmed and run > 0 
    lower_target_perc                   := lower_target_perc_tupla
    higher_target_perc                  := higher_target_perc_tupla
    siffredi_lower_target               := siffredi_lower_target_tupla
    siffredi_higher_target              := siffredi_higher_target_tupla
    lower_target_perc_bot               := lower_target_perc_bot_tupla
    higher_target_perc_bot              := higher_target_perc_bot_tupla
    lower_target_bot                    := lower_target_bot_tupla
    higher_target_bot                   := higher_target_bot_tupla
    lower_target_act_sup_over_bot_perc  := lower_target_act_sup_over_bot_perc_tupla
    higher_target_act_sup_over_bot_perc := higher_target_act_sup_over_bot_perc_tupla
    lower_target_act_sup_over_bot       := lower_target_act_sup_over_bot_tupla
    mid_lower_target_perc               := mid_lower_target_perc_tupla
    mid_higher_target_perc              := mid_higher_target_perc_tupla
    mid_lower_target                    := mid_lower_target_tupla
    mid_higher_target                   := mid_higher_target_tupla

// -------------------------------------}
// Iterazioni di run out candle e tabella finale 
// -----------------------------------------------------------{

//Contatore BBars aggiornato a fine iterazione per evitare bar + 1 nel contatore candele
if run > 0 and contatore < (bar_limit - original_bbars) and block_start_bar and ancoraggio_pivot
    contatore += 1 
//if run > 1 and contatore < (bar_limit - bbars) and block_start_bar and not ancoraggio_pivot and (bar_index[bbars] -1) == support_switch_bar //Sezione da verificare, non sono sicuro che ancori correttamente al pivot
//    contatore += 1
//
if block_start_bar and switch_supporto and not na(save_bot_liq)
    save_bot_liq := na
    save_top_liq := na
//
//
if run > 0 and (contatore + bbars) >= bar_limit and block_start_bar and na(save_bot_liq)
    save_bot_liq := bot_liq
    save_top_liq := top_liq
//

fib_distance = fib_vah_value - fib_val_value

if fib_distance > 3 and run > 0 and mid_level_vol < 4 and percent > 55
    percent -= 5
if fib_distance < 3 and run > 0 and mid_level_vol < 4 and percent < 80
    percent += 5
//

//
if run > 1 and not show_plot
    line.delete(baseLine_lr)
    line.delete(upper_lr)
    line.delete(lower_lr)
    for x = 0 to cnum - 1 by 1
        box.delete(array.get(vol_bars, x))
        box.delete(array.get(vol_bars, x + cnum))
//
tot_position := tot_position_cover + open_position_break + tot_position_scenario_bot + open_position_mid

if counting < 1
    counting += 1
//
if barstate.islastconfirmedhistory
    for i = 1 to bar_breakout
        if low < poc_level
            up_breakout                     := false 
            bot_in_up_break_out             := na
            distanza_break_out_up           := na
    for i = 1 to bar_breakout
        if high > poc_level
            down_breakout                   := false 
            top_in_down_break_out           := na
            distanza_break_out_down         := na

// -------------------------------------}

// Tabella
// -----------------------------------------------------------{

low_cover_level = tot_sup == 4 ? old_sup_3 : tot_sup == 3 ? old_sup_2 : tot_sup == 2 ? old_sup_1 : tot_sup == 1 ? old_sup : na 

// Calcola la differenza percentuale
diff_percentage = 100 - (((low_cover_level / close ) * 100))

// Tabella unificata ottimizzata
M.tabella(percent_change, real_pearson, volume_dispersion, market, market_buy_pattern, diff_percentage, bot, top, bot_is_sup, top_is_res, tot_sup, tot_res, titolo, spread, status, headerColor, positiveColor, negativeColor, show_plot, run)

//if run > 1 and bbars < bbars[1]
//    alert("Correct Reset",alert.freq_once_per_bar)
if run == 2 and bbars == bar_limit
    alert("Bar Limit Reach",alert.freq_once_per_bar)
    run += 1

// -------------------------------------}


