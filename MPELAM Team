//@version=5
indicator('Volume Logic Trading Assistant (Buy)', max_bars_back = 5000,max_boxes_count=200, overlay = false)
 
// MPELAM 2025 
//  ⚡ Volume Logic Trading Assistant ⚡

// Licenza: GNU General Public License v3+
// Redistribuzione: Consentita solo con attribuzione completa 

//  CONFIGURAZIONE SISTEMA:
// ⚠️ ATTENZIONE: BBars DEVE ESSERE NUMERO PARI 

// Var & Library 
// -----------------------------------------------------------{
import MPELAM/Logic_Trade_Bot_Library_BUY/2 as M2  
    // TIMEFRAME E ANALISI TEMPORALE
// ═══════════════════════════════════════════════════════════════════════════════════════{
var string current_timeframe = timeframe.period
var timeframe_level = M2.timeframe_level_function(current_timeframe)
var int lenght_ema = M2.length_ema_function(timeframe_level)
// ═══════════════════════════════════════════════════════════════════════════════════════}
    // SETTING GENERALE E VAR DI INIZIALIZZAZIONE
// ═══════════════════════════════════════════════════════════════════════════════════════{
var percent = input.float(title='% pesata di volume', defval=60, minval=1, maxval = 100) // Percentuale peso volume VAH/VAL
var float percent_block = percent
bbars = input.int(title='Number of Bars - inserire un numero pari', defval=360, minval=1) // Numero barre per analisi
var int original_bbars = bbars   // Backup valore originale bbars
var int bbars_2 = bbars / 2      // Metà delle barre per pivot per iterazioni intermedie
var int bbars_4 = bbars / 4      // 1/4 delle barre per pivot per iterazioni brevi breakout
var int bar_limit = 1440         // Limite massimo barre computazione
var bool ancoraggio_pivot = true // Ancoraggio bbars al pivot
var bool block_start_bar = false // Flag blocco avvio analisi
var int run = 0                  // Contatore stati di inizializzazione
var int contatore = 0            // Contatore barre aggiuntive per ancorare il grafico al pivot
var int cnum = 100               // Numero canali volume profilo
var int original_bbars_old = original_bbars - 1 // Backup bbars precedente
var float incremento_resistenze_pivot = 1.1     // Moltiplicatore distanza resistenze
var float min_0_3 = timeframe_level <= 1 ? close / 100 * 0.33 : timeframe_level <= 3 ? close /100 : close / 100 * 2 // Distanza minima posizioni cover
var int counting = 0 // Iterazione di inizializzazione
var int first_distance_va = 0    // Distanza di Fibonacci tra le fasce VA
var string regime = na           // Indica il regime di mercato CMF
var int score = na               // Punteggio del regime
// ═══════════════════════════════════════════════════════════════════════════════════════}
    // BLOCCO FIB
// ═══════════════════════════════════════════════════════════════════════════════════════{
var float fib_for_break = na        // Fibonacci per breakout
var float fib_for_scenario = na     // Fibonacci per scenari
var float fib_for_scenario_low = na // Fibonacci per scenari
var float fib_val_value = na        // Valore Fibonacci VAL
var float fib_vah_value = na        // Valore Fibonacci VAH
var float fib_perc_0 = 0            // Livello Fibonacci 0%
var float fib_perc_1 = 23.6         // Livello Fibonacci 23.6%
var float fib_perc_2 = 38.2         // Livello Fibonacci 38.2%
var float fib_perc_3 = 50           // Livello Fibonacci 50%
var float fib_perc_4 = 61.8         // Livello Fibonacci 61.8%
var float fib_perc_5 = 76.4         // Livello Fibonacci 78.6%
var float fib_perc_6 = 100          // Livello Fibonacci 100%
// ═══════════════════════════════════════════════════════════════════════════════════════}
    // CONTROLLI E BLOCCHI PER ANCORAGGIO
// ═══════════════════════════════════════════════════════════════════════════════════════{
var bool bot_block = false      // Blocco logica bottom
var bool top_block = false      // Blocco logica top
var bool bot_block_fast = false // Blocco fast bottom
var bool top_block_fast = false // Blocco fast top
var bool bar_reach = false      // Flag raggiungimento bar_limit
// ═══════════════════════════════════════════════════════════════════════════════════════}
    // LIQUIDITÀ E PIVOT
// ═══════════════════════════════════════════════════════════════════════════════════════{
var float bot_liq = na            // Liquidità base ancorata pivot bottom
var float top_liq = na            // Liquidità base ancorata pivot top
var float save_bot_liq = na       // Backup liquidità bottom per bar_limit
var float save_top_liq = na       // Backup liquidità top per bar_limit
bool bot_liq_modified = false // Flag modifica liquidità bottom
bool top_liq_modified = false // Flag modifica liquidità top
var float top_liq_shadow = na     // Salvo liquidità shadow per ottimizzare in base al volume
var float bot_liq_shadow = na     // Salvo liquidità shadow per ottimizzare in base al volume 
// ═══════════════════════════════════════════════════════════════════════════════════════}
    // SUPPORTI E RESISTENZE
// ═══════════════════════════════════════════════════════════════════════════════════════{
var a_sup = array.new_float(0)       // Array pivot non vergini
var a_res = array.new_float(0)       // Array pivot non vergini
var float actual_supporto = na       // Supporto attuale dinamico
var float actual_resistenza = na     // Resistenza attuale dinamica
var int support_switch_bar = na      // Barra switch supporto
var int res_switch_bar = na          // Barra switch resistenza
var float actual_old_supporto = na   // Supporto vecchio per confronto
var float actual_old_resistenza = na // Resistenza vecchia per confronto
var int support_switch_bar_old = na  // Barra switch supporto vecchio
var int res_switch_bar_old = na      // Barra switch resistenza vecchia
var bool bot_is_sup = false          // Flag bot corrisponde a supporto
var bool top_is_res = false          // Flag top corrisponde a resistenza
var int lenght_pivot_order_block = timeframe_level > 0 ? 1 : 2
// ═══════════════════════════════════════════════════════════════════════════════════════}
    // LIVELLI TOP/BOT E BREAKOUT
// ═══════════════════════════════════════════════════════════════════════════════════════{
var float bot = na                     // Livello bottom del range
var float top = na                     // Livello top del range
var bool up_breakout = false           // Flag breakout rialzista
var bool down_breakout = false         // Flag breakout ribassista
var float distanza_break_out_up = na   // Distanza breakout rialzista
var float distanza_break_out_down = na // Distanza breakout ribassista
var float bot_in_up_break_out = na     // Bot al momento breakout up
var float top_in_down_break_out = na   // Top al momento breakout down
// ═══════════════════════════════════════════════════════════════════════════════════════}
    // DISTANZE E MEDIE VOLUME
// ═══════════════════════════════════════════════════════════════════════════════════════{
var float piv_distance = input.float(title='Distanza di prezzo per posizioni cover', defval=50, minval=1) // Distanza base pivot
var float media_mom = na            // Media momentum range
var float piv_distance_res = na     // Distanza scalare livello 1
var float piv_distance_1 = na       // Distanza scalare livello 1
var float piv_distance_2 = na       // Distanza scalare livello 2
var float piv_distance_3 = na       // Distanza scalare livello 3
var float piv_distance_1_res = na   // Distanza resistenze livello 1
var float piv_distance_2_res = na   // Distanza resistenze livello 2
var float piv_distance_3_res = na   // Distanza resistenze livello 3
var float bot_mom = na              // Bottom momentum temporaneo
var float top_mom = na              // Top momentum temporaneo
var int contatore_try = na          // Contatore tentativi pivot
var int contatore_media = 0         // Contatore per calcolo media
var float media = 0                 // Accumulo per media range
var float media_vol = na            // Media volume finale
// ═══════════════════════════════════════════════════════════════════════════════════════}
    // VOLUME PROFILE E POC RATIO
// ═══════════════════════════════════════════════════════════════════════════════════════{
float[] totalvols = array.new_float(cnum, 0.) // Array volumi totali
var float vol_value = na                      // Valore volume corrente
var float poc_level = na                      // Livello Point of Control
var float vah_level = na                      // Livello Value Area High
var float val_level = na                      // Livello Value Area Low
var float poc_bot_level = na                  // POC bottom level
var float poc_top_level = na                  // POC top level
var float poc_second_level = na               // Secondo POC più significativo
var bool poc_is_buy = false                   // Flag POC rialzista/ribassista
var bool poc_2_is_buy = false                 // Flag POC rialzista/ribassista
var float central_volume_perc = na            // Percentuale volume centrale
var float vah_to_poc_vol_ratio = na           // Ratio volume VAH/POC
var float poc_2_to_poc_vol_ratio = na         // Ratio volume POC2/POC
var float val_to_poc_vol_ratio = na           // Ratio volume VAL/POC
// ═══════════════════════════════════════════════════════════════════════════════════════}
    // LINEAR REGRESSION E TREND
// ═══════════════════════════════════════════════════════════════════════════════════════{
var float lr_vol_perc = na                  // Percentuale volume linear regression
var float upperMultInput_lr = 2             // Moltiplicatore deviazione superiore
var useUpperDevInput_lr = true                  
var useLowerDevInput_lr = true                  
var float lowerMultInput_lr = 2             // Moltiplicatore deviazione inferiore
var bool showPearsonInput_lr = true         // Flag visualizzazione Pearson
var bool extendLeftInput_lr = false         // Flag estensione sinistra LR
var bool extendRightInput_lr = false        // Flag estensione destra LR
var line upper_lr = na                      // Linea deviazione superiore LR
var line lower_lr = na                      // Linea deviazione inferiore LR
var line upper_lr_dev = na                  // Linea deviazione superiore LR
var line lower_lr_dev = na                  // Linea deviazione inferiore LR
var line baseLine_lr = na                   // Linea base LR
var float prev_pearsonR = na                // Pearson precedente
var float prev_percent_change = na          // Cambio percentuale precedente
var float perc_pearson = na                 // Percentuale Pearson
var bool trend_up = false                   // Flag trend rialzista
var float perc_trend = na                   // Percentuale trend
var float upperStartPrice_lr = na 
var float upperEndPrice_lr = na 
var float lowerStartPrice_lr = na 
var float lowerEndPrice_lr = na 
var float upperStartPrice_lr_dev = na 
var float upperEndPrice_lr_dev = na 
var float lowerStartPrice_lr_dev = na 
var float lowerEndPrice_lr_dev = na 
var float pearson = na 
var int bar_breakout = 0                    // Variabile per l'interpolazione dei dati sulla regressiva
var int bar_breakout_down = 0               // Variabile per l'interpolazione dei dati sulla regressiva
var int low_perc_fib = 0                    // Variabile per l'interpolazione dei dati sulla regressiva
// ═══════════════════════════════════════════════════════════════════════════════════════}
    // EMA E VALIDAZIONE LIVELLI
// ═══════════════════════════════════════════════════════════════════════════════════════{
var float ema_switch_perc = na              // Percentuale switch EMA
var bool val_is_in_buy = false              // Flag VAL validato per buy
var bool vah_is_in_buy = false              // Flag VAH validato per buy
var bool poc_is_in_buy = false              // Flag POC validato per buy
var bool poc_2_is_in_buy = false            // Flag POC2 validato per buy
var bool bot_liq_is_in_buy = false          // Flag liquidità bottom per buy
var bool act_sup_is_in_buy = false          // Flag supporto attuale per buy
var float ema_value_before_start = na       // Valore EMA prima dello start
var int contatore_ema_switch_down = na      // Contatore switch EMA down
var float last_ema_switch_down = na         // Ultimo switch EMA down
var float prezzo_interpolato_lr_start = na  // Prezzo interpolato LR start
var bool ema_over_lr = false
var bool ema_switch_down = false 
var bool ema_switch_up = false 
// ═══════════════════════════════════════════════════════════════════════════════════════}
    // TARGET E LIVELLI DINAMICI
// ═══════════════════════════════════════════════════════════════════════════════════════{
var float siffredi_lower_target = na            
var float siffredi_higher_target = na          
var float lower_target_bot = na                 
var float higher_target_bot = na                
var float actual_support_lower = na            
var float higher_target_act_sup_over_bot = na   
var int save_start_perc = na                    
var bool save_start_perc_bool = false
var float mid_ask = na  
var int mid_perc_min = 0 
var int mid_perc_mid = 0     
var float mid_lower_target = na          
var float mid_higher_target = na                
var float cover_1_lower_target = na 
var float cover_1_higher_target = na 
var float cover_2_lower_target = na 
var float cover_2_higher_target = na 
var float cover_3_lower_target = na 
var float cover_3_higher_target = na 
var float cover_4_lower_target = na 
var float cover_4_higher_target = na 
var float break_lower_target  = na
var float break_higher_target = na
// ═══════════════════════════════════════════════════════════════════════════════════════}
    // VALORI PERCENTUALI DEI LIVELLI D'INTERESSE E DEI TARGET DELLE POSIZIONI
// ═════════════════════════════════════════════════════════════════════════════════════{
var float lower_lr_perc = na 
var float lr_perc = na 
var float upper_lr_perc = na 
var float break_lower_target_perc = na
var float break_higher_target_perc = na
var int actual_support_over_bot_perc = 0
var float siffredi_lower_target_perc = na 
var float siffredi_higher_target_perc = na 
var float lower_target_bot_perc = na 
var float higher_target_bot_perc = na 
var float actual_support_lower_perc = na 
var float higher_target_act_sup_over_bot_perc = na 
var float mid_lower_target_perc = na 
var float mid_higher_target_perc = na 
var float cover_1_higher_target_perc = na 
var float cover_1_lower_target_perc  = na 
var float cover_2_higher_target_perc = na 
var float cover_2_lower_target_perc  = na 
var float cover_3_higher_target_perc = na 
var float cover_3_lower_target_perc  = na 
var float cover_4_higher_target_perc = na 
var float cover_4_lower_target_perc  = na 
var float break_ask_perc = na 
var float siffredi_ask_perc = na 
var int mid_ask_perc = na 
var int vah_perc = na     
var int poc_perc = na     
var int poc_2_perc = na   
var int val_perc = na     
var int bot_liq_perc = na 
var int top_liq_perc = na 
var int low_perc = na     
var int high_perc = na  
var float vol_distance_perc = na                    // Percentuale distanza volume
var float val_to_bot_volume_perc = na               // Percentuale volume VAL-BOT
var float vah_to_top_volume_perc = na               // Percentuale volume VAH-TOP
var int start_perc = na                             // Percentuale di partenza
var float break_start_perc = na                     // Percentuale inizio break
// ═══════════════════════════════════════════════════════════════════════════════════════}
    // BREAKOUT E MOMENTUM
// ═══════════════════════════════════════════════════════════════════════════════════════{
var float break_out_up_perc_mom = na                // Percentuale breakout up momentum
var float break_out_down_perc_mom = na              // Percentuale breakout down momentum
var float distanza_break_out_up_post = na           // Distanza post breakout up
var float break_out_up_perc = na                    // Percentuale breakout up
var float break_out_up_top_perc = na                // Percentuale top breakout up
var float break_out_down_perc = na                  // Percentuale breakout down
var float distanza_break_out_post_mom_up = na       // Distanza post momentum up
var float distanza_break_out_down_post = na         // Distanza post breakout down
var float break_out_down_top_perc = na              // Percentuale top breakout down
var int breakout_bar_index_down = 0                 // Indice barra breakout down
var float distanza_break_out_post_mom_down= na      // Distanza post momentum down
var int target_buy_perc = na                        //Perc per target simulato
// ═══════════════════════════════════════════════════════════════════════════════════════}
    // ARRAY PIVOT E VOLUME E TARGET
// ═══════════════════════════════════════════════════════════════════════════════════════{
var float[] high_pivots = array.new_float(0)        // Array pivot high
var float[] low_pivots = array.new_float(0)         // Array pivot low
var int[] high_bar_indices = array.new_int(0)       // Indici barre pivot high
var int[] low_bar_indices = array.new_int(0)        // Indici barre pivot low
var vol_bars = array.new_box(cnum * 2, na)          // Array boxes volume profile
var array<float> sma_volumes = array.new_float(cnum, 0.)
var array<line> peak_lines = array.new_line(0)
var array<float> peak_level_ar = array.new_float(0)
var array<float> peak_sma_level = array.new_float(0)
var array<int> peak_level_perc = array.new_int(0)
var array<int> peak_level_perc_sma = array.new_int(0)
var orig_perc_array = array.new_float(100)          // Array percentuali originali livelli d'interesse
// ═══════════════════════════════════════════════════════════════════════════════════════}
    // LABEL E TRACKING EVENTI
// ═══════════════════════════════════════════════════════════════════════════════════════{
var label[] saved_labels = array.new_label()        // Array label salvate
var label vol_break_up_perc_mom_label = na          // Label breakout up momentum
var label vol_break_down_perc_mom_label = na        // Label breakout down momentum
// ═══════════════════════════════════════════════════════════════════════════════════════}
    // COLORI E VISUALIZZAZIONE
// ═══════════════════════════════════════════════════════════════════════════════════════{
var color headerColor = color.new(color.gray, 20)     // Colore header tabelle
var color positiveColor = color.new(color.green, 60)  // Colore valori positivi
var color negativeColor = color.new(color.red, 60)    //Colore valori negativi
var color vah_color = na                              //Colore dinamico VAH
var color val_color = na                              // Colore dinamico VAL
var color poc_color = na                              // Colore dinamico POC
var color poc_2_color = na                            // Colore dinamico POC2
var int poc_width = 2                                 // Spessore linea POC
var int vah_width = 1                                 // Spessore linea VAH
var int val_width = 1                                 // Spessore linea VAL
var int ext_width = 1                                 // Spessore linee estreme
var group3_lr = "Color Settings"
var colorUpper_lr = input.color(color.new(color.green, 95), "Upper Color", group=group3_lr)
var colorLower_lr = input.color(color.new(color.red, 95), "Lower Color", group=group3_lr)
var colorUpper_lr_dev = input.color(color.new(color.green, 93), "Upper Deviation Color", group=group3_lr)
var colorLower_lr_dev = input.color(color.new(color.red, 93), "Lower Deviation Color", group=group3_lr) 
// ═══════════════════════════════════════════════════════════════════════════════════════}
    // GESTIONE POSIZIONI E CONTATORI
// ═══════════════════════════════════════════════════════════════════════════════════════{
var int tot_position = 0                            // Totale posizioni aperte
var int tot_position_cover = 0                      // Totale posizioni cover
var float break_ask = na                            // Prezzo ask per breakout
var float siffredi_ask = na                         // Prezzo ask per breakout basso
var int open_position_mid = 0                       // Posizioni intermedie aperte
var int open_position_break = 0                     // Posizioni breakout aperte
var int posizione_attive_no_cover = 0               // Posizioni attive senza cover
// ═══════════════════════════════════════════════════════════════════════════════════════}
    // SCENARI BOT E LIQUIDITÀ
// ═══════════════════════════════════════════════════════════════════════════════════════{
var float first_bot_liq = na                        // Prima liquidità bottom salvata
var float first_bot = na                            // Primo bottom salvato
var bool scenario_bot_line = false                  // Flag scenario bottom attivo
var bool scenario_bot_2_line = false                // Flag secondo scenario bottom
var int scenario_bot_line_to_h = 0                  // Scenario bot verso high
var int scenario_bot_line_to_l = 0                  // Scenario bot verso low
var float scenario_bot_ask_to_h = 0                 // Ask scenario bot high
var float scenario_bot_ask_to_l = 0                 // Ask scenario bot low
var int scenario_siffredi_cover_line = 0 
var float scenario_siffredi_cover_ask = 0 
// ═══════════════════════════════════════════════════════════════════════════════════════}
    // SUPPORTI COVER SCALARI
// ═══════════════════════════════════════════════════════════════════════════════════════{
var float supporto_1 = na                           // Supporto cover livello 1
var float supporto_2 = na                           // Supporto cover livello 2
var float supporto_3 = na                           // Supporto cover livello 3
var float supporto_4 = na                           // Supporto cover livello 4
// ═══════════════════════════════════════════════════════════════════════════════════════}
    // SCENARI COVER E TRIGGER
// ═══════════════════════════════════════════════════════════════════════════════════════{
var string cover_in_candle = na 
var bool cover_1_line = false                       // Flag cover livello 1 attivo
var bool cover_2_line = false                       // Flag cover livello 2 attivo
var bool cover_3_line = false                       // Flag cover livello 3 attivo
var bool cover_4_line = false                       // Flag cover livello 4 attivo
var bool supporto_cover_trig_1 = false              // Trigger supporto cover 1
var bool supporto_cover_trig_2 = false              // Trigger supporto cover 2
var bool supporto_cover_trig_3 = false              // Trigger supporto cover 3
var bool supporto_cover_trig_4 = false              // Trigger supporto cover 4
// ═══════════════════════════════════════════════════════════════════════════════════════}
    // SCENARI COVER - PARAMETRI OPERATIVI
// ═══════════════════════════════════════════════════════════════════════════════════════{
var bool siffredi_cover_line = false 
var int scenario_cover_1_line_to_h = 0              // Cover 1 verso high
var int scenario_cover_1_line_to_l = 0              // Cover 1 verso low
var float scenario_cover_1_ask_to_h = 0             // Ask cover 1 high
var float scenario_cover_1_ask_to_l = 0             // Ask cover 1 low
var int scenario_cover_2_line_to_h = 0              // Cover 2 verso high
var int scenario_cover_2_line_to_l = 0              // Cover 2 verso low
var float scenario_cover_2_ask_to_h = 0             // Ask cover 2 high
var float scenario_cover_2_ask_to_l = 0             // Ask cover 2 low
var int scenario_cover_3_line_to_h = 0              // Cover 3 verso high
var int scenario_cover_3_line_to_l = 0              // Cover 3 verso low
var float scenario_cover_3_ask_to_h = 0             // Ask cover 3 high
var float scenario_cover_3_ask_to_l = 0             // Ask cover 3 low
var int scenario_cover_4_line_to_h = 0              // Cover 4 verso high
var int scenario_cover_4_line_to_l = 0              // Cover 4 verso low
var float scenario_cover_4_ask_to_h = 0             // Ask cover 4 high
var float scenario_cover_4_ask_to_l = 0             // Ask cover 4 low
// ═══════════════════════════════════════════════════════════════════════════════════════}
    // SCENARI POSIZIONI INTERMEDIE
// ═══════════════════════════════════════════════════════════════════════════════════════{
var int scenario_val_to_bot_target_line  = 0        // Scenario VAL verso bot target
var float scenario_val_to_bot_target_ask = 0        // Ask VAL verso bot target
var int scenario_poc_to_bot_target_line  = 0        // Scenario POC verso bot target
var float scenario_poc_to_bot_target_ask = 0        // Ask POC verso bot target
var int scenario_poc_2_to_bot_target_line = 0       // Scenario POC2 verso bot target
var float scenario_poc_2_to_bot_target_ask = 0      // Ask POC2 verso bot target
var int scenario_vah_to_bot_target_line  = 0        // Scenario VAH verso bot target
var float scenario_vah_to_bot_target_ask = 0        // Ask VAH verso bot target
var int scenario_val_to_higher_line = 0             // Scenario VAL verso higher
var float scenario_val_to_higher_ask = 0            // Ask VAL verso higher
// ═══════════════════════════════════════════════════════════════════════════════════════}
    // SCENARI SPECIALI E BREAKOUT
// ═══════════════════════════════════════════════════════════════════════════════════════{
var int scenario_actual_over_bot_line = 0           // Scenario supporto sopra bot
var float scenario_actual_over_bot_ask = 0          // Ask supporto sopra bot
var int scenario_break_out_line = 0                 // Scenario breakout attivo
var float scenario_break_out_ask = 0                // Ask breakout
var string scenario_bot_1_string_start = na
var float simulato_higher_target_tupla = na
var line scenario_actual_bot_line = na              //Plottaggio scenario actual supporto, variabile necessaria a scopo grafico
var bool break_with_res = false
// ═══════════════════════════════════════════════════════════════════════════════════════}
    // ANALISI MERCATO E PATTERN
// ═══════════════════════════════════════════════════════════════════════════════════════{
var string market = na
var bool active_mid_trade = false
var string market_buy_pattern = na
var float low_level = na
// ═══════════════════════════════════════════════════════════════════════════════════════}
    // CONTATORI POSIZIONI PER TIPOLOGIA
// ═══════════════════════════════════════════════════════════════════════════════════════{
var int tot_position_scenario_bot = 0
var bool close_alarm_mid = false
var int tot_position_scenario_cover_1 = 0
var int tot_position_scenario_cover_2 = 0
var int tot_position_scenario_cover_3 = 0
var int tot_position_scenario_cover_4 = 0
// ═══════════════════════════════════════════════════════════════════════════════════════}
    // GESTIONE SCENARI SPECIALI
// ═══════════════════════════════════════════════════════════════════════════════════════{
var int last_cover = 0
var bool siffredi_fatta = false
var string block_cover_open = na
var bool close_mid_fast = false 
var bool close_break_fast = false 
// ═══════════════════════════════════════════════════════════════════════════════════════}
    // GESTIONE TITOLI E TIMEFRAME
// ═══════════════════════════════════════════════════════════════════════════════════════{
var float moltiplicatore_break = timeframe_level == 1 ? 1 : timeframe_level == 2 ? 2 : timeframe_level > 2 ? 3 : 1
var float moltiplicatore_mid = timeframe_level == 1 ? 3 : timeframe_level == 2 ? 3 : timeframe_level > 2 ? 4 : 2
var float moltiplicatore_bot = timeframe_level == 1 ? 2 : timeframe_level == 2 ? 3 : timeframe_level > 2 ? 4 : 2
var float moltiplicatore_cover = timeframe_level == 1 ? 2 : timeframe_level == 2 ? 3 : timeframe_level > 2 ? 4 : 2
var float n_titoli_moltiplicatore_break = na
var float n_titoli_moltiplicatore_mid = na
var float n_titoli_moltiplicatore_bot = na
var float n_titoli_moltiplicatore_cover = na
int current_bar = bar_index
var int cover_setting = timeframe_level < 1 ? 3 : timeframe_level < 3 ? 2 : 1
var float actual_supporto_old_3 = na
var float actual_supporto_old_2 = na
var float actual_supporto_old_1 = na
// ═══════════════════════════════════════════════════════════════════════════════════════}
// ----------------------------------------}
// Starter Pack
// -----------------------------------------------------------{
    // Analisi sentiment
// -----------------------------------------------------------{
[spread, n_titoli, titolo] = M2.title_spread_n_titoli_function(counting)
// Gestione cash
if not na(titolo) and na(n_titoli_moltiplicatore_break)
    n_titoli_moltiplicatore_break := n_titoli * moltiplicatore_break
    n_titoli_moltiplicatore_mid   := n_titoli * moltiplicatore_mid  
    n_titoli_moltiplicatore_bot   := n_titoli * moltiplicatore_bot  
    n_titoli_moltiplicatore_cover := n_titoli * moltiplicatore_cover
//
vix = request.security("CAPITALCOM:VIX", current_timeframe, close)
sdex = request.security("SDEX", current_timeframe, close)
// Usa la funzione per ottenere entrambi gli stati
[status_vix, status_sdex] = M2.getStatus(vix, sdex)
// Assegnazione valori in base allo status_vix
var int sentiment_level = 0
[sentiment_level_, incremento_distanza_pivot] = M2.valori_status(status_vix, status_sdex, score, timeframe_level)
sentiment_level := sentiment_level_
// Colore basato sullo stato
col = status_vix == "PANICO" or status_vix == "CRITICO" ? color.red : status_vix == "ALTO" or status_vix == "ELEVATO" ? color.orange : status_vix == "NORMALE" or status_vix == "BASSO" ? color.yellow : color.green
// ----------------------------------------}
    // Strutture pivot
// -----------------------------------------------------------{
//Vengono confrontati diversi livelli di pivot, il pivot old e quello normale servono per i margini di gioco, quelli fast per il sistema ad inefficienza rapida come supporto cover
//Gestione supporti e resistenze 
supporto                                 = bar_index > 1 ? ta.pivotlow  (low,  bbars_2, bbars_2)   : na 
resistenza                               = bar_index > 1 ? ta.pivothigh (high, bbars_2, bbars_2)   : na 
switch_supporto                          = not na(supporto)
switch_resistenza                        = not na(resistenza)
if switch_supporto    
    actual_supporto_old_3 := actual_supporto_old_2
    actual_supporto_old_2 := actual_supporto_old_1
    actual_supporto_old_1 := actual_supporto
    actual_supporto := supporto  
    support_switch_bar := bar_index - bbars_2 - 1 // Indica il punto in cui il low corrisponde all'actual supporto 
    if cover_setting == 2
        array.push(a_sup, supporto)
    if cover_setting == 1
        array.push(a_res, supporto)
if switch_resistenza  
    actual_resistenza := resistenza  
    res_switch_bar := bar_index - bbars_2 - 1 // Indica il punto in cui il low corrisponde all'actual supporto 
    if cover_setting == 2
        array.push(a_sup, resistenza)
    if cover_setting == 1
        array.push(a_res, resistenza)
//Pivot per inizializzazione breakout
var float actual_supporto_break = na
var float actual_resistenza_break = na
supporto_break                           = run == 0 and bar_index > 1 ? ta.pivotlow  (low,  bbars_4, bbars_4)   : na 
resistenza_break                         = run == 0 and bar_index > 1 ? ta.pivothigh (high, bbars_4, bbars_4)   : na 
switch_supporto_break = run == 0 and not na(supporto_break)
switch_resistenza_break = run == 0 and not na(resistenza_break)

actual_supporto_break := switch_supporto_break ? supporto_break : actual_supporto_break
actual_resistenza_break := switch_resistenza_break ? resistenza_break : actual_resistenza_break
//
supporto_fast = bar_index > 1000 ? ta.pivotlow  (low,  13, 13)   : na 
resistenza_fast = bar_index > 1000 ? ta.pivothigh (high, 13, 13)   : na 
switch_supporto_fast = not na(supporto_fast)
switch_resistenza_fast = not na(resistenza_fast)
if switch_supporto_fast    
    if cover_setting == 1
        array.push(a_sup, supporto_fast)
    if cover_setting >= 1 or cover_setting == 2 or cover_setting == 3
        array.push(a_res, supporto_fast)
if switch_resistenza_fast  
    if cover_setting == 1
        array.push(a_sup, resistenza_fast)
    if cover_setting >= 1 or cover_setting == 2 or cover_setting == 3
        array.push(a_res, resistenza_fast)
//Gestione supporti e resistenze 
supporto_old                             = bar_index > 100 ? ta.pivotlow  (low,  original_bbars_old, original_bbars_old)   : na 
resistenza_old                           = bar_index > 100 ? ta.pivothigh (high, original_bbars_old, original_bbars_old)   : na 
switch_supporto_old = not na(supporto_old)
switch_resistenza_old = not na(resistenza_old)
if switch_supporto_old    
    actual_old_supporto := supporto_old 
    support_switch_bar_old := bar_index - original_bbars_old - 1 // Indica il punto in cui il low corrisponde all'actual supporto 
    if cover_setting == 3
        array.push(a_sup, supporto_old)
//
if switch_resistenza_old  
    actual_old_resistenza := resistenza_old 
    res_switch_bar_old := bar_index - original_bbars_old - 1 // Indica il punto in cui il low corrisponde all'actual supporto 
    if cover_setting == 3
        array.push(a_sup, resistenza_old)
// Elimino i pivot non vergini dall'array, iterando sia supporti che resistenze nello stesso array vengono prese le inefficienze di apertura di mercato come posizione cover.
int size = array.size(a_sup)
for i = 0 to size - 1
    int j = size - 1 - i
    if j >= 0 and j < array.size(a_sup) // Controllo di sicurezza
        level = array.get(a_sup, j)
        if high >= level and low <= level
            array.remove(a_sup, j)
int size_2 = array.size(a_res)
for i = 0 to size_2 - 1
    int j_2 = size_2 - 1 - i
    if j_2 >= 0 and j_2 < array.size(a_res) // Controllo di sicurezza
        level_2 = array.get(a_res, j_2)
        if high >= level_2 and low <= level_2
            array.remove(a_res, j_2)
//Utilizzo bot max quando le bbars non sono bloccate, questo evita problemi di iterazione di ta.
bot_max = ta.lowest(low, original_bbars)
top_max = ta.highest(high, original_bbars)
if run == 0 and not na(bot_max)
    contatore_media += 1 
    media := timeframe_level > 0 ? media + ((top_max - bot_max) / 2) : media + ((top_max - bot_max))
// ----------------------------------------}
    // Gestione ancoraggio pivot
// -----------------------------------------------------------{
//Setting inizializzato per posizioni cover
if barstate.islastconfirmedhistory
    media_mom := media / contatore_media
    media_vol := math.max(media_mom, min_0_3)
    piv_distance := media_vol
    piv_distance_res := media_vol
    piv_distance_1 := piv_distance   * incremento_distanza_pivot
    piv_distance_2 := piv_distance_1 * incremento_distanza_pivot
    piv_distance_3 := piv_distance_2 * incremento_distanza_pivot
    piv_distance_1_res := piv_distance_res   * incremento_resistenze_pivot
    piv_distance_2_res := piv_distance_1_res * incremento_resistenze_pivot
    piv_distance_3_res := piv_distance_2_res * incremento_resistenze_pivot

[_contatore, _block_start_bar, _bot_block_fast, _top_block_fast, _bot_block, _top_block] = M2.checkPivotSwitch(contatore, tot_position, run, bar_reach, block_start_bar, ancoraggio_pivot, 
                       support_switch_bar, res_switch_bar, support_switch_bar_old, 
                       res_switch_bar_old, original_bbars, bar_limit, actual_supporto, 
                       bot, bbars, media_vol, bot_block, top_block, 
                       bot_block_fast, top_block_fast)
//
contatore := _contatore
block_start_bar := _block_start_bar
bot_block_fast := _bot_block_fast
top_block_fast := _top_block_fast
bot_block := _bot_block
top_block := _top_block

if block_start_bar
    bbars := bbars + contatore
    if run == 0 or (bbars < bbars[1]) //Calcolo manualmente top e bot durante lo switch, la funzione ta.pivot continua a creare problemi utilizzando una lenght dinamica
        top := 0
        bot := 9999999 
        for i = 1 to bbars 
            top := high[i] > top ? high[i] : top
            bot := low[i] < bot ? low[i] : bot
        if (bbars < bbars[1])
            save_bot_liq := na, save_top_liq := na 
//
bar_reach := bbars == bar_limit // Limite di barre raggiunto
if bar_reach //Azzero le bool di ricerca prima dello switch
    bot_block := false, top_block := false
    bot_block_fast := false, top_block_fast := false
//
if run == 0 and not block_start_bar
    bot := bot_max, top := top_max
if (not block_start_bar)
    bot := bot_max, top := top_max
// iterazione anticipata per breakout in modo da abbreviare il numero di calcoli
if run > 0 
    if high > top
        top := high
        if not up_breakout
            up_breakout := true 
            bot_in_up_break_out := bot
            distanza_break_out_up := top[1] - bot_in_up_break_out
    if low < bot 
        bot := low 
        if not down_breakout
            down_breakout := true 
            top_in_down_break_out := top
            distanza_break_out_down := top_in_down_break_out - bot[1]
//
// ----------------------------------------}
    //Gestione corrispondenze pivot - bot/top e salvataggio percentuali iniziali di prezzo
// -----------------------------------------------------------{
bot_is_sup := (bot == actual_supporto or bot == actual_old_supporto or bot == actual_supporto_old_1 or bot == actual_supporto_old_2 or bot == actual_supporto_old_3) ? true : false 
top_is_res := (top == actual_resistenza or top == actual_old_resistenza) ? true : false 
bot_is_sup_started = bot_is_sup and not bot_is_sup[1]
top_is_res_started = top_is_res and not top_is_res[1]
bot_is_sup_over = not bot_is_sup and bot_is_sup[1]
top_is_res_over = not top_is_res and top_is_res[1]
//
actual_support_over_bot_perc := bot_is_sup and actual_supporto > bot ? math.round(((actual_supporto - bot) / (top - bot)) * 100) : actual_support_over_bot_perc
actual_support_over_bot_perc := not bot_is_sup ? 0 : actual_support_over_bot_perc
global_distance = top - bot
low_perc := math.floor(((low - bot) / global_distance) * 100)
low_perc_fib := low_perc <= fib_perc_1 ? 1 : low_perc <= fib_perc_2 ? 2 : low_perc <= fib_perc_3 ? 3 : low_perc <= fib_perc_4 ? 4 : low_perc <= fib_perc_5 ? 5 : low_perc <= fib_perc_6 ? 6 : 6
high_perc := math.ceil(((high - bot) / global_distance) * 100)
// ----------------------------------------}
    // Gestione cover - funzione
// -----------------------------------------------------------{
    //Iterazione scalare per il sistema cover
[tot_sup, old_sup, old_sup_1, old_sup_2, old_sup_3, tot_res, old_res, old_res_1, old_res_2, old_res_3] = M2.scalare_sistema_cover(barstate.islastconfirmedhistory, a_sup, a_res, bot_is_sup, bot, piv_distance, piv_distance_1, piv_distance_2, piv_distance_3, top, piv_distance_1_res, piv_distance_2_res, piv_distance_3_res)
if barstate.islastconfirmedhistory
    fib_for_break := timeframe_level < 2 ? (na(old_res) ? fib_perc_4 : fib_perc_5) : fib_perc_5
    fib_for_scenario := timeframe_level < 2 ? (sentiment_level < 7 ? fib_perc_3 : fib_perc_4) : (sentiment_level < 7 ? fib_perc_4 : fib_perc_5)
    fib_for_scenario_low := sentiment_level < 7 ? fib_perc_3 : fib_perc_4        

// ----------------------------------------}
    // Gestione Breakout
// -----------------------------------------------------------{
        // Dichiarazioni Volume indicator + dichiarazioni liq
// -----------------------------------------------------------{
step                                    = global_distance / cnum
// Identifica i pivot high e low brevi per impostare la liquidità attuale 
pivot_high                              = ta.pivothigh(high, lenght_pivot_order_block, lenght_pivot_order_block)
pivot_low                               = ta.pivotlow(low, lenght_pivot_order_block, lenght_pivot_order_block)
[bot_liq_shadow_new, top_liq_shadow_new, save_bot_liq_new, save_top_liq_new] = M2.manage_pivots(pivot_high, pivot_low, bar_index, bar_limit, bbars, high_pivots, high_bar_indices, low_pivots, low_bar_indices, save_bot_liq, save_top_liq, bot_liq_shadow, top_liq_shadow)
save_bot_liq := save_bot_liq_new
save_top_liq := save_top_liq_new
bot_liq_shadow := bot_liq_shadow_new
top_liq_shadow := top_liq_shadow_new

// ----------------------------------------}
        // Calcolo Percentuali di Distanza e Break Out
// -----------------------------------------------------------{
// Inizializzazione dei breakout alla prima esecuzione, deve essere aggiustato, in questo momento rileva falsi break quando l'ancoraggio è avvenuto su supporto old o resistenza old 
[old_top, old_bot, current_res, current_sup] = M2.breakout(top, actual_resistenza_break, actual_old_resistenza, actual_resistenza, bot, actual_supporto_break, actual_old_supporto, actual_supporto)
if barstate.islastconfirmedhistory 
    bar_breakout := current_res == actual_old_resistenza ? res_switch_bar_old : current_res == actual_resistenza ? res_switch_bar : bar_breakout    
    bar_breakout := bar_index - bar_breakout
if barstate.islastconfirmedhistory 
    bar_breakout_down := current_sup == actual_old_supporto ? support_switch_bar_old : current_sup == actual_supporto ? support_switch_bar : bar_breakout_down    
    bar_breakout_down := bar_index - bar_breakout_down
//
sar = ta.sar(0.1,0.1,0.1)
if barstate.islastconfirmedhistory 
    if top > current_res
        up_breakout := true 
        bot_in_up_break_out := bot
        distanza_break_out_up := current_res - bot_in_up_break_out
        iterazione_break = bar_breakout
        for i = 1 to iterazione_break
            if high[i] == top
                bar_breakout := bar_index - bar_index[i] - 1
                break
    if bot < current_sup
        down_breakout := true 
        top_in_down_break_out := top
        distanza_break_out_down := top_in_down_break_out - current_sup
        iterazione_break_down = bar_breakout_down
        for i = 1 to iterazione_break_down
            if low[i] == bot
                bar_breakout_down := bar_index - bar_index[i] - 1
                break
//
M2.clean_labels(saved_labels) //Pulizia label in eccesso
if run > 0
    breakout_bar_index_up               = ta.valuewhen(high == top, bar_index, 0)
    if up_breakout and low < poc_level
        distanza_break_out_up_post := top - bot_in_up_break_out
        break_out_up_perc := ((distanza_break_out_up_post - distanza_break_out_up) / distanza_break_out_up) * 100
        up_breakout := false 
        label break_out_up_perc_label   = label.new(breakout_bar_index_up, top, "Break_out: " + str.tostring(break_out_up_perc, "#.##") + "%", 
             color = positiveColor, style =label.style_label_down, textcolor =color.white, size = size.small, force_overlay = true)
        array.push(saved_labels, break_out_up_perc_label)
    label.delete(vol_break_up_perc_mom_label)
    if up_breakout
        distanza_break_out_post_mom_up := top - bot_in_up_break_out
        break_out_up_perc_mom := ((distanza_break_out_post_mom_up - distanza_break_out_up) / distanza_break_out_up) * 100
        break_out_up_top_perc := math.max(break_out_up_perc_mom, break_out_up_perc_mom[1])
        vol_break_up_perc_mom_label := label.new(bar_index + 43 , top, text = "Break: " + str.tostring(math.round_to_mintick(break_out_up_perc_mom)) + "%",
                              style = label.style_label_down, color = na, textcolor = positiveColor, force_overlay = true)
    if not up_breakout and not na (break_out_up_top_perc)
        break_out_up_top_perc := na 
// Una collezione per mantenere le label di breakout
if run > 0 
    breakout_bar_index_down             := ta.valuewhen(low == bot, bar_index, 0)
    if down_breakout and high > poc_level
        distanza_break_out_down_post := top_in_down_break_out - bot
        break_out_down_perc := ((distanza_break_out_down_post - distanza_break_out_down) / distanza_break_out_down) * 100
        down_breakout := false 
        label break_out_down_perc_label = label.new(breakout_bar_index_down, bot, "Break_out: " + str.tostring(break_out_down_perc, "#.##") + "%", 
             color =color.blue, style =label.style_label_up, textcolor =color.white, size =size.small, force_overlay = true)
        array.push(saved_labels, break_out_down_perc_label) 
    label.delete(vol_break_down_perc_mom_label)
    if down_breakout
        distanza_break_out_post_mom_down := top_in_down_break_out - bot
        break_out_down_perc_mom := ((distanza_break_out_post_mom_down - distanza_break_out_down) / distanza_break_out_down) * 100
        break_out_down_top_perc := math.max(break_out_down_perc_mom, break_out_down_perc_mom[1])
        vol_break_down_perc_mom_label := label.new(bar_index + 43, bot, text = "Break: " + str.tostring(math.round_to_mintick(break_out_down_perc_mom)) + "%",
                              style = label.style_label_up, color = na , textcolor = color.red, force_overlay = true)
    if not down_breakout and not na (break_out_down_top_perc)
        break_out_down_top_perc         := na 
    //
// -------------------------------------}
// -------------------------------------}
// ----------------------------------------}
// Buy Logic
// -----------------------------------------------------------{
    //Reset allarme Mid e setting iniziale
    // -----------------------------------------------------------{
if close_alarm_mid 
    close_alarm_mid := false 
    scenario_val_to_higher_line := 0, scenario_val_to_higher_ask := 0, scenario_vah_to_bot_target_line := 0, scenario_vah_to_bot_target_ask := 0
    scenario_val_to_bot_target_line := 0, scenario_val_to_bot_target_ask := 0, scenario_poc_to_bot_target_line := 0, scenario_poc_to_bot_target_ask := 0
    scenario_poc_2_to_bot_target_line := 0, scenario_poc_2_to_bot_target_ask    := 0
//
    // -------------------------------------}
    // Lista trig
    // -----------------------------------------------------------{
if tot_position_cover == 0 and last_cover > 0
    last_cover := 0
//
first_bot_liq := (not scenario_bot_line and not scenario_bot_2_line and not na(first_bot_liq)) ? na : first_bot_liq
stable_box = bot[1] == bot and top[1] == top 
// Funzione iterante da lasciare nel codice sorgente per migliorare computabilità, aggiunge le chiusure sui livelli dell'array sinusoide
check_peak_levels() =>
    result = false
    if array.size(peak_level_ar) > 0
        for i = 0 to array.size(peak_level_ar) - 1
            level = array.get(peak_level_ar, i)
            if low[1] < level and high > level
                result := true
                break
    result

var float scenario_siffredi_close_perc = na
var float actual_supporto_poc_level = na 
var int actual_supporto_poc_perc = na 
if barstate.islast and run > 0
    mid_ask_perc := not na(mid_ask) ? math.round((mid_ask - bot) / ((top - bot) * 100)) : na 
    var int n_posizione = na
    //Trig di apertura
    val_trig_base_act = (
             (high[1] >= val_level and low <= val_level) or (high_perc >= val_perc and low_perc <= val_perc and timeframe_level <= 1) or
             (low[1] >= val_level and low <= val_level) or (low_perc >= val_perc and low_perc <= val_perc and timeframe_level <= 1))    
             and stable_box and val_is_in_buy
    vah_trig_base_act = (
             (high[1] >= vah_level and low <= vah_level) or (high_perc >= vah_perc and low_perc <= vah_perc and timeframe_level <= 1) or
             (low[1] >= vah_level and low <= vah_level) or (low_perc >= vah_perc and low_perc <= vah_perc and timeframe_level <= 1))    
             and stable_box and vah_is_in_buy
    poc_trig_base_act = (
             (high[1] >= poc_level and low <= poc_level) or(high_perc >= poc_perc and low_perc <= poc_perc and timeframe_level <= 1) or
             (low[1] >= poc_level and low <= poc_level) or (low_perc >= poc_perc and low_perc <= poc_perc and timeframe_level <= 1)) 
             and stable_box and poc_is_in_buy
    poc_2_trig_base_act = (
             (high[1] >= poc_second_level and low <= poc_second_level) or (high_perc >= poc_2_perc and low_perc <= poc_2_perc and timeframe_level <= 1) or
             (low[1] >= poc_second_level and low <= poc_second_level) or (low_perc >= poc_2_perc and low_perc <= poc_2_perc and timeframe_level <= 1)) 
             and stable_box and poc_2_is_in_buy
    bot_liq_trig = (
             (high[1] >= bot_liq and low <= bot_liq) or (high_perc >= bot_liq_perc and low_perc <= bot_liq_perc and timeframe_level <= 1) or
             (low[1] >= bot_liq and low <= bot_liq)  or (low_perc >= bot_liq_perc and low_perc <= bot_liq_perc and timeframe_level <= 1))
             and stable_box and bot_liq_is_in_buy
    poc_2_trig_break_act = poc_2_trig_base_act and low_perc < lower_lr_perc 
    old_sup_trig = (low[1] > old_sup[1] and low <= old_sup[1]) or (low[1] > old_sup and low <= old_sup)
    //Trig di chiusura 
    higher_target_bot_trig      = high >= higher_target_bot or high_perc >= higher_target_bot_perc    
    lower_target_bot_trig       = high >= lower_target_bot or high_perc >= lower_target_bot_perc or high > upperEndPrice_lr     
    siffredi_higher_target_trig = high >= siffredi_higher_target or high_perc >= siffredi_higher_target_perc                    
    siffredi_lower_target_trig  = high >= siffredi_lower_target or high_perc >= siffredi_lower_target_perc       
    break_higher_target_trig    = high >= break_higher_target or high_perc >= break_higher_target_perc      
    break_lower_target_trig     = high >= break_lower_target or high_perc >= break_lower_target_perc        
    mid_lower_target_trig       = (high >= mid_lower_target or high_perc >= mid_lower_target_perc or high > upperEndPrice_lr) and open_position_mid > 0 and save_start_perc == save_start_perc[1]
    mid_higher_target_trig      = (high >= mid_higher_target or high_perc >= mid_higher_target_perc) and open_position_mid > 0
    actual_support_lower_trig   = high >= actual_support_lower or high_perc >= actual_support_lower_perc or high > upperEndPrice_lr               
    cover_1_higher_target_trig  = high >= cover_1_higher_target or high_perc >= cover_1_higher_target_perc     
    cover_1_lower_target_trig   = high >= cover_1_lower_target  or high_perc >= cover_1_lower_target_perc        
    cover_2_higher_target_trig  = high >= cover_2_higher_target or high_perc >= cover_2_higher_target_perc     
    cover_2_lower_target_trig   = high >= cover_2_lower_target  or high_perc >= cover_2_lower_target_perc        
    cover_3_higher_target_trig  = high >= cover_3_higher_target or high_perc >= cover_3_higher_target_perc     
    cover_3_lower_target_trig   = high >= cover_3_lower_target  or high_perc >= cover_3_lower_target_perc        
    cover_4_higher_target_trig  = high >= cover_4_higher_target or high_perc >= cover_4_higher_target_perc        
    cover_4_lower_target_trig   = high >= cover_4_lower_target  or high_perc >= cover_4_lower_target_perc        
    actual_support_trig = actual_support_lower_trig 
    chiusura_scenario_under_lower_lr = sentiment_level < 7 ? mid_lower_target_trig : mid_higher_target_trig
    chiusura_scenario_siffredi = sentiment_level < 7 ? siffredi_lower_target_trig : siffredi_higher_target_trig
    chiusura_scenario_break_fib_4 = sentiment_level < 7 ? break_lower_target_trig : break_higher_target_trig
    any_trig_close = (low[1] < val_level and high > val_level) or (low[1] < vah_level and high > vah_level) or
         (low[1] < poc_level and high > poc_level ) or (low[1] < poc_second_level and high > poc_second_level) or
         (low[1] < top_liq and high > top_liq) or check_peak_levels()        
    // -------------------------------------}
    // Buy Break out ID 13 - 23
    // -----------------------------------------------------------{
    bool scenario_break_out = false 
    scenario_break_out := market_buy_pattern == "Poc 2 Break" ? poc_2_trig_base_act : market_buy_pattern == "Poc Break" ? poc_trig_base_act : market_buy_pattern == "Vah Break" ? vah_trig_base_act : false
    bool scenario_siffredi = false 
    if (market_buy_pattern == "Siffredi") or ((market_buy_pattern == "Siffredi look for break"))
        scenario_siffredi := market_buy_pattern == "Siffredi" and na(siffredi_ask) and not siffredi_fatta ? (vah_trig_base_act or bot_liq_trig or poc_2_trig_base_act or poc_trig_base_act or val_trig_base_act)  : 
                             market_buy_pattern == "Siffredi look for break" and na(siffredi_ask) and not siffredi_fatta ? (poc_trig_base_act or val_trig_base_act or bot_liq_trig) : 
                             market_buy_pattern == "Siffredi" and na(siffredi_ask) and siffredi_fatta and not na(scenario_siffredi_close_perc) ? ((vah_trig_base_act and vah_perc < scenario_siffredi_close_perc -5) or (bot_liq_trig and bot_liq_perc < scenario_siffredi_close_perc -5) or (poc_2_trig_base_act and poc_2_perc < scenario_siffredi_close_perc -5) or (poc_trig_base_act and poc_perc < scenario_siffredi_close_perc -5) or (val_trig_base_act and val_perc < scenario_siffredi_close_perc -5))  : 
                             market_buy_pattern == "Siffredi look for break" and na(siffredi_ask) and siffredi_fatta and not na(scenario_siffredi_close_perc -5) ? ((poc_trig_base_act and poc_perc < scenario_siffredi_close_perc -5) or (val_trig_base_act and val_perc < scenario_siffredi_close_perc -5) or (bot_liq_trig and bot_liq_perc < scenario_siffredi_close_perc -5)) : false
    //
    if scenario_break_out and open_position_mid == 0 and tot_position_scenario_bot == 0 and scenario_break_out_line == 0
        n_posizione := 13
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
         \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
         str.tostring(timenow), "{", titolo, "BUY", n_titoli_moltiplicatore_break, "}", "}", "}"), alert.freq_once_per_bar)
        scenario_break_out_line := 1
        scenario_break_out_ask := vah_trig_base_act ? (vah_level + spread) : poc_2_trig_base_act  ? (poc_second_level + spread) : poc_trig_base_act ? (poc_level + spread) : val_trig_base_act ? (val_level + spread) : (bot_liq + spread)
        break_ask := scenario_break_out_ask
        break_start_perc := (scenario_break_out_ask - bot) / ((top - bot) * 100)
        label scenario_break = label.new(bar_index, low - (high - low), "scenario break", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, scenario_break)
    //
    if scenario_break_out_line == 1 and scenario_break_out_line[1] == 1 and chiusura_scenario_break_fib_4 and high > scenario_break_out_ask        
        n_posizione := 13
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
         \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
        break_ask := na, break_start_perc := na,
        scenario_break_out_ask := 0, scenario_break_out_line  := 0
        label close_res = label.new(bar_index, high, "close scenario break", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, close_res)
    // 
    if scenario_siffredi and open_position_mid == 0 and (tot_position_scenario_bot == 0 or (tot_position_scenario_bot == 1 and tot_position == 1)) and scenario_break_out_line == 0
        n_posizione := 23
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
         \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
         str.tostring(timenow), "{", titolo, "BUY", n_titoli_moltiplicatore_break, "}", "}", "}"), alert.freq_once_per_bar)
        scenario_break_out_line := 1, scenario_break_out_ask := vah_trig_base_act ? (vah_level + spread) :poc_2_trig_base_act ? (poc_second_level + spread) :poc_trig_base_act ? (poc_level + spread) :(poc_level + spread)
        break_ask := scenario_break_out_ask, siffredi_ask := break_ask
        break_start_perc :=  not na(scenario_break_out_ask) ? (scenario_break_out_ask - bot) / ((top - bot) * 100) : na
        label scenario_break = label.new(bar_index, low - (high - low), "scenario siffredi", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, scenario_break)
    //
    if scenario_break_out_line == 1 and scenario_break_out_line[1] == 1 and chiusura_scenario_siffredi and high > scenario_break_out_ask and not na(siffredi_ask)
        n_posizione := 23
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
         \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
        break_ask := na, siffredi_ask := na, break_start_perc := na
        scenario_break_out_ask := 0, scenario_break_out_line := 0
        scenario_siffredi_close_perc := siffredi_higher_target_trig ? siffredi_higher_target_perc : siffredi_lower_target_perc
        label close_res = label.new(bar_index, high, "close scenario siffredi", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, close_res)
    //
    siffredi_fatta := market_buy_pattern == "Siffredi" and scenario_break_out_line == 1 ? true : (market_buy_pattern != "Siffredi" and siffredi_fatta ? false : siffredi_fatta)
    scenario_siffredi_close_perc := siffredi_fatta ? scenario_siffredi_close_perc : na
    // Conteggio posizioni break
    open_position_break := scenario_actual_over_bot_line + scenario_break_out_line
    // -------------------------------------}
    // Mid position 
    // -----------------------------------------------------------{
        // Mid position setting
    // -----------------------------------------------------------{
    bool open_12 = false
    bool open_13 = false
    bool close_12 = false
    // -------------------------------------}
        // Buy 2 Poc position 
    // -----------------------------------------------------------{
    var bool scenario_poc_2_to_bot_target = false 
    scenario_poc_2_to_bot_target := market_buy_pattern == "Poc 2 Buy Fig" ? poc_2_trig_base_act : false 
    if scenario_poc_2_to_bot_target and open_position_mid == 0 and tot_position_scenario_bot == 0 and open_position_break == open_position_break[1]
        if scenario_break_out_line == 0
            open_13 := true 
            scenario_break_out_line := 1
            scenario_break_out_ask := poc_second_level + spread 
            break_ask := scenario_break_out_ask
            break_start_perc := (scenario_break_out_ask - bot) / ((top - bot) * 100)
        else
            open_12 := true
            scenario_poc_2_to_bot_target_line := 1, scenario_poc_2_to_bot_target_ask  := poc_second_level + spread 
            mid_ask := scenario_poc_2_to_bot_target_ask
            open_position_mid := 1
        label scenario_poc_2_to_bot_target_label = label.new(bar_index, low, "scenario_poc 2 to bot target", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, scenario_poc_2_to_bot_target_label)
    //
    if scenario_poc_2_to_bot_target_line == 1 and scenario_poc_2_to_bot_target_line[1] == 1 and (chiusura_scenario_under_lower_lr) and high > scenario_poc_2_to_bot_target_ask
        close_12 := true
        mid_ask := na
        scenario_poc_2_to_bot_target_line := 0, scenario_poc_2_to_bot_target_ask  := 0
        label close_poc_2_to_bot_higher_label = label.new(bar_index, high, "close scenario poc 2 to bot target", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, close_poc_2_to_bot_higher_label)
    //
    // -------------------------------------}
        // Buy Poc position 
    // -----------------------------------------------------------{
    var bool scenario_poc_to_bot_target = false 
    scenario_poc_to_bot_target := market_buy_pattern == "Poc Buy Fig" ? poc_trig_base_act : false 
    if scenario_poc_to_bot_target and open_position_mid == 0 and tot_position_scenario_bot == 0 and open_position_break == open_position_break[1] 
        if scenario_break_out_line == 0
            open_13 := true 
            scenario_break_out_line := 1
            scenario_break_out_ask := poc_level + spread 
            break_ask := scenario_break_out_ask
            break_start_perc := (scenario_break_out_ask - bot) / ((top - bot) * 100)
        else
            open_12 := true
            scenario_poc_to_bot_target_line := 1, scenario_poc_to_bot_target_ask  := poc_level + spread 
            mid_ask := scenario_poc_to_bot_target_ask
            open_position_mid := 1
        label scenario_poc_to_bot_target_label = label.new(bar_index, low, "scenario_poc to bot target", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, scenario_poc_to_bot_target_label)
        //
    if scenario_poc_to_bot_target_line == 1 and scenario_poc_to_bot_target_line[1] == 1 and (chiusura_scenario_under_lower_lr) and high > scenario_poc_to_bot_target_ask
        close_12 := true
        mid_ask := na
        scenario_poc_to_bot_target_line := 0, scenario_poc_to_bot_target_ask  := 0
        label close_poc_to_bot_higher_label = label.new(bar_index, high, "close scenario poc to bot target", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, close_poc_to_bot_higher_label)
    //
    // -------------------------------------}
        // Buy Val position 
    // -----------------------------------------------------------{
    var bool scenario_val_to_bot_target = false 
    scenario_val_to_bot_target := market_buy_pattern == "Val Buy Fig" ? val_trig_base_act : false 
    if scenario_val_to_bot_target and open_position_mid == 0 and tot_position_scenario_bot == 0 and open_position_break == open_position_break[1]
        if scenario_break_out_line == 0
            open_13 := true 
            scenario_break_out_line := 1
            scenario_break_out_ask := val_level + spread 
            break_ask := scenario_break_out_ask
            break_start_perc := (scenario_break_out_ask - bot) / ((top - bot) * 100)
        else
            open_12 := true
            scenario_val_to_bot_target_line := 1, scenario_val_to_bot_target_ask := val_level + spread 
            mid_ask := scenario_val_to_bot_target_ask
            open_position_mid := 1
        label scenario_val_to_bot_target_label = label.new(bar_index, low, "scenario_val to bot target", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, scenario_val_to_bot_target_label)
    //
    if scenario_val_to_bot_target_line == 1 and scenario_val_to_bot_target_line[1] == 1 and (chiusura_scenario_under_lower_lr) and high > scenario_val_to_bot_target_ask
        close_12 := true
        mid_ask := na
        scenario_val_to_bot_target_line := 0, scenario_val_to_bot_target_ask  := 0
        label close_val_to_bot_higher_label = label.new(bar_index, high, "close scenario val to bot target", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, close_val_to_bot_higher_label)
    //
    // -------------------------------------}
        // Buy Vah position
    // -----------------------------------------------------------{
    var bool scenario_vah_to_bot_target = false 
    scenario_vah_to_bot_target := market_buy_pattern == "Vah Buy Fig" ? vah_trig_base_act : false 
    if scenario_vah_to_bot_target and open_position_mid == 0 and tot_position_scenario_bot == 0 and open_position_break == open_position_break[1]
        if scenario_break_out_line == 0
            open_13 := true 
            scenario_break_out_line := 1
            scenario_break_out_ask := vah_level + spread 
            break_ask := scenario_break_out_ask
            break_start_perc := (scenario_break_out_ask - bot) / ((top - bot) * 100)
        else
            open_12 := true
            scenario_vah_to_bot_target_line := 1, scenario_vah_to_bot_target_ask := vah_level + spread 
            mid_ask := scenario_vah_to_bot_target_ask
            open_position_mid := 1
        label scenario_vah_to_bot_target_label = label.new(bar_index, low, "scenario_vah to bot target", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, scenario_vah_to_bot_target_label)
    //
    if scenario_vah_to_bot_target_line == 1 and scenario_vah_to_bot_target_line[1] == 1 and (chiusura_scenario_under_lower_lr) and high > scenario_vah_to_bot_target_ask
        close_12 := true
        mid_ask := na
        scenario_vah_to_bot_target_line := 0, scenario_vah_to_bot_target_ask := 0
        label close_vah_to_bot_higher_label = label.new(bar_index, high, "close scenario vah to bot target", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, close_vah_to_bot_higher_label)
    //
    // -------------------------------------}
        // Mid position alert
    // -----------------------------------------------------------{
    if open_12
        n_posizione := 12
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
         \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
         str.tostring(timenow), "{", titolo, "BUY", n_titoli_moltiplicatore_mid, "}", "}", "}"), alert.freq_once_per_bar)
    if open_13
        n_posizione := 13
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
         \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
         str.tostring(timenow), "{", titolo, "BUY", n_titoli_moltiplicatore_mid, "}", "}", "}"), alert.freq_once_per_bar)
    if close_12
        n_posizione := 12
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
         \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
    //
    // -------------------------------------}
    // -------------------------------------}
    //Conteggio posizioni e gestione secondaria dei livelli di target 
    // -----------------------------------------------------------{
    open_position_mid := scenario_val_to_higher_line + scenario_poc_to_bot_target_line + scenario_val_to_bot_target_line + scenario_vah_to_bot_target_line + scenario_poc_2_to_bot_target_line
    mid_just_open = open_position_mid > open_position_mid[1] 
    mid_ask_perc := not na(mid_ask) ? math.round((mid_ask - bot) / ((top - bot) * 100)) : na 
    // -------------------------------------}
    // Buy Logic Bot
    // -----------------------------------------------------------{
        // Posizione Actual over bot
    // -----------------------------------------------------------{
    scenario_actual_over_bot = actual_support_over_bot_perc < lower_lr_perc and actual_supporto > bot and bot_is_sup and low[1] > actual_supporto_poc_level and low < actual_supporto_poc_level and act_sup_is_in_buy and (actual_supporto < mid_ask or na(mid_ask)) and tot_position_scenario_bot == 0 and not cover_1_line
    // Apertura
    if scenario_actual_over_bot and open_position_break == 0 and not mid_just_open and tot_position_scenario_bot == 0 
        n_posizione := 11
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
         \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
         str.tostring(timenow), "{", titolo, "BUY", n_titoli_moltiplicatore_mid, "}", "}", "}"), alert.freq_once_per_bar)
        scenario_actual_over_bot_line := 1, scenario_actual_over_bot_ask := actual_supporto + spread * 2
        label scenario_actual_over_bot_label = label.new(bar_index, low - (high - low), "scenario actual over bot", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, scenario_actual_over_bot_label)
    // Chiusura
    if scenario_actual_over_bot_line == 1 and scenario_actual_over_bot_line[1] == 1 and (high > upperEndPrice_lr[1] or actual_support_trig) and high > scenario_actual_over_bot_ask
        n_posizione := 11
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
         \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
        close_mid_fast := high > mid_ask ? true : false
        close_break_fast := high > break_ask ? true : false
        scenario_actual_over_bot_line := 0, scenario_actual_over_bot_ask  := 0
        label close_actual_over_bot = label.new(bar_index, high, "close actual over bot", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, close_actual_over_bot)
    //
    // -------------------------------------}
        // Attivazione scenari bot
    // -------------------------------------{
    scenario_bot   = bot_liq_trig and bot_is_sup and not scenario_bot_line and not scenario_bot_2_line and not cover_1_line[1]
    scenario_bot_down = low < bot[1]
    scenario_bot_down_start = scenario_bot_down and ((bot_is_sup[1] and not scenario_bot_line and not scenario_bot_2_line ))
    scenario_bot_2 = old_sup_trig and not bot_is_sup and not scenario_bot_line and not scenario_bot_2_line and not cover_1_line[1]
    //Salvo due blocchi diversi di livelli cover a parte in modo da non raddoppiare la successiva iterazione del codice.
    if (scenario_bot or scenario_bot_down_start) and not scenario_bot_line
        scenario_bot_line   := true 
        first_bot_liq := bot_liq, first_bot := bot
        supporto_1 := not na(old_sup) ? old_sup : na, supporto_2 := not na(old_sup_1) ? old_sup_1 : na, supporto_3 := not na(old_sup_2) ? old_sup_2 : na, supporto_4 := not na(old_sup_3) ? old_sup_3 : na        
    if scenario_bot_2 and not scenario_bot_2_line
        scenario_bot_2_line := true 
        first_bot_liq := bot_liq, first_bot := old_sup
        supporto_1 := not na(old_sup_1) ? old_sup_1 : na, supporto_2 := not na(old_sup_2) ? old_sup_2 : na, supporto_3 := not na(old_sup_3) ? old_sup_3 : na
    // Incremento dei supporti in caso di pericolosità del mercato crescente
    if tot_position_scenario_bot > 0 and incremento_distanza_pivot != incremento_distanza_pivot[1]
        supporto_1 := na, supporto_2 := na, supporto_3 := na, supporto_4 := na
        array.sort(a_sup, order.descending)  // Ordine decrescente per supporti
        for i = 0 to array.size(a_sup) - 1
            supporto_1 := (array.get(a_sup, i) < (first_bot - piv_distance[1]) and array.get(a_sup, i) < supporto_1[1] and not na(supporto_1[1])) ? array.get(a_sup, i) : na
        if not na(supporto_1)
            for i = 0 to array.size(a_sup) - 1
                supporto_2 := (array.get(a_sup, i) < (supporto_1 - piv_distance_1[1]) and array.get(a_sup, i) < supporto_2[1] and not na(supporto_2[1])) ? array.get(a_sup, i) : na
        if not na(supporto_2) 
            for i = 0 to array.size(a_sup) - 1
                supporto_3 := (array.get(a_sup, i) < (supporto_2 - piv_distance_2[1]) and array.get(a_sup, i) < supporto_3[1] and not na(supporto_3[1])) ? array.get(a_sup, i) : na
        if not na(supporto_3)
            for i = 0 to array.size(a_sup) - 1
                supporto_4 := (array.get(a_sup, i) < (supporto_3 - piv_distance_3[1]) and array.get(a_sup, i) < supporto_4[1] and not na(supporto_4[1])) ? array.get(a_sup, i) : na
        //
    // -------------------------------------}
        //Iterazioni quando bot_is_sup  
    // -------------------------------------{
    if scenario_bot_line
        if ((scenario_bot and ((bot_liq_perc < mid_ask_perc - 13) or na(mid_ask_perc))) or scenario_bot_down_start) and scenario_bot_line_to_l == 0 and scenario_actual_over_bot_line == 0 and not mid_just_open
            n_posizione := 1 
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
             \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
             str.tostring(timenow), "{", titolo, "BUY", n_titoli_moltiplicatore_bot, "}", "}", "}"), alert.freq_once_per_bar)
            scenario_bot_line_to_l := 1, scenario_bot_ask_to_l := scenario_bot ? (bot_liq[1] + spread) : (bot[1] + spread)
            scenario_bot_1_string_start := scenario_bot ? "scenario_bot" : "scenario_bot_down_start"
            label scenario_bot_label = label.new(bar_index, low, "scenario_bot l", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_bot_label)
        //
        if (scenario_bot or scenario_bot_down_start) and scenario_bot_line_to_h == 0 and (open_position_break + open_position_mid) < 4 and na(siffredi_ask) 
            n_posizione := 2
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
             \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
             str.tostring(timenow), "{", titolo, "BUY", n_titoli_moltiplicatore_bot, "}", "}", "}"), alert.freq_once_per_bar)
            scenario_bot_line_to_h := 1, scenario_bot_ask_to_h := bot_liq[1] + spread 
            label scenario_bot_2_label = label.new(bar_index, low, "scenario_bot h", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_bot_2_label)
        // Chiusure
        if scenario_bot_line_to_l == 1 and scenario_bot_line_to_l[1] == 1 and ((lower_target_bot_trig) or (cover_1_line and any_trig_close)) and high > scenario_bot_ask_to_l
            n_posizione := 1
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
             \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
            close_mid_fast := high > mid_ask ? true : false
            close_break_fast := high > break_ask ? true : false
            scenario_bot_1_string_start := na 
            label scenario_bot_close_label_l = label.new(bar_index, high, "close scenario_bot l", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
            scenario_bot_line_to_l := 0, scenario_bot_ask_to_l := 0
            array.push(saved_labels, scenario_bot_close_label_l)
        //
        if scenario_bot_line_to_h == 1 and scenario_bot_line_to_h[1] == 1 and ((higher_target_bot_trig) or (cover_2_line and any_trig_close)) and high > scenario_bot_ask_to_h
            n_posizione := 2
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
             \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
            close_mid_fast := high > mid_ask ? true : false
            close_break_fast := high > break_ask ? true : false
            label scenario_bot_close_label_h = label.new(bar_index, high, "close scenario_bot h", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_bot_close_label_h)
            scenario_bot_line_to_h := 0
            scenario_bot_ask_to_h := 0
        //
    // -------------------------------------}
        //Iterazioni quando not bot_is_sup 
    // -------------------------------------{
    if scenario_bot_2_line 
        // Aperture
        if (scenario_bot_2) and scenario_bot_line_to_l == 0 and scenario_actual_over_bot_line == 0 and not mid_just_open and ((bot_liq_perc < mid_ask_perc - 13) or na(mid_ask_perc)) 
            n_posizione := 1
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
             \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
             str.tostring(timenow), "{", titolo, "BUY", n_titoli_moltiplicatore_bot, "}", "}", "}"), alert.freq_once_per_bar)
            scenario_bot_line_to_l := 1, scenario_bot_ask_to_l := old_sup + spread 
            label scenario_bot_label = label.new(bar_index, low, "scenario_bot l", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_bot_label)
        //
        if scenario_bot_2 and scenario_bot_line_to_h == 0 and (open_position_break + open_position_mid) < 4 and na(siffredi_ask)
            n_posizione := 2
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
             \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
             str.tostring(timenow), "{", titolo, "BUY", n_titoli_moltiplicatore_bot, "}", "}", "}"), alert.freq_once_per_bar)
            scenario_bot_line_to_h := 1, scenario_bot_ask_to_h := old_sup + spread 
            label scenario_bot_2_label = label.new(bar_index, low, "scenario_bot h", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_bot_2_label)
        // Chiusure
        if scenario_bot_line_to_l == 1  and scenario_bot_line_to_l[1] == 1 and ((lower_target_bot_trig or (cover_1_line and any_trig_close))) and high > scenario_bot_ask_to_l
            n_posizione := 1
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
             \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
            close_mid_fast := high > mid_ask ? true : false
            close_break_fast := high > break_ask ? true : false
            scenario_bot_line_to_l := 0, scenario_bot_ask_to_l := 0
            label scenario_bot_close_label_l = label.new(bar_index, high, "close scenario_bot l", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_bot_close_label_l)
        //
        if scenario_bot_line_to_h == 1 and scenario_bot_line_to_h[1] == 1 and ((higher_target_bot_trig) or (cover_2_line and any_trig_close)) and high > scenario_bot_ask_to_h
            n_posizione := 2
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
             \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
            close_mid_fast := high > mid_ask ? true : false
            close_break_fast := high > break_ask ? true : false
            scenario_bot_line_to_h := 0, scenario_bot_ask_to_h := 0
            label scenario_bot_close_label_h = label.new(bar_index, high, "close scenario_bot h", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_bot_close_label_h)
        //
    // -------------------------------------}
    // -------------------------------------}
    // Chiusura posizioni mid e break di copertura
    // -------------------------------------{
    if close_mid_fast
        n_posizione := 12
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
         \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
        close_alarm_mid := true, close_mid_fast := false 
        label close_alarm_mid_label = label.new(bar_index, high + high - low, "close alarm mid", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, close_alarm_mid_label)
    //
    if close_break_fast
        n_posizione := 13
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
         \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
        break_ask := na, break_start_perc := na, scenario_break_out_ask := 0, scenario_break_out_line := 0, close_break_fast := false
        label close_res = label.new(bar_index, high, "close scenario break", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, close_res)
    //
    // -------------------------------------}
    //Pulisco i livelli di bot e i supporti quando le posizioni sono tutte chiuse - definisco le variabili di cover
    // -------------------------------------{
    tot_position_scenario_bot := scenario_bot_line_to_l + scenario_bot_line_to_h 
    //Chiusura della line di scenario bot quando non ci sono operazioni aperte
    if tot_position_scenario_bot == 0 and scenario_bot_line 
        scenario_bot_line := false 
        supporto_1 := na 
        supporto_2 := na 
        supporto_3 := na 
        supporto_4 := na 
    //
    if tot_position_scenario_bot == 0 and scenario_bot_2_line
        scenario_bot_2_line := false 
        supporto_1 := na 
        supporto_2 := na 
        supporto_3 := na 
        supporto_4 := na 
    //            
    if scenario_bot_line or scenario_bot_2_line
        supporto_cover_trig_1 := not na(supporto_1[1]) and low[1] > supporto_1[1] and low <= supporto_1[1] and not cover_2_line
        supporto_cover_trig_2 := not na(supporto_2[1]) and low[1] > supporto_2[1] and low <= supporto_2[1] and not cover_3_line
        supporto_cover_trig_3 := not na(supporto_3[1]) and low[1] > supporto_3[1] and low <= supporto_3[1] and not cover_4_line
        supporto_cover_trig_4 := not na(supporto_4[1]) and low[1] > supporto_4[1] and low <= supporto_4[1]
    //
    // -------------------------------------}
    // Cover Bot
    // -----------------------------------------------------------{
    string block_cover = na 
    if timeframe_level <= 1
        if sentiment_level < 11
            block_cover := "H"
        else 
            block_cover := "L"

        //Posizione cover Siffredi
    // -------------------------------------{
    siffredi_cover_line := (tot_position_scenario_bot > 0 and upperEndPrice_lr < scenario_bot_ask_to_h and scenario_siffredi_cover_line == 0 and na(siffredi_ask)) ? true : false
    bool scenario_siffredi_cover = false 
    if siffredi_cover_line and ((market_buy_pattern == "Siffredi") or (market_buy_pattern == "Siffredi look for break"))
        scenario_siffredi_cover := ((vah_trig_base_act) or (poc_2_trig_base_act) or poc_trig_base_act or (val_trig_base_act))
    if scenario_siffredi_cover 
        block_cover_open := not cover_1_line ? "Cover 1" : cover_1_line and not cover_2_line ? "Cover 2" : cover_2_line and not cover_3_line ? "Cover 3" : cover_3_line and not cover_4_line ? "Cover 4" : block_cover_open
    //
    if scenario_siffredi_cover 
        n_posizione := 100
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
         \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
         str.tostring(timenow), "{", titolo, "BUY", n_titoli_moltiplicatore_cover, "}", "}", "}"), alert.freq_once_per_bar)
        scenario_siffredi_cover_line := 1
        scenario_siffredi_cover_ask := vah_trig_base_act ? (vah_level + spread) :
                                 poc_2_trig_base_act     ? (poc_second_level + spread) :
                                 poc_trig_base_act       ? (poc_level + spread) :
                                 (poc_level + spread)        
        siffredi_ask := scenario_siffredi_cover_ask
        label scenario_siffredi_cover_label = label.new(bar_index, low - (high - low), "scenario siffredi cover", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, scenario_siffredi_cover_label)
    //
    if scenario_siffredi_cover_line == 1 and scenario_siffredi_cover_line[1] == 1 and chiusura_scenario_siffredi and high > scenario_siffredi_cover_ask
        n_posizione := 100
        alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
         \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
        siffredi_ask := na , scenario_siffredi_cover_line := 0, scenario_siffredi_cover_ask := 0, block_cover_open := na 
        label scenario_siffredi_cover_label_close = label.new(bar_index, high, "close scenario siffredi cover", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
        array.push(saved_labels, scenario_siffredi_cover_label_close)
    //
    // -------------------------------------}
        //Posizione cover 1
    // -------------------------------------{
    if supporto_cover_trig_1 
        cover_1_line := true 
    //Aperture
    if cover_1_line
        if supporto_cover_trig_1 and scenario_cover_1_line_to_h == 0 and block_cover_open != "Cover 1" and block_cover != "H"
            n_posizione := 3
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
             \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
             str.tostring(timenow), "{", titolo, "BUY", n_titoli_moltiplicatore_cover, "}", "}", "}"), alert.freq_once_per_bar)
            scenario_cover_1_line_to_h := 1, scenario_cover_1_ask_to_h := supporto_1 + spread 
            label scenario_cover_1_label_h = label.new(bar_index, low, "scenario_cover_1 h", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_1_label_h)
        //
        if supporto_cover_trig_1 and scenario_cover_1_line_to_l == 0 and block_cover != "L"
            n_posizione := 4
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
             \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
             str.tostring(timenow), "{", titolo, "BUY", n_titoli_moltiplicatore_cover, "}", "}", "}"), alert.freq_once_per_bar)
            scenario_cover_1_line_to_l := 1, scenario_cover_1_ask_to_l := supporto_1 + spread 
            label scenario_cover_1_label_l = label.new(bar_index, low, "scenario_cover_1 l", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_1_label_l)
        //Chiusure
        if scenario_cover_1_line_to_h == 1 and scenario_cover_1_line_to_h[1] == 1 and ((cover_1_higher_target_trig)) and high > scenario_cover_1_ask_to_h
            n_posizione := 3
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
             \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
            scenario_cover_1_line_to_h := 0, scenario_cover_1_ask_to_h := 0
            label scenario_cover_1_close_label_h = label.new(bar_index, high, "close scenario_cover_1 h", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_1_close_label_h)
        //
        if scenario_cover_1_line_to_l == 1 and scenario_cover_1_line_to_l[1] == 1 and cover_1_lower_target_trig and high > scenario_cover_1_ask_to_l
            n_posizione := 4
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
             \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
            scenario_cover_1_line_to_l := 0, scenario_cover_1_ask_to_l := 0
            label scenario_cover_1_close_label_l = label.new(bar_index, high, "close scenario_cover_1 l", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_1_close_label_l)
            //
        tot_position_scenario_cover_1 := scenario_cover_1_line_to_l + scenario_cover_1_line_to_h
        if tot_position_scenario_cover_1 == 0 and cover_1_line //Chiusura della line di scenario bot quando non ci sono operazioni aperte
            cover_1_line := false 
        //
    // -------------------------------------}
        //Posizione cover 2
    // -------------------------------------{
    if supporto_cover_trig_2 and (cover_1_line[1] or not cover_1_line) 
        cover_2_line := true 
    //Aperture
    if cover_2_line
        if supporto_cover_trig_2 and scenario_cover_2_line_to_h == 0 and block_cover_open != "Cover 2" and block_cover != "H"
            n_posizione := 5
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
             \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
             str.tostring(timenow), "{", titolo, "BUY", n_titoli_moltiplicatore_cover, "}", "}", "}"), alert.freq_once_per_bar)
            scenario_cover_2_line_to_h := 1, scenario_cover_2_ask_to_h := supporto_2 + spread 
            label scenario_cover_2_label_h = label.new(bar_index, low, "scenario_cover_2 h", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_2_label_h)
        //
        if supporto_cover_trig_2 and scenario_cover_2_line_to_l == 0 and block_cover != "L"
            n_posizione := 6
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
             \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
             str.tostring(timenow), "{", titolo, "BUY", n_titoli_moltiplicatore_cover, "}", "}", "}"), alert.freq_once_per_bar)
            scenario_cover_2_line_to_l := 1, scenario_cover_2_ask_to_l := supporto_2 + spread 
            label scenario_cover_2_label_l = label.new(bar_index, low, "scenario_cover_2 l", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_2_label_l)
        //Chiusure
        if scenario_cover_2_line_to_h == 1 and scenario_cover_2_line_to_h[1] == 1 and cover_2_higher_target_trig and high > scenario_cover_2_ask_to_h
            n_posizione := 5
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
             \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
            scenario_cover_2_line_to_h := 0, scenario_cover_2_ask_to_h := 0
            label scenario_cover_2_close_label_h = label.new(bar_index, high, "close scenario_cover_2 h", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_2_close_label_h)
            //
        if scenario_cover_2_line_to_l == 1 and scenario_cover_2_line_to_l[1] == 1 and cover_2_lower_target_trig and high > scenario_cover_2_ask_to_l
            n_posizione := 6
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
             \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
            label scenario_cover_2_close_label_l = label.new(bar_index, high, "close scenario_cover_2 l", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
            scenario_cover_2_line_to_l := 0, scenario_cover_2_ask_to_l := 0
            array.push(saved_labels, scenario_cover_2_close_label_l)
            //
        tot_position_scenario_cover_2 := scenario_cover_2_line_to_l + scenario_cover_2_line_to_h
        if tot_position_scenario_cover_2 == 0 and cover_2_line //Chiusura della line di scenario bot quando non ci sono operazioni aperte
            cover_2_line := false 
        //
    // -------------------------------------}
        //Posizione cover 3
    // -------------------------------------{
    if supporto_cover_trig_3 and (cover_2_line[1] or not cover_2_line) 
        cover_3_line := true 
    //Aperture
    if cover_3_line 
        if supporto_cover_trig_3 and scenario_cover_3_line_to_h == 0 and block_cover_open != "Cover 3" and block_cover != "H"
            n_posizione := 7
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
             \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
             str.tostring(timenow), "{", titolo, "BUY", n_titoli_moltiplicatore_cover, "}", "}", "}"), alert.freq_once_per_bar)
            scenario_cover_3_line_to_h := 1, scenario_cover_3_ask_to_h := supporto_3 + spread 
            label scenario_cover_3_label_h = label.new(bar_index, low, "scenario_cover_3 h", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_3_label_h)
        //
        if supporto_cover_trig_3 and scenario_cover_3_line_to_l == 0 and block_cover != "L"
            n_posizione := 8
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
             \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
             str.tostring(timenow), "{", titolo, "BUY", n_titoli_moltiplicatore_cover, "}", "}", "}"), alert.freq_once_per_bar)
            scenario_cover_3_line_to_l := 1, scenario_cover_3_ask_to_l := supporto_3 + spread 
            label scenario_cover_3_label_l = label.new(bar_index, low, "scenario_cover_3 l", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_3_label_l)
        //Chiusure
        if scenario_cover_3_line_to_h == 1 and scenario_cover_3_line_to_h[1] == 1 and cover_3_higher_target_trig and high > scenario_cover_3_ask_to_h
            n_posizione := 7
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
             \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
            scenario_cover_3_line_to_h := 0, scenario_cover_3_ask_to_h := 0
            label scenario_cover_3_close_label_h = label.new(bar_index, high, "close scenario_cover_3 h", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_3_close_label_h)
        //
        if scenario_cover_3_line_to_l == 1 and scenario_cover_3_line_to_l[1] == 1 and cover_3_lower_target_trig and high > scenario_cover_3_ask_to_l
            n_posizione := 8
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
             \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
            scenario_cover_3_line_to_l := 0, scenario_cover_3_ask_to_l := 0
            label scenario_cover_3_close_label_l = label.new(bar_index, high, "close scenario_cover_3 l", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_3_close_label_l)
        //
        tot_position_scenario_cover_3 := scenario_cover_3_line_to_l + scenario_cover_3_line_to_h
        if tot_position_scenario_cover_3 == 0 and cover_3_line //Chiusura della line di scenario bot quando non ci sono operazioni aperte
            cover_3_line := false 
        //
    // -------------------------------------}
        //Posizione cover 4
    // -------------------------------------{
    if supporto_cover_trig_4 and (cover_3_line[1] or not cover_3_line)
        cover_4_line := true 
    //Aperture
    if cover_4_line 
        if supporto_cover_trig_4 and scenario_cover_4_line_to_h == 0 and block_cover_open != "Cover 4" and block_cover != "H"
            n_posizione := 9
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
             \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
             str.tostring(timenow), "{", titolo, "BUY", n_titoli_moltiplicatore_cover, "}", "}", "}"), alert.freq_once_per_bar)
            scenario_cover_4_line_to_h := 1, scenario_cover_4_ask_to_h := supporto_4 + spread 
            label scenario_cover_4_label_h = label.new(bar_index, low, "scenario_cover_4 h", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_4_label_h)
        //
        if supporto_cover_trig_4 and scenario_cover_4_line_to_l == 0 and block_cover != "L"
            n_posizione := 10
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\": {6}, \"data\": {7} 
             \"epic\": \"{8}\", \"direction\": \"{9}\", \"size\": {10} {11} {12} {13}", "{", "{", current_timeframe, "true", "OPEN", str.tostring(n_posizione), 
             str.tostring(timenow), "{", titolo, "BUY", n_titoli_moltiplicatore_cover, "}", "}", "}"), alert.freq_once_per_bar)
            scenario_cover_4_line_to_l := 1, scenario_cover_4_ask_to_l := supporto_4 + spread 
            label scenario_cover_4_label_l = label.new(bar_index, low, "scenario_cover_4 l", color=positiveColor,  style=label.style_label_up, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_4_label_l)
        //Chiusure
        if scenario_cover_4_line_to_h == 1 and scenario_cover_4_line_to_h[1] == 1 and cover_4_higher_target_trig and high > scenario_cover_4_ask_to_h
            n_posizione := 9
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
             \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
            scenario_cover_4_line_to_h := 0, scenario_cover_4_ask_to_h  := 0
            label scenario_cover_4_close_label_h = label.new(bar_index, high, "close scenario_cover_4 h", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_4_close_label_h)
        //
        if scenario_cover_4_line_to_l == 1 and scenario_cover_4_line_to_l[1] == 1 and cover_4_lower_target_trig and high > scenario_cover_4_ask_to_l
            n_posizione := 10
            alert(str.format("{0} \"data\": {1} \"secret\": \"\", \"timeframe\": \"{2}\", \"real\": {3}, \"action\": \"{4}\", \"id\": \"{5}\", \"timenow\":{6}, 
             \"epic\": \"{7}\" {8} {9}", "{", "{", current_timeframe, "true", "CLOSE", str.tostring(n_posizione), str.tostring(timenow), titolo, "}", "}"), alert.freq_once_per_bar)
            scenario_cover_4_line_to_l := 0, scenario_cover_4_ask_to_l := 0
            label scenario_cover_4_close_label_l = label.new(bar_index, high, "close scenario_cover_4 l", color=negativeColor, style=label.style_label_down, textcolor=color.white, size=size.small, force_overlay = true)
            array.push(saved_labels, scenario_cover_4_close_label_l)
        //
        tot_position_scenario_cover_4 := scenario_cover_4_line_to_l + scenario_cover_4_line_to_h    
        if tot_position_scenario_cover_4 == 0 and cover_4_line //Chiusura della line di scenario bot quando non ci sono operazioni aperte
            cover_4_line := false 
        //
    // -------------------------------------}
    // -------------------------------------}
    // Reset supporti
// -----------------------------------------------------------{
    tot_position_cover := tot_position_scenario_cover_1 + tot_position_scenario_cover_2 + tot_position_scenario_cover_3 + tot_position_scenario_cover_4 + scenario_siffredi_cover_line
    var int last_cover_open = 0
    last_cover_open := tot_position_scenario_cover_4 > 0 ? 4 : tot_position_scenario_cover_3 > 0 ? 3 : tot_position_scenario_cover_2 > 0 ? 2 : tot_position_scenario_cover_1 > 0 ? 1 : 0    
    if tot_position_cover < tot_position_cover[1]
        if last_cover_open == 1 
            supporto_1 := bot 
            if bot_is_sup 
                supporto_2 := old_sup, supporto_3 := old_sup_1, supporto_4 := old_sup_2 
            else 
                supporto_2 := old_sup_1, supporto_3 := old_sup_2, supporto_4 := old_sup_3 
        else if last_cover_open == 2 
            supporto_2 := bot 
            if bot_is_sup 
                supporto_3 := old_sup, supporto_4 := old_sup_1 
            else 
                supporto_3 := old_sup_1, supporto_4 := old_sup_2 
        else if last_cover_open == 3 
            supporto_3 := bot 
            if bot_is_sup 
                supporto_4 := old_sup
            else 
                supporto_4 := old_sup_1 
        else if last_cover_open == 4 
            supporto_4 := bot 
    //
// -------------------------------------}
// -------------------------------------}
// Volume indicator
// ------------------------------------------------------------{
// Calcolo Volume profile e setting iniziali
// -----------------------------------------------------------{
levels                                  = array.new_float(cnum + 1)
for x = 0 to cnum by 1
    array.set(levels, x, bot + step * x)
array.clear(peak_level_ar)
array.clear(peak_level_perc)
array.clear(peak_level_perc_sma)
array.clear(peak_sma_level)
var int poc_2_index = 0
get_vol(y11, y12, y21, y22, height, vol) =>
    nz(math.max(math.min(math.max(y11, y12), math.max(y21, y22)) - math.max(math.min(y11, y12), math.min(y21, y22)), 0) * vol / height)
//
var int peak_count = 0
var line reg_line = na
var string costituzione_volume = na
var smoothed_lines_5 = array.new<line>(cnum - 1)
var smoothed_lines_2 = array.new<line>(cnum - 1)
var smoothed_lines_10 = array.new<line>(cnum - 1)
var float pearson_coeff_vol = na 
var int up_ar = na 
var int down_ar = na  
var volumes                             = array.new_float(cnum * 2, 0.)
var int start_bar = 0 
if barstate.islastconfirmedhistory
    start_bar := bar_index
if (barstate.isconfirmed and run > 0 ) or (barstate.islastconfirmedhistory) or (bar_index > start_bar and barstate.isconfirmed and na(poc_level) and start_bar != 0)
    run := run < 2 ? run + 1 : run 
    volumes                            := array.new_float(cnum * 2, 0.)
    for bars = 0 to bbars - 1 by 1
        body_top                        = math.max(close[bars], open[bars])
        body_bot                        = math.min(close[bars], open[bars])
        itsgreen                        = close[bars] >= open[bars]
        topwick                         = high[bars] - body_top
        bottomwick                      = body_bot - low[bars]
        body                            = body_top - body_bot
        bodyvol                         = body * volume[bars]           / (2 * topwick + 2 * bottomwick + body)
        topwickvol                      = 2 * topwick * volume[bars]    / (2 * topwick + 2 * bottomwick + body)
        bottomwickvol                   = 2 * bottomwick * volume[bars] / (2 * topwick + 2 * bottomwick + body)
        for x = 0 to cnum - 1 by 1
            array.set(volumes, x, array.get(volumes, x) + (itsgreen ? get_vol(array.get(levels, x), array.get(levels, x + 1), body_bot, body_top, body, bodyvol) : 0) + get_vol(array.get(levels, x), array.get(levels, x + 1), body_top, high[bars], topwick, topwickvol) / 2 + get_vol(array.get(levels, x), array.get(levels, x + 1), body_bot, low[bars], bottomwick, bottomwickvol) / 2)
            array.set(volumes, x + cnum, array.get(volumes, x + cnum) + (itsgreen ? 0 : get_vol(array.get(levels, x), array.get(levels, x + 1), body_bot, body_top, body, bodyvol)) + get_vol(array.get(levels, x), array.get(levels, x + 1), body_top, high[bars], topwick, topwickvol) / 2 + get_vol(array.get(levels, x), array.get(levels, x + 1), body_bot, low[bars], bottomwick, bottomwickvol) / 2)
    totalvols                           := array.new_float(cnum, 0.)
    for x = 0 to cnum - 1 by 1
        array.set(totalvols, x, array.get(volumes, x) + array.get(volumes, x + cnum))
    //
    int poc                             = array.indexof(totalvols, array.max(totalvols))
    poc_level                           := (array.get(levels, poc) + array.get(levels, poc + 1)) / 2    
    poc_perc                            := math.round(((poc_level - bot) / global_distance) * 100)
    // Aggiorno la percent reimpostandola con i valori iniziali per ripetere il monitoraggio senza valori estremi percent
    percent := percent_block
    // -------------------------------------}
    // Miglioramento delle zone liq in base ai massimi volumetrici
    // -----------------------------------------------------------{
    // Bot liq
    float new_bot_liq                   = bot_liq_shadow
    // Trova l'indice di livello corrispondente a bot_liq
    int bot_liq_index                   = 0
    for i = 0 to cnum - 1
        if array.get(levels, i) <= bot_liq_shadow and (i == cnum - 1 or array.get(levels, i + 1) > bot_liq_shadow)
            bot_liq_index               := i
            break
    for i = bot_liq_index to 0 // Controlla le barre dall'alto verso il basso per trovare volume assente
        if i < array.size(totalvols)
            if array.get(totalvols, i) == 0
                new_bot_liq             := array.get(levels, i)
                bot_liq_modified        := true
                bot_liq_index               := i
                break
    bot_liq := bot_liq_modified ? new_bot_liq : bot_liq_shadow
    // Ottimizzazione aggiuntiva per bot_liq: sali fino al picco di volume
    if bot_liq_index < cnum - 1 and bot_liq_index > 0
        float max_vol = array.get(totalvols, bot_liq_index)
        int max_index = bot_liq_index
        for i = bot_liq_index + 1 to cnum - 1
            float current_vol = array.get(totalvols, i)
            if current_vol > max_vol
                max_vol := current_vol
                max_index := i
                bot_liq := (array.get(levels, i) + array.get(levels, i + 1)) / 2
                bot_liq_index               := i
            else
                break
    // Top Liq
    float new_top_liq = top_liq_shadow
    // Trova l'indice di livello corrispondente a top_liq
    int top_liq_index = cnum - 1
    for i = 0 to cnum - 1
        if array.get(levels, i) <= top_liq_shadow and (i == cnum - 1 or array.get(levels, i + 1) > top_liq_shadow)
            top_liq_index := i
            break
    for i = top_liq_index to cnum - 1 // Controlla le barre dal basso verso l'alto per trovare volume assente
        if i < array.size(totalvols)
            if array.get(totalvols, i) == 0
                new_top_liq := array.get(levels, i)
                top_liq_modified := true
                top_liq_index               := i
                break
    top_liq := top_liq_modified ? new_top_liq : top_liq_shadow
    // Ottimizzazione aggiuntiva: scendi fino al picco di volume
    int current_index = 0
    for i = 0 to cnum - 1
        if array.get(levels, i) <= top_liq and (i == cnum - 1 or array.get(levels, i + 1) > top_liq)
            current_index := i
            break
    // Cerca il picco locale scendendo
    if current_index > 0
        float max_vol = array.get(totalvols, current_index)
        int max_index = current_index
        for i = current_index - 1 to 0
            float current_vol = array.get(totalvols, i)
            if current_vol > max_vol
                max_vol := current_vol
                max_index := i
                top_liq := (array.get(levels, i) + array.get(levels, i + 1)) / 2
                top_liq_index               := i
            else
                break
    bot_liq_perc                        := math.round(((bot_liq - bot) / global_distance) * 100)
    top_liq_perc                        := math.round(((top_liq - bot) / global_distance) * 100)
    //
    // -------------------------------------}
    //Percent study
    // -----------------------------------------------------------{
    totalmax                            = array.sum(totalvols) * percent / 100.
    va_total                            = array.get(totalvols, poc)
    int up                              = poc
    int down                            = poc
    for x = 0 to cnum - 1 by 1
        if va_total >= totalmax
            break
        uppervol                        = up < cnum - 1 ? array.get(totalvols, up + 1) : 0.
        lowervol                        = down > 0      ? array.get(totalvols, down - 1) : 0.
        if (uppervol == 0 and lowervol == 0 ) 
            break

        if uppervol >= lowervol
            va_total += uppervol
            up += 1
            up
        else
            va_total += lowervol
            down -= 1
            down
    // Determina zone Fibonacci dei livelli VA
    float vah_perc_temp = up * 100 / cnum
    float val_perc_temp = down * 100 / cnum
    bool switch_vah = false
    int fib_val_temp = val_perc_temp <= fib_perc_1 ? 1 : val_perc_temp <= fib_perc_2 ? 2 : val_perc_temp <= fib_perc_3 ? 3 : val_perc_temp <= fib_perc_4 ? 4 : val_perc_temp <= fib_perc_5 ? 5 : val_perc_temp <= fib_perc_6 ? 6 : 6
    int fib_vah_temp = vah_perc_temp <= fib_perc_1 ? 1 : vah_perc_temp <= fib_perc_2 ? 2 : vah_perc_temp <= fib_perc_3 ? 3 : vah_perc_temp <= fib_perc_4 ? 4 : vah_perc_temp <= fib_perc_5 ? 5 : vah_perc_temp <= fib_perc_6 ? 6 : 6
    // Calcola differenza Fibonacci
    first_distance_va := fib_vah_temp - fib_val_temp
    if first_distance_va > 3
        switch_vah := true, percent -= 5
    if first_distance_va < 3
        switch_vah := true, percent += 5  
    // Ricalcola VA se percent è cambiato per ottimizzazione livelli VA iniziali
    if switch_vah
        switch_vah := false
        totalmax := array.sum(totalvols) * percent / 100.
        va_total := array.get(totalvols, poc)
        up := poc
        down := poc
        for x = 0 to cnum - 1 by 1
            if va_total >= totalmax
                break
            uppervol = up < cnum - 1 ? array.get(totalvols, up + 1) : 0.
            lowervol = down > 0 ? array.get(totalvols, down - 1) : 0.
            if uppervol == 0 and lowervol == 0
                break
            if uppervol >= lowervol
                va_total += uppervol, up += 1
            else
                va_total += lowervol, down -= 1
    //
    // -------------------------------------}
    // Sinusoide volumetrica smussata
    // -----------------------------------------------------------{
    // SMOOTHING BIDIREZIONALE - MULTIPLI PERIODI
    // Array per i risultati
    smoothed_down = array.new_float(cnum, 0.)
    smoothed_up = array.new_float(cnum, 0.)
    smoothed_final_2 = array.new_float(cnum, 0.)
    smoothed_final_5 = array.new_float(cnum, 0.)
    smoothed_final_10 = array.new_float(cnum, 0.)
    max_sma_values = array.new_float(cnum, 0.)
    max_sma_values_breve = array.new_float(cnum, 0.)

    // SMA 2
    for i = cnum - 1 to 0
        float sum = 0.
        int count = 0
        for j = 0 to 1
            int idx = i - j
            if idx >= 0
                sum += array.get(totalvols, idx)
                count += 1
        array.set(smoothed_down, i, count > 0 ? sum / count : array.get(totalvols, i))
    for i = 0 to cnum - 1
        float sum = 0.
        int count = 0
        for j = 0 to 1
            int idx = i + j
            if idx < cnum
                sum += array.get(totalvols, idx)
                count += 1
        array.set(smoothed_up, i, count > 0 ? sum / count : array.get(totalvols, i))
    for i = 0 to cnum - 1
        array.set(smoothed_final_2, i, (array.get(smoothed_down, i) + array.get(smoothed_up, i)) / 2)
    // SMA 5
    for i = cnum - 1 to 0
        float sum = 0.
        int count = 0
        for j = 0 to 4
            int idx = i - j
            if idx >= 0
                sum += array.get(totalvols, idx)
                count += 1
        array.set(smoothed_down, i, count > 0 ? sum / count : array.get(totalvols, i))
    for i = 0 to cnum - 1
        float sum = 0.
        int count = 0
        for j = 0 to 4
            int idx = i + j
            if idx < cnum
                sum += array.get(totalvols, idx)
                count += 1
        array.set(smoothed_up, i, count > 0 ? sum / count : array.get(totalvols, i))
    for i = 0 to cnum - 1
        array.set(smoothed_final_5, i, (array.get(smoothed_down, i) + array.get(smoothed_up, i)) / 2)
    // SMA 10
    for i = cnum - 1 to 0
        float sum = 0.
        int count = 0
        for j = 0 to 9
            int idx = i - j
            if idx >= 0
                sum += array.get(totalvols, idx)
                count += 1
        array.set(smoothed_down, i, count > 0 ? sum / count : array.get(totalvols, i))
    for i = 0 to cnum - 1
        float sum = 0.
        int count = 0
        for j = 0 to 9
            int idx = i + j
            if idx < cnum
                sum += array.get(totalvols, idx)
                count += 1
        array.set(smoothed_up, i, count > 0 ? sum / count : array.get(totalvols, i))
    for i = 0 to cnum - 1
        array.set(smoothed_final_10, i, (array.get(smoothed_down, i) + array.get(smoothed_up, i)) / 2)
    for i = 0 to cnum - 1
        float val_2 = array.get(smoothed_final_2, i)
        float val_5 = array.get(smoothed_final_5, i)
        float val_10 = array.get(smoothed_final_10, i)  
        array.set(max_sma_values, i, math.max(val_2, math.max(val_5, val_10)))
        array.set(max_sma_values_breve, i, math.max(val_2, val_5))
    // CALCOLO REGRESSIONE
    float sum_x = 0.0
    float sum_y = 0.0
    float sum_xy = 0.0
    float sum_x2 = 0.0
    float n = cnum
    int start_offset = 23 
    int max_width = 100  
    for j = 0 to cnum - 1
        x = j
        y = array.get(smoothed_final_2, j)
        sum_x += x
        sum_y += y
        sum_xy += x * y
        sum_x2 += x * x
    float slope = (n * sum_xy - sum_x * sum_y) / (n * sum_x2 - sum_x * sum_x)
    float intercept = (sum_y - slope * sum_x) / n
    float max_vol = array.max(totalvols)
    // Calcola posizioni X per regressione
    float x_reg_start = max_vol > 0 ? (intercept / max_vol) * max_width : 0
    float x_reg_end = max_vol > 0 ? ((slope * (cnum - 1) + intercept) / max_vol) * max_width : 0
    costituzione_volume := x_reg_start > x_reg_end ? "Crescente" : x_reg_start < x_reg_end ? "Decrescente" : "Stabile"
    // Calcola valori della regressione per ogni punto
    reg_values = array.new_float(cnum, 0.)
    for i = 0 to cnum - 1
        array.set(reg_values, i, slope * i + intercept)
    // Calcola medie
    float mean_reg = array.avg(reg_values)
    float mean_vols = array.avg(totalvols)
    // Calcola numeratore e denominatori per Pearson
    float numerator = 0.0
    float denom_reg = 0.0
    float denom_vols = 0.0
    for i = 0 to cnum - 1
        float diff_reg = array.get(reg_values, i) - mean_reg
        float diff_vols = array.get(totalvols, i) - mean_vols
        numerator += diff_reg * diff_vols
        denom_reg += diff_reg * diff_reg
        denom_vols += diff_vols * diff_vols
    float first_reg_value = intercept  // quando i=0
    float last_reg_value = slope * (cnum - 1) + intercept  // quando i=cnum-1
    bool trend_crescente = last_reg_value < first_reg_value
    pearson_coeff_ = numerator / math.sqrt(denom_reg * denom_vols)
    pearson_coeff_vol := trend_crescente ? pearson_coeff_ : -pearson_coeff_ 
    // NUOVO: IDENTIFICA PICCHI SMA2
    peak_count := 0
    for i = 1 to cnum - 2 
        float sma2 = array.get(smoothed_final_2, i)
        float sma2_prev = array.get(smoothed_final_2, i - 1)
        float sma2_next = array.get(smoothed_final_2, i + 1)
        float sma5 = array.get(smoothed_final_5, i)
        float sma10 = array.get(smoothed_final_10, i)
        if sma2 > sma5 and sma2 > sma10 and sma2 > sma2_prev and sma2 > sma2_next
            array.push(peak_level_perc_sma, i)
            array.push(peak_sma_level, sma2)
            peak_count += 1
    var zone_starts_down = array.new_int(20)
    var zone_ends_down = array.new_int(20)
    var zone_starts_up = array.new_int(20)
    var zone_ends_up = array.new_int(20)
    int zone_count_down = 0
    int zone_count_up = 0
    bool in_zone_down = false
    bool in_zone_up = false
    for i = 0 to cnum - 1
        float reg_value = slope * i + intercept
        float max_sma = array.get(max_sma_values, i)
        // Zone DOWN
        if not in_zone_down and max_sma < reg_value 
            array.set(zone_starts_down, zone_count_down, i)
            in_zone_down := true
        else if in_zone_down and max_sma > reg_value
            array.set(zone_ends_down, zone_count_down, i - 1)
            zone_count_down += 1
            in_zone_down := false
        // Zone UP
        float max_sma_breve = array.get(max_sma_values_breve, i)
        float sma_10  = array.get(smoothed_final_10, i)
        if not in_zone_up and max_sma_breve > reg_value and max_sma_breve > sma_10
            array.set(zone_starts_up, zone_count_up, i)
            in_zone_up := true
        else if in_zone_up and (max_sma_breve < reg_value or max_sma_breve < sma_10)
            array.set(zone_ends_up, zone_count_up, i - 1)
            zone_count_up += 1
            in_zone_up := false
    if in_zone_down
        array.set(zone_ends_down, zone_count_down, cnum - 1)
        zone_count_down += 1
    if in_zone_up
        array.set(zone_ends_up, zone_count_up, cnum - 1)
        zone_count_up += 1
    // DISEGNA LINEA DI REGRESSIONE
    line.delete(reg_line)
    reg_line := line.new(
         bar_index + start_offset + int(x_reg_start), bot,
         bar_index + start_offset + int(x_reg_end), top,
         color=color.new(color.white, 50),
         width=3,
         style=line.style_dashed, force_overlay = true)
    array.clear(peak_lines)
    bool poc_is_low = false 
    bool poc_is_up = false 
    if peak_count > 0
        for p = 0 to peak_count - 1
            int idx = array.get(peak_level_perc_sma, p)
            float val = array.get(peak_sma_level, p)
            float price_peak = (array.get(levels, idx) + array.get(levels, idx + 1)) / 2
            float reg_value = slope * idx + intercept
            color line_color = color.new(color.red, 0) 
            int poc_width_ = 1
            if math.abs(price_peak - poc_level) < step / 2  
                line_color := color.new(color.blue, 0)  
                poc_width_ := 2
                if p == 0
                    poc_is_low := true 
                if p == peak_count - 1
                    poc_is_up := true
            else if val >= reg_value
                line_color := color.new(color.green, 0) 
            array.unshift(peak_level_perc, idx)
            array.unshift(peak_level_ar, price_peak)
            array.unshift(peak_lines, line.new(
                     bar_index - bbars,  
                     price_peak, 
                     bar_index + 23, 
                     price_peak,    
                     color=line_color,
                     width= poc_width_,
                     style=line.style_dashed, force_overlay = true))
        int first_low_zone_start = 0
        if poc_is_low
            if array.size(zone_starts_up) > 0
                first_low_zone_start := array.get(zone_starts_up, 0)
            if first_low_zone_start < poc 
                poc_width_ = 1
                price_peak_poc_low = (array.get(levels, first_low_zone_start) + array.get(levels, first_low_zone_start + 1)) / 2
                array.unshift(peak_level_perc, first_low_zone_start)
                array.unshift(peak_sma_level,array.get(smoothed_final_2,first_low_zone_start))
                array.unshift(peak_level_ar, price_peak_poc_low)
                array.unshift(peak_lines, line.new(
                         bar_index - bbars, 
                         price_peak_poc_low, 
                         bar_index + 23,
                         price_peak_poc_low,
                         color=color.green,
                         width=poc_width_,
                         style=line.style_dashed, force_overlay = true))
        int last_low_zone_start = cnum - 1
        if poc_is_up 
            if array.size(zone_ends_up) > 0
                last_low_zone_start := array.get(zone_ends_up, array.size(zone_ends_up) - 1)
            if last_low_zone_start > poc 
                poc_width_ = 1
                price_peak_poc_low = (array.get(levels, last_low_zone_start) + array.get(levels, last_low_zone_start - 1)) / 2
                array.push(peak_level_perc, last_low_zone_start)
                array.push(peak_sma_level,array.get(smoothed_final_2,last_low_zone_start))
                array.push(peak_level_ar, price_peak_poc_low)
                array.push(peak_lines, line.new(
                         bar_index - bbars,
                         price_peak_poc_low,   
                         bar_index + 23,    
                         price_peak_poc_low,     
                         color=color.green,
                         width=poc_width_,
                         style=line.style_dashed, force_overlay = true))
    var no_vol_boxes = array.new<box>(20)
    var no_vol_labels = array.new<label>(20)
    
    // Pulisci precedenti
    for idx = 0 to 19
        box.delete(array.get(no_vol_boxes, idx))
        label.delete(array.get(no_vol_labels, idx))
    if zone_count_down > 0
        for z = 0 to zone_count_down - 1
            int i_start = array.get(zone_starts_down, z)
            int i_end = array.get(zone_ends_down, z)
            float price_start = array.get(levels, i_start)
            float price_end = array.get(levels, i_end + 1)         
            array.set(no_vol_boxes, z, box.new(
                 bar_index,
                 price_start,
                 bar_index + start_offset,
                 price_end,
                 bgcolor=color.new(color.yellow, 90),
                 border_width=1,
                 border_color= color.new(color.red,100), force_overlay = true))

        //
    // -------------------------------------}
    // Settaggio finale livelli VA
    // -----------------------------------------------------------{
    vah_perc_temp := up * 100 / cnum
    val_perc_temp := down * 100 / cnum
    switch_vah := false
    // Determina zone Fibonacci
    fib_val_temp := val_perc_temp <= fib_perc_1 ? 1 : val_perc_temp <= fib_perc_2 ? 2 : val_perc_temp <= fib_perc_3 ? 3 : val_perc_temp <= fib_perc_4 ? 4 : val_perc_temp <= fib_perc_5 ? 5 : val_perc_temp <= fib_perc_6 ? 6 : 6
    fib_vah_temp := vah_perc_temp <= fib_perc_1 ? 1 : vah_perc_temp <= fib_perc_2 ? 2 : vah_perc_temp <= fib_perc_3 ? 3 : vah_perc_temp <= fib_perc_4 ? 4 : vah_perc_temp <= fib_perc_5 ? 5 : vah_perc_temp <= fib_perc_6 ? 6 : 6
    // Determino le zone di Fibonacci provvisorie per il ricalcolo ottimizzato delle zone VA
    first_distance_va := fib_vah_temp - fib_val_temp
    // Ottimizzazione VAH basata sui picchi nella stessa fascia Fibonacci
    if array.size(peak_level_ar) > 0
        float current_vah_vol = array.get(totalvols, up)
        int best_vah_index = up
        float best_vah_vol = current_vah_vol
        for i = 0 to array.size(peak_level_ar) - 1
            float peak = array.get(peak_level_ar, i)
            int peak_perc = array.get(peak_level_perc, i)
            int peak_fib = peak_perc <= fib_perc_1 ? 1 : peak_perc <= fib_perc_2 ? 2 : peak_perc <= fib_perc_3 ? 3 : peak_perc <= fib_perc_4 ? 4 : peak_perc <= fib_perc_5 ? 5 : peak_perc <= fib_perc_6 ? 6 : 6
            int peak_index = 0
            for j = 0 to cnum - 1
                if peak >= array.get(levels, j) and peak < array.get(levels, j + 1)
                    peak_index := j
                    break
            if peak_fib == fib_vah_temp and peak_index > poc and peak_index != poc
                float peak_vol = array.get(totalvols, peak_index)
                if peak_vol > best_vah_vol
                    best_vah_index := peak_index
                    best_vah_vol := peak_vol
        up := best_vah_index
    // Ottimizzazione VAL basata sui picchi nella stessa fascia Fibonacci
    if array.size(peak_level_ar) > 0
        float current_val_vol = array.get(totalvols, down)
        int best_val_index = down
        float best_val_vol = current_val_vol
        for i = 0 to array.size(peak_level_ar) - 1
            float peak = array.get(peak_level_ar, i)
            int peak_perc = array.get(peak_level_perc, i)
            int peak_fib = peak_perc <= fib_perc_1 ? 1 : 
                         peak_perc <= fib_perc_2 ? 2 : 
                         peak_perc <= fib_perc_3 ? 3 : 
                         peak_perc <= fib_perc_4 ? 4 : 
                         peak_perc <= fib_perc_5 ? 5 : 
                         peak_perc <= fib_perc_6 ? 6 : 6
            int peak_index = 0
            for j = 0 to cnum - 1
                if peak >= array.get(levels, j) and peak < array.get(levels, j + 1)
                    peak_index := j
                    break
            if peak_fib == fib_val_temp and peak_index < poc and peak_index != poc
                float peak_vol = array.get(totalvols, peak_index)
                if peak_vol > best_val_vol
                    best_val_index := peak_index
                    best_val_vol := peak_vol
        down := best_val_index
    if up < cnum - 1 // Ottimizzazione finale: sposta VAH verso il picco volumetrico superiore
        float current_vol = array.get(totalvols, up)
        int peak_index = up
        for i = up + 1 to cnum - 1
            float next_vol = array.get(totalvols, i)
            if next_vol > current_vol
                current_vol := next_vol
                peak_index := i
            else
                break
        up := peak_index
    if down > 0 // Ottimizzazione finale: sposta VAL verso il picco volumetrico inferiore
        float current_vol = array.get(totalvols, down)
        int peak_index = down
        for i = down - 1 to 0
            float next_vol = array.get(totalvols, i)
            if next_vol > current_vol
                current_vol := next_vol
                peak_index := i
            else
                break
        down := peak_index
    // Solo dopo tutte le ottimizzazioni, ricalcolo i livelli VAH e VAL
    vah_level                           := up < cnum - 1 ? (array.get(levels, up) + array.get(levels, up + 1)) / 2 : array.get(levels, up)
    val_level                           := down > 0 ? (array.get(levels, down) + array.get(levels, down + 1)) / 2 : array.get(levels, down)
    // -------------------------------------}
    //Ottimizzazione livelli va e ricerca livello poc 2
    // ------------------------------------------------------------{
    float ext_poc_vol                   = 0
    int levels_size                     = array.size(levels)
    int totalvols_size                  = array.size(totalvols)
    float temp_poc_second_level         = na
    int vah_shadow_index = up
    bool found_valley = false
    if up + 2 < cnum - 1
        for i = up + 1 to cnum - 2
            float prev = array.get(sma_volumes, i - 1)
            float curr = array.get(sma_volumes, i)
            float next = array.get(sma_volumes, i + 1)
            if curr < prev and curr < next
                vah_shadow_index := i, found_valley := true
                break
    if not found_valley
        while vah_shadow_index + 1 < totalvols_size
            if array.get(totalvols, vah_shadow_index) > array.get(totalvols, vah_shadow_index + 1)
                vah_shadow_index += 1
            else
                break
    int val_shadow_index = down
    found_valley := false
    if down - 2 > 0
        for i = down - 1 to 1
            float prev = array.get(sma_volumes, i - 1)
            float curr = array.get(sma_volumes, i)
            float next = array.get(sma_volumes, i + 1)
            if curr < prev and curr < next
                val_shadow_index := i, found_valley := true
                break
    if not found_valley
        while val_shadow_index > 0
            if array.get(totalvols, val_shadow_index) > array.get(totalvols, val_shadow_index - 1)
                val_shadow_index -= 1
            else
                break
    if val_shadow_index > 0
        for i = 0 to math.min(val_shadow_index - 1, totalvols_size - 1)
            if i + 1 < levels_size
                float vol = array.get(totalvols, i)
                float candidate_level = (array.get(levels, i) + array.get(levels, i + 1)) / 2
                if vol > ext_poc_vol and candidate_level < top_liq and candidate_level > bot_liq
                    ext_poc_vol := vol, temp_poc_second_level := candidate_level
    if vah_shadow_index + 1 < totalvols_size
        int start_i = vah_shadow_index + 1
        int end_i = totalvols_size - 1
        if start_i <= end_i
            for i = start_i to end_i
                if i + 1 < levels_size
                    float vol = array.get(totalvols, i)
                    float candidate_level = (array.get(levels, i) + array.get(levels, i + 1)) / 2
                    if vol > ext_poc_vol and (candidate_level < top_liq or top_liq_perc < 75) and (candidate_level > bot_liq)
                        ext_poc_vol := vol, temp_poc_second_level := candidate_level
    if not na(temp_poc_second_level)
        poc_second_level                := temp_poc_second_level   
        for i = 0 to cnum - 1
            if array.get(levels, i) <= poc_second_level and (i == cnum - 1 or array.get(levels, i + 1) > poc_second_level)
                poc_2_index               := i
                break
    //
    // -------------------------------------}
    // Gestione colorazione poc
    // -----------------------------------------------------------{
    // Determina se il POC è rialzista o ribassista basandosi sul volume
    float poc_buy_volume                = array.get(volumes, poc)
    float poc_sell_volume               = array.get(volumes, poc + cnum)

    if poc_buy_volume >= poc_sell_volume // Maggior volume di acquisto
        poc_color := color.blue, poc_is_buy := true 
    else if poc_sell_volume > poc_buy_volume // Maggior volume di vendita
        poc_color := color.orange, poc_is_buy := false 
    //
    // Determina se il POC_2 è rialzista o ribassista basandosi sul volume
    if na(poc_2_index) or poc_2_index < 0
        poc_2_index := poc
    //
    float poc_2_buy_volume          = array.get(volumes, poc_2_index)
    float poc_2_sell_volume         = array.get(volumes, poc_2_index + cnum)
    if poc_2_buy_volume >= poc_2_sell_volume // Maggior volume di acquisto
        poc_2_color := color.blue , poc_2_is_buy := true 
    else if poc_2_sell_volume > poc_2_buy_volume // Maggior volume di vendita
        poc_2_color := color.orange, poc_2_is_buy := false
    //
    // -------------------------------------}
// -------------------------------------}
// Definizione label - line e valori top/bot delle linee di poc - val e vah
// ------------------------------------------------------------{
    //Settaggi principali
    // -----------------------------------------------------------{
    // Crea array con indici da escludere
    array<int> exclude_indices = array.new_int()
    array.push(exclude_indices, top_liq_index)
    array.push(exclude_indices, bot_liq_index)
    array.push(exclude_indices, down)   
    array.push(exclude_indices, up)      
    array.push(exclude_indices, poc)
    array.push(exclude_indices, poc_2_index) 

    // Rimuovi picchi con indici da escludere
    if array.size(peak_level_perc) > 0
        for i = array.size(peak_level_perc) - 1 to 0
            if array.includes(exclude_indices, array.get(peak_level_perc, i))
                line.delete(array.get(peak_lines, i))
                array.remove(peak_lines, i)
                array.remove(peak_level_ar, i)
                array.remove(peak_level_perc, i)
    //
    up_ar := up 
    down_ar := down 
    mid_distance                        = global_distance / 2
    poc_bot_level                       := bot + mid_distance 

    vah_perc                            := math.round(((vah_level - bot) / global_distance) * 100)
    poc_2_perc                          := math.round(((poc_second_level - bot) / global_distance) * 100)
    val_perc                            := math.round(((val_level - bot) / global_distance) * 100)

    vol_distance                        = vah_level - val_level
    vol_distance_perc                   := vah_perc - val_perc
    vol_value                           := vah_level - val_level
    // -------------------------------------}

    //Riadattamento di posizioni cover (aggiunto successivamente per recuperare media del volume corretta per distanziare le posizioni switch_resistenza//Riordino supporti e resistenze quando viene impostato un nuovo pivot e quel pivot corrisponde a sup/res attuale)
    // -----------------------------------------------------------{

    piv_distance_1                      := piv_distance   * incremento_distanza_pivot
    piv_distance_2                      := piv_distance_1 * incremento_distanza_pivot
    piv_distance_3                      := piv_distance_2 * incremento_distanza_pivot
    piv_distance_1_res                      := piv_distance_res   * incremento_distanza_pivot
    piv_distance_2_res                      := piv_distance_1_res * incremento_distanza_pivot
    piv_distance_3_res                      := piv_distance_2_res * incremento_distanza_pivot

[tot_sup_b, old_sup_b, old_sup_1_b, old_sup_2_b, old_sup_3_b, tot_res_b, old_res_b, old_res_1_b, old_res_2_b, old_res_3_b] = M2.scalare_sistema_cover(barstate.isconfirmed, a_sup, a_res, bot_is_sup, bot, piv_distance, piv_distance_1, piv_distance_2, piv_distance_3, top, piv_distance_1_res, piv_distance_2_res, piv_distance_3_res)
if barstate.isconfirmed 
    tot_sup     := tot_sup_b  
    old_sup     := old_sup_b  
    old_sup_1   := old_sup_1_b
    old_sup_2   := old_sup_2_b
    old_sup_3   := old_sup_3_b
    tot_res     := tot_res_b  
    old_res     := old_res_b  
    old_res_1   := old_res_1_b
    old_res_2   := old_res_2_b
    old_res_3   := old_res_3_b
//
    // -------------------------------------}
    //Plottaggi
    // -----------------------------------------------------------{
//Plot istogramma
M2.drawVolumeHistogram(run, top, bot, cnum, volumes, vol_bars, levels, down_ar, up_ar)        
//Plot dei livelli vah, poc, sup, res
M2.plotlineSystem(run, bbars, poc_level, poc_second_level, top, bot,  vah_level, val_level, bot_liq, top_liq, old_res, old_sup, old_res_1, old_sup_1,  old_res_2, old_sup_2, old_res_3, old_sup_3, poc_color, poc_2_color, negativeColor, positiveColor, poc_width, val_width, ext_width, bot_is_sup)
// -------------------------------------}
// -------------------------------------}
// LR
// -----------------------------------------------------------{
//Utilizzo una lr per la gestione del trend, al momento risulta poco utilizzato rispetto alle sue reali potenzialità, il pearson è uno strumento fondamentale per la dinamizzazione dei flussi verso i rispettivi target
lengthInput_lr = bbars
sourceInput_lr = close
//Calcolo slope LR
[s_lr, a_lr, i_lr] = M2.calcSlope_lr(sourceInput_lr, lengthInput_lr, run)
startPrice_lr = i_lr + s_lr * (lengthInput_lr - 1)
endPrice_lr   = i_lr
if run > 0
    if na(baseLine_lr) and not na(startPrice_lr)
        baseLine_lr                     := line.new(bar_index - lengthInput_lr + 1, startPrice_lr, bar_index, endPrice_lr, width=1, color=color.new(color.blue, 50), force_overlay = true)
    else
        if not na(startPrice_lr)
            line.set_xy1(baseLine_lr, bar_index - lengthInput_lr + 1, startPrice_lr)
            line.set_xy2(baseLine_lr, bar_index, endPrice_lr)
    //
[stdDev_lr, pearsonR_lr, upDev_lr, dnDev_lr] = M2.calcDev_lr(sourceInput_lr, lengthInput_lr, s_lr, a_lr, i_lr, run)
pearson := run > 0 ? pearsonR_lr : na
upperStartPrice_lr := run > 0 ? startPrice_lr + (useUpperDevInput_lr ? upperMultInput_lr * stdDev_lr : upDev_lr)   : na  
upperEndPrice_lr   := run > 0 ? endPrice_lr   + (useUpperDevInput_lr ? upperMultInput_lr * stdDev_lr : upDev_lr)   : na  
lowerStartPrice_lr := run > 0 ? startPrice_lr + (useLowerDevInput_lr ? -lowerMultInput_lr * stdDev_lr : -dnDev_lr) : na
lowerEndPrice_lr   := run > 0 ? endPrice_lr   + (useLowerDevInput_lr ? -lowerMultInput_lr * stdDev_lr : -dnDev_lr) : na
    //
float trend_lr = math.sign(startPrice_lr - endPrice_lr)
// LR alternativa con deviazioni personalizzate
upperStartPrice_lr_dev := run > 0 ? startPrice_lr + upDev_lr : na    
upperEndPrice_lr_dev   := run > 0 ? endPrice_lr + upDev_lr   : na
lowerStartPrice_lr_dev := run > 0 ? startPrice_lr - dnDev_lr : na
lowerEndPrice_lr_dev   := run > 0 ? endPrice_lr - dnDev_lr   : na

if run > 0 
    if na(upper_lr) and not na(upperStartPrice_lr)
        upper_lr := line.new(bar_index - lengthInput_lr + 1, upperStartPrice_lr, bar_index, upperEndPrice_lr, width=1, color=color.new(colorUpper_lr, 20), force_overlay = true)
    else
        if not na(upperStartPrice_lr)
            line.set_xy1(upper_lr, bar_index - lengthInput_lr + 1, upperStartPrice_lr)
            line.set_xy2(upper_lr, bar_index, upperEndPrice_lr)
        //
    if na(lower_lr) and not na(lowerStartPrice_lr)
        lower_lr := line.new(bar_index - lengthInput_lr + 1, lowerStartPrice_lr, bar_index, lowerEndPrice_lr, width=1, color=color.new(colorLower_lr, 20), force_overlay = true)
    else
        if not na(lowerStartPrice_lr)
            line.set_xy1(lower_lr, bar_index - lengthInput_lr + 1, lowerStartPrice_lr)
            line.set_xy2(lower_lr, bar_index, lowerEndPrice_lr)
        //
    if na(upper_lr_dev) and not na(upperStartPrice_lr_dev)
        upper_lr_dev := line.new(bar_index - lengthInput_lr + 1, upperStartPrice_lr_dev, bar_index, upperEndPrice_lr_dev, width=1, extend=extend.none, color=color.new(colorUpper_lr, 20), force_overlay = true)
    else
        if not na(upperStartPrice_lr_dev)
            line.set_xy1(upper_lr_dev, bar_index - lengthInput_lr + 1, upperStartPrice_lr_dev)
            line.set_xy2(upper_lr_dev, bar_index, upperEndPrice_lr_dev)
    if na(lower_lr_dev) and not na(lowerStartPrice_lr_dev)
        lower_lr_dev := line.new(bar_index - lengthInput_lr + 1, lowerStartPrice_lr_dev, bar_index, lowerEndPrice_lr_dev, width=1, extend=extend.none, color=color.new(colorLower_lr, 20), force_overlay = true)
    else
        if not na(lowerStartPrice_lr_dev)
            line.set_xy1(lower_lr_dev, bar_index - lengthInput_lr + 1, lowerStartPrice_lr_dev)
            line.set_xy2(lower_lr_dev, bar_index, lowerEndPrice_lr_dev)
    if not na(upper_lr) and not na(upper_lr_dev)
        linefill.new(upper_lr, upper_lr_dev, color = colorUpper_lr_dev)
    if not na(lower_lr_dev) and not na(lower_lr)
        linefill.new(lower_lr_dev, lower_lr, color = colorLower_lr_dev)
//
// Calcola di perc e pendenze
trend_up := endPrice_lr >= startPrice_lr and run > 0 ? true : false

//
percent_change = run > 0 ? (endPrice_lr - startPrice_lr) * 100 / math.abs(startPrice_lr)  : na 
real_pearson   = trend_up ? pearson : -pearson
lr_distance    = run > 0 ? upperStartPrice_lr - lowerStartPrice_lr                        : na    
if barstate.isconfirmed        
    lr_vol_perc   := run > 0 ? 100 - (((global_distance - lr_distance)/global_distance)*100)  : na   
    lr_perc       := run > 0 ? math.round(((endPrice_lr - bot) / global_distance) * 100)      : na       
    lower_lr_perc := run > 0 ? math.round(((lowerEndPrice_lr - bot) / global_distance) * 100) : na
    upper_lr_perc := run > 0 ? math.round(((upperEndPrice_lr - bot) / global_distance) * 100) : na
// -------------------------------------}
// Ema per identificare la zona di prezzo
// -----------------------------------------------------------{

var int ema_perc = na
// Chiamata della funzione
[_val_is_in_buy, _vah_is_in_buy, _poc_is_in_buy, _poc_2_is_in_buy, _bot_liq_is_in_buy, _act_sup_is_in_buy, _ema_over_lr, _ema_perc] = M2.check_buy_conditions(upperStartPrice_lr, upperEndPrice_lr, bbars, bot, global_distance, run, val_level, vah_level, poc_level, poc_second_level, bot_liq, actual_supporto, lenght_ema)
if barstate.isconfirmed and run > 0
    val_is_in_buy       := _val_is_in_buy    
    vah_is_in_buy       := _vah_is_in_buy    
    poc_is_in_buy       := _poc_is_in_buy    
    poc_2_is_in_buy     := _poc_2_is_in_buy  
    bot_liq_is_in_buy   := _bot_liq_is_in_buy
    act_sup_is_in_buy   := _act_sup_is_in_buy
    ema_perc            := _ema_perc
    ema_over_lr         := _ema_over_lr
    //
// -------------------------------------}
// Aggiustamento Break durante l'inizializzazione
// -----------------------------------------------------------{
// Aggiustamento inizializzazione breakout
if barstate.islastconfirmedhistory
    if up_breakout
        for i = 1 to bar_breakout
            if low[i] < poc_level
                up_breakout                     := false 
                bot_in_up_break_out             := na
                distanza_break_out_up           := na
    if down_breakout
        for i = 1 to bar_breakout_down
            if high[i] > poc_level
                down_breakout                   := false 
                top_in_down_break_out           := na
                distanza_break_out_down         := na
//
var bool scenario_actual_over_bot_pattern = false 
// -------------------------------------}
// Market analisi 
// -----------------------------------------------------------{
// Analisi generale di mercato 
old_sup_perc = math.round(((old_sup - bot) / global_distance) * 100)

var bool figura_poc_to_bot_target_low = false 
if (run > 0 and barstate.isconfirmed) or (run > 0 and barstate.islastconfirmedhistory)
    //Dichiarazione di bool persistenti
    var bool figura_val_to_bot_target_low = false 
    var bool figura_val_to_bot_target = false 
    var bool figura_poc_to_bot_target = false 
    var bool figura_vah_to_bot_target = false 
    var bool figura_vah_to_bot_target_low = false 
    var bool figura_bot_liq = false 
    var bool figura_bot_liq_low = false 
    var bool figura_bot = false 
    var bool figura_bot_low = false 
    var bool figura_poc_2_to_bot_target_over_poc = false
    var bool figura_poc_2_to_bot_target_under_poc = false
    var bool figura_poc_2_to_bot_target_low_over_poc = false
    var bool figura_poc_2_to_bot_target_low_under_poc = false
    break_with_res := false 
    //Stringhe d'ingresso con run == 1 
    market := run == 1 and bot_is_sup and not trend_up ? "Fall Accumula Liq" : run == 1 and bot_is_sup and trend_up ? "Trend Up" : run == 1 and not bot_is_sup and not trend_up ? "Trend Down" : run == 1 and not bot_is_sup and trend_up ? "Fall Spike Up" : market
    //Iterazioni post inizializzazione per incrociare i dati di start
    market := market == "Fall Spike Up" and bot_is_sup ? "Trend Up" : market
    market := market == "Fall Spike Up" and not trend_up ? "Trend Down" : market
    market := market == "Fall Accumula Liq" and trend_up ? "Trend Up" : market
    market := market == "Fall Accumula Liq" and not bot_is_sup ? "Trend Down" : market 
    market := market == "Trend Up" and not trend_up ? "Fall Accumula Liq" : market
    market := market == "Trend Down" and bot_is_sup ? "Fall Accumula Liq" : market 
    market := market == "Trend Down" and trend_up ? "Fall Spike Up" : market
    //Iterazione per prevedere lo switch del trend verso l'alto 
    market := ((market == "Fall Accumula Liq" or market == "Trend Down") and (high >upperEndPrice_lr or ema_over_lr)) ? "Switch Up Trend" : market
    market := market == "Switch Up Trend" and trend_up ? "Trend Up" : market
    market := market == "Switch Up Trend" and low < bot_liq ? "Trend Down" : market 
    //Passaggio alle definizioni dei pattern di gioco 
    if market == "Fall Accumula Liq" or market == "Trend Up" or market == "Fall Spike Up" or market == "Switch Up Trend" or (market == "Trend Down" and pearson < 0.2 )
        active_mid_trade                := true 
    else 
        active_mid_trade                := false  
        market_buy_pattern              := "No Buy Pattern" 
    //
    //Impostazione degli scenari quando l'analisi di mercato fornisce un responso d'analisi
    if active_mid_trade 
        low_level := math.min(val_level, poc_second_level)
        low_level_perc = math.round(((low_level - bot) / global_distance) * 100)

        var bool break_control_vah   = false
        var bool break_control_poc   = false
        var bool break_control_val   = false
        var bool break_control_poc_2 = false

        //Controllo che i livelli siano sufficientemente sotto la posizione di break aperta, qualora ce ne fosse una. Aggiungo verifica livello per ottimizzare.
        break_control_vah   := ((na(break_start_perc) or (not na(break_start_perc)) and vah_perc   < (break_start_perc - (fib_perc_1)))) and vah_is_in_buy
        break_control_poc   := ((na(break_start_perc) or (not na(break_start_perc)) and poc_perc   < (break_start_perc - (fib_perc_1)))) and poc_is_in_buy
        break_control_val   := ((na(break_start_perc) or (not na(break_start_perc)) and val_perc   < (break_start_perc - (fib_perc_1)))) and val_is_in_buy
        break_control_poc_2 := ((na(break_start_perc) or (not na(break_start_perc)) and poc_2_perc < (break_start_perc - (fib_perc_1)))) and poc_2_is_in_buy

        poc_is_ready   = (((poc_perc   <= lower_lr_perc and pearson >= 0.3) or (poc_perc   <= lr_perc and pearson < 0.3)) and poc_perc <= fib_for_scenario)
        vah_is_ready   =  ((vah_perc   <= lower_lr_perc and pearson >= 0.3) or (vah_perc   <= lr_perc and pearson < 0.3)) and vah_perc   <= fib_for_scenario 
        val_is_ready   =  ((val_perc   <= lower_lr_perc and pearson >= 0.3) or (val_perc   <= lr_perc and pearson < 0.3)) and val_perc   <= fib_for_scenario  
        poc_2_is_ready =  ((poc_2_perc <= lower_lr_perc and pearson >= 0.3) or (poc_2_perc <= lr_perc and pearson < 0.3)) and poc_2_perc <= fib_for_scenario 

        //Definizione delle figure scenario under LR
        figura_poc_2_to_bot_target = break_control_poc_2 and poc_2_is_ready and (poc_2_perc > bot_liq_perc or (poc_2_perc < bot_liq_perc and not bot_liq_is_in_buy))

        figura_poc_2_to_bot_target_over_poc  := figura_poc_2_to_bot_target and poc_second_level > poc_level
        figura_vah_to_bot_target    := break_control_vah   and vah_is_ready and vah_perc > bot_liq_perc and not figura_poc_2_to_bot_target_over_poc 
        figura_poc_to_bot_target    := break_control_poc   and poc_is_ready and poc_perc > bot_liq_perc and not figura_poc_2_to_bot_target_over_poc and not figura_vah_to_bot_target 
        figura_val_to_bot_target    := break_control_val   and val_is_ready and (val_perc > bot_liq_perc or (val_perc < bot_liq_perc and not bot_liq_is_in_buy)) and not figura_poc_to_bot_target and not figura_poc_2_to_bot_target_over_poc and not figura_vah_to_bot_target
        figura_poc_2_to_bot_target_under_poc := figura_poc_2_to_bot_target and not figura_val_to_bot_target and not figura_poc_2_to_bot_target_over_poc and not figura_vah_to_bot_target and not figura_poc_to_bot_target and low_level == poc_second_level
        figura_bot_liq              := not figura_vah_to_bot_target and not figura_val_to_bot_target and not figura_poc_to_bot_target and not figura_poc_2_to_bot_target_over_poc and not figura_poc_2_to_bot_target_under_poc and bot_liq_is_in_buy
        figura_bot                  := not figura_vah_to_bot_target and not figura_val_to_bot_target and not figura_poc_to_bot_target and not figura_poc_2_to_bot_target_over_poc and not figura_poc_2_to_bot_target_under_poc and not figura_bot_liq
        if figura_bot
            market_buy_pattern := "Bot Buy Fig", start_perc := bot_is_sup ? 0 : old_sup_perc, target_buy_perc := start_perc
        if low_level <= lowerEndPrice_lr
            if not up_breakout or open_position_break > 0
                //Poc 2
                if market_buy_pattern != "Poc 2 Buy Fig" and figura_poc_2_to_bot_target_over_poc
                    market_buy_pattern := "Poc 2 Buy Fig", start_perc := poc_2_perc , target_buy_perc := start_perc
                if market_buy_pattern == "Poc 2 Buy Fig" and not figura_poc_2_to_bot_target_over_poc
                    market_buy_pattern := na, start_perc := na, target_buy_perc := na 
                //Vah
                if market_buy_pattern != "Vah Buy Fig" and figura_vah_to_bot_target 
                    market_buy_pattern := "Vah Buy Fig", start_perc := vah_perc, target_buy_perc := start_perc
                if market_buy_pattern == "Vah Buy Fig" and not figura_vah_to_bot_target
                    market_buy_pattern  := na, start_perc := na, target_buy_perc := na
                //Poc 
                if market_buy_pattern != "Poc Buy Fig" and figura_poc_to_bot_target
                    market_buy_pattern := "Poc Buy Fig", start_perc := poc_perc , target_buy_perc := start_perc
                if market_buy_pattern  == "Poc Buy Fig" and not figura_poc_to_bot_target
                    market_buy_pattern  := na, start_perc := na, target_buy_perc := na 
                //Val
                if market_buy_pattern != "Val Buy Fig" and figura_val_to_bot_target 
                    market_buy_pattern := "Val Buy Fig", start_perc := val_perc , target_buy_perc := start_perc
                if market_buy_pattern == "Val Buy Fig" and not figura_val_to_bot_target
                    market_buy_pattern := na, start_perc := na, target_buy_perc := na 
                //Poc 2
                if market_buy_pattern != "Poc 2 Buy Fig" and figura_poc_2_to_bot_target_under_poc
                    market_buy_pattern := "Poc 2 Buy Fig", start_perc := poc_2_perc , target_buy_perc := start_perc
                if market_buy_pattern == "Poc 2 Buy Fig" and not figura_poc_2_to_bot_target_under_poc and not figura_poc_2_to_bot_target_over_poc
                    market_buy_pattern := na, start_perc := na, target_buy_perc := na 
                //Bot Liq
                if market_buy_pattern != "Bot Liq Fig" and figura_bot_liq 
                    market_buy_pattern := "Bot Liq Fig", target_buy_perc := bot_is_sup ? bot_liq_perc : old_sup_perc 
                if market_buy_pattern == "Bot Liq Fig" and not figura_bot_liq
                    market_buy_pattern  := na, target_buy_perc := na 
            else 
                market_buy_pattern := "Break-out Fig" 
            //
        //Definizione delle figure scenario over lower LR
        poc_is_ready_low   = (poc_perc  <= lr_perc and poc_perc <= fib_for_scenario_low) 
        vah_is_ready_low   = vah_perc   <= lr_perc and vah_perc   <= fib_for_scenario_low 
        val_is_ready_low   = val_perc   <= lr_perc and val_perc   <= fib_for_scenario_low  
        poc_2_is_ready_low = poc_2_perc <= lr_perc and poc_2_perc <= fib_for_scenario_low 
        figura_poc_2_to_bot_target_low = break_control_poc_2 and poc_2_is_ready_low and (poc_2_perc > bot_liq_perc or (poc_2_perc < bot_liq_perc and not bot_liq_is_in_buy))  
        figura_poc_2_to_bot_target_low_over_poc     := figura_poc_2_to_bot_target_low and poc_second_level > poc_level
        figura_vah_to_bot_target_low    := break_control_vah and vah_is_ready_low and vah_perc > bot_liq_perc and not figura_poc_2_to_bot_target_low_over_poc 
        figura_poc_to_bot_target_low    := break_control_poc and poc_is_ready_low and poc_perc > bot_liq_perc and not figura_poc_2_to_bot_target_low_over_poc and not figura_vah_to_bot_target_low 
        figura_val_to_bot_target_low    := break_control_val and val_is_ready_low and (val_perc > bot_liq_perc or (val_perc < bot_liq_perc and not bot_liq_is_in_buy)) and not figura_poc_to_bot_target_low and not figura_poc_to_bot_target_low and not figura_poc_2_to_bot_target_low_over_poc and not figura_vah_to_bot_target_low
        figura_poc_2_to_bot_target_low_under_poc    := figura_poc_2_to_bot_target_low and not figura_val_to_bot_target_low and not figura_poc_2_to_bot_target_low_over_poc and not figura_vah_to_bot_target_low and not figura_poc_to_bot_target_low and low_level == poc_second_level
        figura_bot_liq_low             := not figura_vah_to_bot_target_low and not figura_val_to_bot_target_low and not figura_poc_to_bot_target_low and not figura_poc_2_to_bot_target_low_over_poc and not figura_poc_2_to_bot_target_low_under_poc and bot_liq_is_in_buy
        figura_bot_low                 := not figura_vah_to_bot_target_low and not figura_val_to_bot_target_low and not figura_poc_to_bot_target_low and not figura_poc_2_to_bot_target_low_over_poc and not figura_poc_2_to_bot_target_low_under_poc and not figura_bot_liq_low
        if (low_level > lowerEndPrice_lr or (market == "Switch Up Trend" and not trend_up and pearson < 0.5)) //Ricerca di scenari più bassi quando il poc è compreso nella lr
            if not up_breakout or open_position_break > 0
                if figura_bot_low
                    market_buy_pattern := "Bot Buy Fig", start_perc := bot_is_sup ? 0 : old_sup_perc, target_buy_perc := start_perc
                //Poc 2
                if market_buy_pattern != "Poc 2 Buy Fig" and figura_poc_2_to_bot_target_low_over_poc
                    market_buy_pattern := "Poc 2 Buy Fig", start_perc := poc_2_perc , target_buy_perc := start_perc
                if market_buy_pattern == "Poc 2 Buy Fig" and not figura_poc_2_to_bot_target_low_over_poc
                    market_buy_pattern := na, start_perc := na, target_buy_perc := na 
                //Vah
                if market_buy_pattern != "Vah Buy Fig" and figura_vah_to_bot_target_low 
                    market_buy_pattern := "Vah Buy Fig", start_perc := vah_perc, target_buy_perc := start_perc
                if market_buy_pattern == "Vah Buy Fig" and not figura_vah_to_bot_target_low
                    market_buy_pattern  := na, start_perc := na, target_buy_perc := na 
                //Poc 
                if market_buy_pattern != "Poc Buy Fig" and figura_poc_to_bot_target_low
                    market_buy_pattern := "Poc Buy Fig", start_perc := poc_perc , target_buy_perc := start_perc
                if market_buy_pattern  == "Poc Buy Fig" and not figura_poc_to_bot_target_low
                    market_buy_pattern  := na, start_perc := na, target_buy_perc := na 
                //Val
                if market_buy_pattern != "Val Buy Fig" and figura_val_to_bot_target_low
                    market_buy_pattern := "Val Buy Fig", start_perc := val_perc , target_buy_perc := start_perc
                if market_buy_pattern == "Val Buy Fig" and not figura_val_to_bot_target_low
                    market_buy_pattern := na, start_perc := na, target_buy_perc := na 
                //Poc 2
                if market_buy_pattern != "Poc 2 Buy Fig" and figura_poc_2_to_bot_target_low_under_poc
                    market_buy_pattern := "Poc 2 Buy Fig", start_perc := poc_2_perc, target_buy_perc := start_perc
                if market_buy_pattern == "Poc 2 Buy Fig" and not figura_poc_2_to_bot_target_low_under_poc and not figura_poc_2_to_bot_target_low_over_poc
                    market_buy_pattern := na, start_perc := na, target_buy_perc := na 
                //Bot Liq
                if market_buy_pattern != "Bot Liq Fig" and figura_bot_liq_low
                    market_buy_pattern := "Bot Liq Fig", target_buy_perc := bot_is_sup ? bot_liq_perc : old_sup_perc
                if market_buy_pattern == "Bot Liq Fig" and not figura_bot_liq_low
                    market_buy_pattern  := na , target_buy_perc := na
            else 
                market_buy_pattern := "Break-out Fig" 
            //
        if market_buy_pattern == "Break-out Fig"
            if poc_second_level > poc_level 
                if poc_perc < fib_for_break and poc_is_in_buy and poc_perc < top_liq_perc - 12
                    market_buy_pattern := "Poc Break", target_buy_perc := poc_perc, break_with_res := not na(old_res) ? true : false 
                if (vah_perc < fib_for_break) and vah_is_in_buy and vah_perc < top_liq_perc - 12
                    market_buy_pattern := "Vah Break", target_buy_perc := vah_perc, break_with_res := not na(old_res) ? true : false 
                if poc_2_perc < fib_for_break and poc_2_is_in_buy and poc_2_perc < top_liq_perc - 12
                    target_buy_perc := poc_2_perc, market_buy_pattern := "Poc 2 Break", break_with_res := not na(old_res) ? true : false 
            //Inverto la stessa struttura perchè il poc 2 può essere sotto o sopra il blocco va
            if poc_second_level < poc_level 
                if poc_2_perc < fib_for_break and poc_2_is_in_buy and poc_2_perc < top_liq_perc - 12
                    market_buy_pattern := "Poc 2 Break", target_buy_perc := poc_2_perc, break_with_res := not na(old_res) ? true : false 
                if poc_perc < fib_for_break and poc_is_in_buy and poc_perc < top_liq_perc - 12
                    market_buy_pattern := "Poc Break", target_buy_perc := poc_perc , break_with_res := not na(old_res) ? true : false 
                if (vah_perc < fib_for_break) and vah_is_in_buy and vah_perc < top_liq_perc - 12
                    market_buy_pattern := "Vah Break", target_buy_perc := vah_perc, break_with_res := not na(old_res) ? true : false 
            //
            if market_buy_pattern == "Break-out Fig" and (figura_val_to_bot_target or figura_val_to_bot_target_low)
                market_buy_pattern := "Val Buy Fig", start_perc :=val_perc, target_buy_perc := val_perc, break_with_res := not na(old_res) ? true : false 
            market_buy_pattern := market_buy_pattern == "Break-out Fig" ? "No data after break" : market_buy_pattern
        //Scenario Max - l'idea è che lo sfondamento di una lr mobile indica un volume che ha nettamente rotto il trend. Sarebbe opportuno iterare la Siffredi solo quando real_pearson < -0.9/0.8 in questo modo mi assicuro che quel trend sta davvero cadendo
        if  market == "Switch Up Trend" and not trend_up and pearson >= 0.5 
            market_buy_pattern := "Siffredi", target_buy_perc := poc_2_is_in_buy and poc_2_perc > poc_perc ? poc_2_perc : vah_is_in_buy ? vah_perc : poc_is_in_buy ? poc_perc : val_is_in_buy ? val_perc : poc_2_is_in_buy and poc_2_perc < poc_perc ? poc_2_perc : bot_liq_perc

    //
    scenario_actual_over_bot_pattern := actual_support_over_bot_perc < lower_lr_perc and actual_supporto > bot and bot_is_sup and act_sup_is_in_buy and (actual_supporto < mid_ask or na(mid_ask)) and 
                                      ((market_buy_pattern == "Vah Buy Fig" and actual_support_over_bot_perc > vah_perc) or (market_buy_pattern == "Val Buy Fig" and actual_support_over_bot_perc > val_perc) or (market_buy_pattern == "Poc Buy Fig" and actual_support_over_bot_perc > poc_perc) or
                                      (market_buy_pattern == "Poc 2 Buy Fig" and actual_support_over_bot_perc > poc_2_perc) or (market_buy_pattern == "Bot Liq Fig" and actual_support_over_bot_perc > bot_liq_perc))
[_actual_supporto_poc_perc, _target_buy_perc, _market_buy_pattern] = M2.processActualBotPattern(actual_supporto_poc_perc, target_buy_perc, market_buy_pattern, scenario_actual_bot_line, scenario_actual_over_bot_pattern,peak_level_perc, peak_level_ar, actual_support_over_bot_perc, lower_lr_perc, ema_perc, levels, sma_volumes, cnum)
actual_supporto_poc_perc := _actual_supporto_poc_perc
target_buy_perc := _target_buy_perc
market_buy_pattern := _market_buy_pattern
old_res_perc = math.round(((old_res - bot) / global_distance) * 100)

actual_supporto_poc_level := M2.get_level_from_perc(actual_supporto_poc_perc, old_sup_perc, old_sup, top, bot, old_res_perc, old_res, bot_liq_perc, bot_liq, val_perc, val_level, poc_perc, poc_level, vah_perc, vah_level, top_liq_perc, top_liq, poc_2_perc, poc_second_level, actual_support_over_bot_perc, actual_supporto, peak_level_perc, peak_level_ar)

scenario_actual_bot_line := line.new(x1 = support_switch_bar, y1 = actual_supporto_poc_level, x2 = bar_index, y2 = actual_supporto_poc_level, color = color.yellow, width = 1, force_overlay = true)    
//
// -------------------------------------}
// CMF
// ------------------------------------------------------------{
ad = close==high and close==low or high==low ? 0 : ((2*close-low-high)/(high-low))*volume
mf = (math.sum(ad, bbars) / math.sum(volume, bbars)) * 100  // Moltiplicato per 100!
score_new = barstate.isconfirmed ? 
         (mf > 80 ? 6 : mf > 60 ? 4 : mf > 20 ? 2 : 
         mf > -20 ? 0 : mf > -60 ? -2 : mf > -80 ? -4 : -6) : 0
volume_organisation_score = pearson_coeff_vol > 0.6 ? 6 : pearson_coeff_vol > 0.3 ? 4 : pearson_coeff_vol > 0.1 ? 2 : pearson_coeff_vol > -0.1 ? 0 : pearson_coeff_vol > -0.3 ? -2 : pearson_coeff_vol > -0.6 ? -4 : -6
score := score_new + volume_organisation_score
cmfPlot = plot(mf, 'Money Flow', color=na, display=display.none)  // Linea invisibile
zeroPlot = plot(0, 'Zero', color=na, display=display.none)        // Linea zero invisibile
hline(0, 'Mid Line', color=color.gray, linewidth=1, linestyle=hline.style_dotted)
fill(cmfPlot, zeroPlot, color=mf > 0 ? color.new(color.green, 70) : color.new(color.red, 70), title="CMF Fill")
regime := barstate.isconfirmed ? (mf > 0 ? "Bull" : mf < 0 ? "Bear" : regime) : regime
M2.createCMFTable(mf)
// ----------------------------------------}
//Gestione dei livelli di target
// -----------------------------------------------------------{
//Determino livelli e percentuali del livello di apertura delle posizioni mid, la struttura differisce dalle altre per diversa predisposizione iniziale 
if open_position_mid == 0 
    save_start_perc := start_perc 
    save_start_perc_bool := false  
if open_position_mid > 0 and not save_start_perc_bool
    save_start_perc := math.round(((mid_ask - bot) / global_distance) * 100)
    save_start_perc_bool := true 
//
save_start_perc := save_start_perc_bool and bot != bot[1] ? math.round(((mid_ask - bot) / global_distance) * 100) : save_start_perc
//Determino livelli e percentuali del livello di apertura delle posizioni break, viene mantenuto nei cicli per evitare partenze rapide dalla mid quando viene appena triggerata la break
break_ask_perc := not na(break_ask) ? math.round(((break_ask - bot) / global_distance) * 100) : na 
//Determino livelli e percentuali del livello di apertura delle posizioni bot
bot_liq_perc_used = na(first_bot_liq) ? bot_liq_perc : scenario_bot_1_string_start == "scenario_bot" ? math.round(((first_bot_liq - bot) / global_distance) * 100) : math.round(((first_bot - bot) / global_distance) * 100)
//Determino livelli e percentuali del livello di apertura delle posizioni siffredi
siffredi_ask_perc := not na(siffredi_ask) ? math.round(((siffredi_ask - bot) / global_distance) * 100) : 25 
//Determino livelli e percentuali del livello di apertura delle posizioni cover, utilizzo un blocco singolo per ogni cover per ottimizzare la computazione 
cover_1_ask      = not na(scenario_cover_1_ask_to_l) or not na(scenario_cover_1_ask_to_h) ? math.min(scenario_cover_1_ask_to_l, scenario_cover_1_ask_to_h) : na
cover_1_ask_perc = not na(scenario_cover_1_ask_to_l) or not na(scenario_cover_1_ask_to_h) ? math.round(((cover_1_ask - bot) / global_distance) * 100) : na
cover_2_ask      = not na(scenario_cover_2_ask_to_l) or not na(scenario_cover_2_ask_to_h) ? math.min(scenario_cover_2_ask_to_l, scenario_cover_2_ask_to_h) : na
cover_2_ask_perc = not na(scenario_cover_2_ask_to_l) or not na(scenario_cover_2_ask_to_h) ? math.round(((cover_2_ask - bot) / global_distance) * 100) : na
cover_3_ask      = not na(scenario_cover_3_ask_to_l) or not na(scenario_cover_3_ask_to_h) ? math.min(scenario_cover_3_ask_to_l, scenario_cover_3_ask_to_h) : na
cover_3_ask_perc = not na(scenario_cover_3_ask_to_l) or not na(scenario_cover_3_ask_to_h) ? math.round(((cover_3_ask - bot) / global_distance) * 100) : na
cover_4_ask      = not na(scenario_cover_4_ask_to_l) or not na(scenario_cover_4_ask_to_h) ? math.min(scenario_cover_4_ask_to_l, scenario_cover_4_ask_to_h) : na
cover_4_ask_perc = not na(scenario_cover_4_ask_to_l) or not na(scenario_cover_4_ask_to_h) ? math.round(((cover_4_ask - bot) / global_distance) * 100) : na
//Livello di simulazione per gestione arrow
simulato_break = (market_buy_pattern == "Poc Break" or market_buy_pattern == "Poc 2 Break" or market_buy_pattern == "Vah Break") ? true : false
target_buy_perc := (na(target_buy_perc) or market_buy_pattern == "No Buy Pattern" ) ? old_sup_perc : target_buy_perc
// Popolamento struttura vettoriale con parametrizzazione sequenziale dei livelli di target
array.clear(orig_perc_array)
orig_perc_array := M2.populate_orig_perc_array(bot_liq_perc, val_perc, poc_perc, vah_perc, top_liq_perc, poc_2_perc, peak_level_perc)
//
[lower_target_simulato, higher_target_simulato] = M2.calculate_target_percentages(orig_perc_array, target_buy_perc, sentiment_level, timeframe_level, fib_perc_1, fib_perc_2, fib_perc_3, fib_perc_4, fib_perc_5, fib_perc_6, break_with_res, old_res_perc)
simulato_level = M2.get_level_from_perc(target_buy_perc, old_sup_perc, old_sup, top, bot, old_res_perc, old_res, bot_liq_perc, bot_liq, val_perc, val_level, poc_perc, poc_level, vah_perc, vah_level, top_liq_perc, top_liq, poc_2_perc, poc_second_level, actual_support_over_bot_perc, actual_supporto, peak_level_perc, peak_level_ar)
simulato_lower_target_tupla   = M2.get_level_from_perc(lower_target_simulato, old_sup_perc, old_sup, top, bot, old_res_perc, old_res, bot_liq_perc, bot_liq, val_perc, val_level, poc_perc, poc_level, vah_perc, vah_level, top_liq_perc, top_liq, poc_2_perc, poc_second_level, actual_support_over_bot_perc, actual_supporto, peak_level_perc, peak_level_ar)
simulato_higher_target_tupla := M2.get_level_from_perc(higher_target_simulato, old_sup_perc, old_sup, top, bot, old_res_perc, old_res, bot_liq_perc, bot_liq, val_perc, val_level, poc_perc, poc_level, vah_perc, vah_level, top_liq_perc, top_liq, poc_2_perc, poc_second_level, actual_support_over_bot_perc, actual_supporto, peak_level_perc, peak_level_ar)
simulato_higher_target_tupla := simulato_break and low_perc_fib == 5 and not na(old_res) ? old_res : simulato_higher_target_tupla
//Target break 
[break_lower_target_perc_tupla, break_higher_target_perc_tupla] = M2.calculate_target_percentages(orig_perc_array, break_ask_perc, sentiment_level, timeframe_level, fib_perc_1, fib_perc_2, fib_perc_3, fib_perc_4, fib_perc_5, fib_perc_6, break_with_res, old_res_perc)
break_lower_target_tupla  = M2.get_level_from_perc(break_lower_target_perc_tupla, old_sup_perc, old_sup, top, bot, old_res_perc, old_res, bot_liq_perc, bot_liq, val_perc, val_level, poc_perc, poc_level, vah_perc, vah_level, top_liq_perc, top_liq, poc_2_perc, poc_second_level, actual_support_over_bot_perc, actual_supporto, peak_level_perc, peak_level_ar)
break_higher_target_tupla = M2.get_level_from_perc(break_higher_target_perc_tupla, old_sup_perc, old_sup, top, bot,old_res_perc, old_res, bot_liq_perc, bot_liq, val_perc, val_level, poc_perc, poc_level, vah_perc, vah_level, top_liq_perc, top_liq, poc_2_perc, poc_second_level, actual_support_over_bot_perc, actual_supporto, peak_level_perc, peak_level_ar)
//Target Siffredi
[siffredi_lower_target_perc_tupla, siffredi_higher_target_perc_tupla] = M2.calculate_target_percentages(orig_perc_array, siffredi_ask_perc, sentiment_level, timeframe_level, fib_perc_1, fib_perc_2, fib_perc_3, fib_perc_4, fib_perc_5, fib_perc_6, break_with_res, old_res_perc)
siffredi_lower_target_tupla  = M2.get_level_from_perc(siffredi_lower_target_perc_tupla, old_sup_perc, old_sup, top, bot, old_res_perc, old_res, bot_liq_perc, bot_liq, val_perc, val_level, poc_perc, poc_level, vah_perc, vah_level, top_liq_perc, top_liq, poc_2_perc, poc_second_level, actual_support_over_bot_perc, actual_supporto, peak_level_perc, peak_level_ar)
siffredi_higher_target_tupla = M2.get_level_from_perc(siffredi_higher_target_perc_tupla, old_sup_perc, old_sup, top, bot,old_res_perc, old_res, bot_liq_perc, bot_liq, val_perc, val_level, poc_perc, poc_level, vah_perc, vah_level, top_liq_perc, top_liq, poc_2_perc, poc_second_level, actual_support_over_bot_perc, actual_supporto, peak_level_perc, peak_level_ar)
// Target del livello bot liq posizione 1-2
[lower_target_bot_perc_tupla, higher_target_bot_perc_tupla] = M2.calculate_target_percentages(orig_perc_array, bot_liq_perc_used, sentiment_level, timeframe_level, fib_perc_1, fib_perc_2, fib_perc_3, fib_perc_4, fib_perc_5, fib_perc_6, break_with_res, old_res_perc)
lower_target_bot_tupla  = M2.get_level_from_perc(lower_target_bot_perc_tupla, old_sup_perc, old_sup, top, bot,  old_res_perc, old_res, bot_liq_perc, bot_liq, val_perc, val_level, poc_perc, poc_level, vah_perc, vah_level, top_liq_perc, top_liq, poc_2_perc, poc_second_level, actual_support_over_bot_perc, actual_supporto, peak_level_perc, peak_level_ar)
higher_target_bot_tupla = M2.get_level_from_perc(higher_target_bot_perc_tupla, old_sup_perc, old_sup, top, bot, old_res_perc, old_res, bot_liq_perc, bot_liq, val_perc, val_level, poc_perc, poc_level, vah_perc, vah_level, top_liq_perc, top_liq, poc_2_perc, poc_second_level, actual_support_over_bot_perc, actual_supporto, peak_level_perc, peak_level_ar)
// Target per posizione 11 actual over bot 
[lower_target_act_sup_over_bot_perc_tupla, higher_target_act_sup_over_bot_perc_tupla] = M2.calculate_target_percentages(orig_perc_array, actual_supporto_poc_perc, sentiment_level, timeframe_level, fib_perc_1, fib_perc_2, fib_perc_3, fib_perc_4, fib_perc_5, fib_perc_6, break_with_res, old_res_perc)
lower_target_act_sup_over_bot_tupla = M2.get_level_from_perc(lower_target_act_sup_over_bot_perc_tupla, old_sup_perc, old_sup, top, bot, old_res_perc, old_res, bot_liq_perc, bot_liq, val_perc, val_level, poc_perc, poc_level, vah_perc, vah_level, top_liq_perc, top_liq, poc_2_perc, poc_second_level, actual_support_over_bot_perc, actual_supporto, peak_level_perc, peak_level_ar)
//Target per posizioni MID 12
[mid_lower_target_perc_tupla, mid_higher_target_perc_tupla] = M2.calculate_target_percentages(orig_perc_array, save_start_perc, sentiment_level, timeframe_level, fib_perc_1, fib_perc_2, fib_perc_3, fib_perc_4, fib_perc_5, fib_perc_6, break_with_res, old_res_perc)
mid_lower_target_tupla  = M2.get_level_from_perc(mid_lower_target_perc_tupla, old_sup_perc, old_sup, top, bot,  old_res_perc, old_res, bot_liq_perc, bot_liq, val_perc, val_level, poc_perc, poc_level, vah_perc, vah_level, top_liq_perc, top_liq, poc_2_perc, poc_second_level, actual_support_over_bot_perc, actual_supporto, peak_level_perc, peak_level_ar)
mid_higher_target_tupla = M2.get_level_from_perc(mid_higher_target_perc_tupla, old_sup_perc, old_sup, top, bot, old_res_perc, old_res, bot_liq_perc, bot_liq, val_perc, val_level, poc_perc, poc_level, vah_perc, vah_level, top_liq_perc, top_liq, poc_2_perc, poc_second_level, actual_support_over_bot_perc, actual_supporto, peak_level_perc, peak_level_ar)
//Target per posizioni Cover 1
[cover_1_lower_target_perc_tupla, cover_1_higher_target_perc_tupla] = M2.calculate_target_percentages(orig_perc_array, cover_1_ask_perc, sentiment_level, timeframe_level, fib_perc_1, fib_perc_2, fib_perc_3, fib_perc_4, fib_perc_5, fib_perc_6, break_with_res, old_res_perc)
cover_1_lower_target_tupla  = M2.get_level_from_perc(cover_1_lower_target_perc_tupla, old_sup_perc, old_sup, top, bot,  old_res_perc, old_res, bot_liq_perc, bot_liq, val_perc, val_level, poc_perc, poc_level, vah_perc, vah_level, top_liq_perc, top_liq, poc_2_perc, poc_second_level, actual_support_over_bot_perc, actual_supporto, peak_level_perc, peak_level_ar)
cover_1_higher_target_tupla = M2.get_level_from_perc(cover_1_higher_target_perc_tupla, old_sup_perc, old_sup, top, bot, old_res_perc, old_res, bot_liq_perc, bot_liq, val_perc, val_level, poc_perc, poc_level, vah_perc, vah_level, top_liq_perc, top_liq, poc_2_perc, poc_second_level, actual_support_over_bot_perc, actual_supporto, peak_level_perc, peak_level_ar)
//Target per posizioni Cover 2
[cover_2_lower_target_perc_tupla, cover_2_higher_target_perc_tupla] = M2.calculate_target_percentages(orig_perc_array, cover_1_ask_perc, sentiment_level, timeframe_level, fib_perc_1, fib_perc_2, fib_perc_3, fib_perc_4, fib_perc_5, fib_perc_6, break_with_res, old_res_perc)
cover_2_lower_target_tupla  = M2.get_level_from_perc(cover_2_lower_target_perc_tupla, old_sup_perc, old_sup, top, bot,  old_res_perc, old_res, bot_liq_perc, bot_liq, val_perc, val_level, poc_perc, poc_level, vah_perc, vah_level, top_liq_perc, top_liq, poc_2_perc, poc_second_level, actual_support_over_bot_perc, actual_supporto, peak_level_perc, peak_level_ar)
cover_2_higher_target_tupla = M2.get_level_from_perc(cover_2_higher_target_perc_tupla, old_sup_perc, old_sup, top, bot, old_res_perc, old_res, bot_liq_perc, bot_liq, val_perc, val_level, poc_perc, poc_level, vah_perc, vah_level, top_liq_perc, top_liq, poc_2_perc, poc_second_level, actual_support_over_bot_perc, actual_supporto, peak_level_perc, peak_level_ar)
//Target per posizioni Cover 3
[cover_3_lower_target_perc_tupla, cover_3_higher_target_perc_tupla] = M2.calculate_target_percentages(orig_perc_array, cover_1_ask_perc, sentiment_level, timeframe_level, fib_perc_1, fib_perc_2, fib_perc_3, fib_perc_4, fib_perc_5, fib_perc_6, break_with_res, old_res_perc)
cover_3_lower_target_tupla  = M2.get_level_from_perc(cover_3_lower_target_perc_tupla, old_sup_perc, old_sup, top, bot,  old_res_perc, old_res, bot_liq_perc, bot_liq, val_perc, val_level, poc_perc, poc_level, vah_perc, vah_level, top_liq_perc, top_liq, poc_2_perc, poc_second_level, actual_support_over_bot_perc, actual_supporto, peak_level_perc, peak_level_ar)
cover_3_higher_target_tupla = M2.get_level_from_perc(cover_3_higher_target_perc_tupla, old_sup_perc, old_sup, top, bot, old_res_perc, old_res, bot_liq_perc, bot_liq, val_perc, val_level, poc_perc, poc_level, vah_perc, vah_level, top_liq_perc, top_liq, poc_2_perc, poc_second_level, actual_support_over_bot_perc, actual_supporto, peak_level_perc, peak_level_ar)
//Target per posizioni Cover 4
[cover_4_lower_target_perc_tupla, cover_4_higher_target_perc_tupla] = M2.calculate_target_percentages(orig_perc_array, cover_1_ask_perc, sentiment_level, timeframe_level, fib_perc_1, fib_perc_2, fib_perc_3, fib_perc_4, fib_perc_5, fib_perc_6, break_with_res, old_res_perc)
cover_4_lower_target_tupla  = M2.get_level_from_perc(cover_4_lower_target_perc_tupla, old_sup_perc, old_sup, top, bot,  old_res_perc, old_res, bot_liq_perc, bot_liq, val_perc, val_level, poc_perc, poc_level, vah_perc, vah_level, top_liq_perc, top_liq, poc_2_perc, poc_second_level, actual_support_over_bot_perc, actual_supporto, peak_level_perc, peak_level_ar)
cover_4_higher_target_tupla = M2.get_level_from_perc(cover_4_higher_target_perc_tupla, old_sup_perc, old_sup, top, bot, old_res_perc, old_res, bot_liq_perc, bot_liq, val_perc, val_level, poc_perc, poc_level, vah_perc, vah_level, top_liq_perc, top_liq, poc_2_perc, poc_second_level, actual_support_over_bot_perc, actual_supporto, peak_level_perc, peak_level_ar)

if barstate.isconfirmed and run > 0 
    siffredi_lower_target               := siffredi_lower_target_tupla
    siffredi_lower_target_perc          := siffredi_lower_target_perc_tupla
    siffredi_higher_target              := siffredi_higher_target_tupla
    siffredi_higher_target_perc         := siffredi_higher_target_perc_tupla
    lower_target_bot                    := lower_target_bot_tupla
    lower_target_bot_perc               := lower_target_bot_perc_tupla
    higher_target_bot                   := higher_target_bot_tupla
    higher_target_bot_perc              := higher_target_bot_perc_tupla
    actual_support_lower                := lower_target_act_sup_over_bot_tupla
    actual_support_lower_perc           := lower_target_act_sup_over_bot_perc_tupla
    mid_lower_target                    := mid_lower_target_tupla
    mid_lower_target_perc               := mid_lower_target_perc_tupla
    mid_higher_target                   := mid_higher_target_tupla
    mid_higher_target_perc              := mid_higher_target_perc_tupla
    cover_1_lower_target                := cover_1_lower_target_tupla 
    cover_1_lower_target_perc           := cover_1_lower_target_perc_tupla 
    cover_1_higher_target               := cover_1_higher_target_tupla
    cover_1_higher_target_perc          := cover_1_higher_target_perc_tupla
    cover_2_lower_target                := cover_2_lower_target_tupla 
    cover_2_lower_target_perc           := cover_2_lower_target_perc_tupla 
    cover_2_higher_target               := cover_2_higher_target_tupla
    cover_2_higher_target_perc          := cover_2_higher_target_perc_tupla
    cover_3_lower_target                := cover_3_lower_target_tupla 
    cover_3_lower_target_perc           := cover_3_lower_target_perc_tupla 
    cover_3_higher_target               := cover_3_higher_target_tupla
    cover_3_higher_target_perc          := cover_3_higher_target_perc_tupla
    cover_4_lower_target                := cover_4_lower_target_tupla 
    cover_4_lower_target_perc           := cover_4_lower_target_perc_tupla 
    cover_4_higher_target               := cover_4_higher_target_tupla
    cover_4_higher_target_perc          := cover_4_higher_target_perc_tupla
    break_lower_target                  := break_lower_target_tupla      
    break_lower_target_perc             := break_lower_target_perc_tupla            
    break_higher_target                 := break_higher_target_tupla            
    break_higher_target_perc            := break_higher_target_perc_tupla    
    //

// -------------------------------------}
// Iterazioni di run out candle e tabella finale 
// -----------------------------------------------------------{
//Contatore BBars aggiornato a fine iterazione per evitare bar + 1 nel contatore candele e salvataggio liquidità iniziale quando vengono superate le bbars massime (bbars_reach)
contatore := run > 0 and contatore < (bar_limit - original_bbars) and block_start_bar and ancoraggio_pivot ? contatore + 1 : contatore
//
if block_start_bar and switch_supporto and not na(save_bot_liq)
    save_bot_liq := na
    save_top_liq := na
//
if run > 0 and (contatore + bbars) >= bar_limit and block_start_bar and na(save_bot_liq)
    save_bot_liq := bot_liq
    save_top_liq := top_liq
//Conteggio globale posizioni 
tot_position := tot_position_cover + open_position_break + tot_position_scenario_bot + open_position_mid
//Determino il livello di fib da accettare in base al timeframe_level
if barstate.isconfirmed
    fib_for_break := timeframe_level < 2 ? (na(old_res) ? fib_perc_4 : fib_perc_5) : fib_perc_5
    fib_for_scenario := timeframe_level < 2 ? (sentiment_level < 7 ? fib_perc_3 : fib_perc_4) : (sentiment_level < 7 ? fib_perc_4 : fib_perc_5)
    fib_for_scenario_low := sentiment_level < 7 ? fib_perc_3 : fib_perc_4        
    //
    counting := counting < 1 ? counting + 1 : counting
//
// -------------------------------------}
//Candle/Volume Structure
// -----------------------------------------------------------{
[volume_ratio, spike_ratio, body_ratio, volume_up, volume_down, spike_up, spike_down, body_up, body_down] = M2.calculateMetrics(bbars)
// -------------------------------------}
// Tabella
// -----------------------------------------------------------{
//Stabilisco il livello massimo di cover ancora posizionato
low_cover_level = tot_sup == 4 ? old_sup_3 : tot_sup == 3 ? old_sup_2 : tot_sup == 2 ? old_sup_1 : tot_sup == 1 ? old_sup : na 
// Calcola la gestione percentuale dei supporti Cover
diff_percentage = 100 - (((low_cover_level / close ) * 100))
// Tabella unificata ottimizzata
run := run == 3 and bbars < bbars[1] ? 2 : run
run_result = M2.check_alerts(run, bbars, bar_limit, poc_level, poc_level[1], bot_liq, timeframe_level, up_breakout, up_breakout[1], down_breakout, down_breakout[1], bot) 
run := run_result == 1 and barstate.isconfirmed ? run + 1 : run 
M2.tabella_completa(percent_change, real_pearson, costituzione_volume , market, market_buy_pattern, diff_percentage, bot, top, bot_is_sup, top_is_res,tot_sup, tot_res, titolo, spread, status_vix, headerColor, positiveColor, negativeColor, volume_ratio, spike_ratio, body_ratio,bbars, status_sdex)
M2.drawArrowsAndTable(simulato_level, simulato_lower_target_tupla, simulato_higher_target_tupla, sentiment_level, market_buy_pattern, old_sup)
// -------------------------------------}

